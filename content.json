{"pages":[{"title":"关于我","text":"高二Oier，来自北京。 曾获NOIP2016普及组三等奖，NOIP2017/2018提高组一等奖，WC2019铜牌。","link":"/about/index.html"}],"posts":[{"title":"【01Trie+Pruefer】51nod 1601 完全图的最小生成树计数","text":"题目大意有 $n$ 个点，每个点有点权 $a_i$，点 $u,v$ 之间的边边权为 $a_u \\oplus a_v$。求该完全图的最小生成树的权值与方案数。 数据范围$n\\leq 10^5$$0\\leq a_i&lt; 2^{30}$ 分析从边权为点xor得到，想到可以对点权建立Trie树。 每次合并两子树mst的权值，并加入两子树中节点可以xor得到的最小值作为连接这两棵子树的最小边，自下而上得到整棵Trie的mst的值。 根据Cayley公式，如果存在有 $a(a&gt;2)$ 个相同权值的点时，生成树的方案数为 $a^{a-2}$。每次合并两子树时对方案数做乘法原理即可得到最终的方案数。 复杂度 $O(n\\log{a_i})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 22:59:31 * @LastEditTime: 2019-01-26 23:41:49 * @Source: 51nod * @Problem: 1601 完全图的最小生成树计数 * @Url: https://www.51nod.com/Challenge/Problem.html#!#problemId=1601 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1e5 + 5;const int MOD = 1e9 + 7;int N;int Ch[MAXN &lt;&lt; 5][2], Num[MAXN &lt;&lt; 5], cnt = 1;long long sum, num = 1;void insert(int val) { int x = 1; for (int i = 29; i &gt;= 0; --i) { int d = (val &gt;&gt; i) &amp; 1; if (!Ch[x][d]) { Ch[x][d] = ++cnt; } x = Ch[x][d]; } ++Num[x];}long long poww(long long x, long long t) { long long ans = 1; for (; t; t &gt;&gt;= 1) { if (t &amp; 1) { ans = ans * x % MOD; } x = x * x % MOD; } return ans;}long long min, tmp;void getMin(int x, int y, int d, int v = 0) { if (d &lt; 0) { if (v &lt; min) { min = v; tmp = (long long)Num[x] * Num[y] % MOD; } else if (v == min) { tmp = (tmp + (long long)Num[x] * Num[y]) % MOD; } return; } if (Ch[x][0] &amp;&amp; Ch[y][0]) { getMin(Ch[x][0], Ch[y][0], d - 1, v); if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } } else if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } else { if (Ch[x][0]) { getMin(Ch[x][0], Ch[y][1], d - 1, v + (1 &lt;&lt; d)); } if (Ch[x][1]) { getMin(Ch[x][1], Ch[y][0], d - 1, v + (1 &lt;&lt; d)); } }}void cal(int x, int d) { if (d &lt; 0) { if (Num[x] &gt; 1) { num = num * poww(Num[x], Num[x] - 2); } return; } if (!Ch[x][0]) { cal(Ch[x][1], d - 1); } else if (!Ch[x][1]) { cal(Ch[x][0], d - 1); } else { cal(Ch[x][0], d - 1); cal(Ch[x][1], d - 1); min = 1 &lt;&lt; 30; tmp = 0; getMin(Ch[x][0], Ch[x][1], d - 1, 0); sum = sum + (1 &lt;&lt; d) + min; num = (num * tmp) % MOD; }}int main() { scanf(\"%d\", &amp;N); int x; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); insert(x); } cal(1, 29); printf(\"%lld\\n%lld\\n\", sum, num); return 0;}","link":"/51nod-1601/"},{"title":"【差分约束】[SCOI 2011] BZOJ 2330 糖果","text":"有 $N$ 个数 $A1\\cdots N$，要求满足 $M$ 个条件。条件形如： $A[i] \\leq A[j]$，$A[i] &lt; A[j]$， $A[i] = A[j]$ 。如果可以满足所有条件，求 $\\sum{A_i}$ 的最小值，否则输出 -1。 数据范围$N,M\\leq 100000$ 题目链接BZOJ 2330 题解将条件依次转化为 $A[j] - A[i] \\geq 0$，$A[j] - A[i]\\geq 1$，$A[j]-A[i]\\geq 0 \\&amp; A[i]-A[j]\\geq 0$。 根据 $u - v\\geq w$ 建有向边 $(v, u, w)$ 的方式建图，求最长路。 如果单纯通过spfa进队 $N$ 次来判断无解可能会导致超时，发现无解本质为出现正环。因此可以采用Tarjan求联通分量，判断各分量内是否存在非零边的方法做到 $O(N+M)$ 判断无解。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;const int MAXN = 100000 + 5;int N, K;struct Edge { int u, v, w, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;long long Dis[MAXN];bool Inq[MAXN];long long spfa() { for (int i = 1; i &lt;= N; ++i) { Dis[i] = 1; Que.push(i); } while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &lt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } long long res = 0; for (int i = 1; i &lt;= N; ++i) { res += Dis[i]; } return res;}int Dfn[MAXN], Low[MAXN], cntD;int Stk[MAXN], top;int Belong[MAXN], cntB;void dfs(int x) { Dfn[x] = Low[x] = ++cntD; Stk[++top] = x; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (!Dfn[v]) { dfs(v); Low[x] = std::min(Low[x], Low[v]); } else if (!Belong[v]) { Low[x] = std::min(Low[x], Dfn[v]); } } if (Dfn[x] == Low[x]) { Belong[x] = ++cntB; do { Belong[Stk[top]] = cntB; } while (Stk[top--] != x); }}int main() { int opt, x, y; scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 1; i &lt;= K; ++i) { scanf(\"%d%d%d\", &amp;opt, &amp;x, &amp;y); if (opt == 1) { addEdge(x, y, 0); addEdge(y, x, 0); } else if (opt == 2) { addEdge(x, y, 1); } else if (opt == 3) { addEdge(y, x, 0); } else if (opt == 4) { addEdge(y, x, 1); } else if (opt == 5) { addEdge(x, y, 0); } if (opt % 2 == 0 &amp;&amp; x == y) { puts(\"-1\"); return 0; } } for (int i = 1; i &lt;= N; ++i) { if (!Dfn[i]) { dfs(i); } } bool flag = 0; for (int i = 1; i &lt;= cntE; ++i) { if (E[i].w &amp;&amp; Belong[E[i].u] == Belong[E[i].v]) { flag = 1; break; } } if (flag) { puts(\"-1\"); } else { printf(\"%lld\\n\", spfa()); } return 0;}","link":"/BZOJ-2330/"},{"title":"【差分约束】[HNOI 2005] BZOJ 1202 狡猾的商人","text":"给定 $M$ 组关于 $l, r, x$ 的等式，意为 $\\sum\\limits_{i=l}^{r}{A_i}=x$，判断是否可以构造出 $A[1\\cdots N]$ 满足这些等式。 数据范围$N\\leq 100,M\\leq 1000$ 题目链接BZOJ 1202 题解将等式写成前缀和的形式，用 $Sum[i]$ 表示 $\\sum\\limits_{j=1}^{i}{A_j}$ ，等式化为 $Sum[r] - Sum[l-1] = x$。 可以将等式变形成两个不等式， $Sum[r] - Sum[l-1] \\geq x$ 和 $Sum[l - 1] - Sum[r] \\geq -x$ 。 那么原问题就转化为差分约束系统求解模型。连接边 $(l - 1, r, x)$ 和 $(r, l - 1, -x)$ ，SPFA判断是否存在负环，复杂度 $O(NM)$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;const int MAXM = 1000 + 5;int N, M;struct Edge { int v, w, nxt;} E[MAXM * 3];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;int Dis[MAXN], Cnt[MAXN], Inq[MAXN];bool Vis[MAXN];int n;bool spfa() { while (!Que.empty()) { Que.pop(); } memset(Dis, 0x3f, sizeof Dis); memset(Inq, 0, sizeof Inq); memset(Cnt, 0, sizeof Cnt); Que.push(N + 1); Dis[N + 1] = 0; while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Cnt[v] = Cnt[x] + 1; if (Cnt[v] &gt; n) { return false; } if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } return true;}void init() { cntE = 0; memset(H, 0, sizeof H); n = 0; memset(Vis, 0, sizeof Vis);}int main() { int T, u, v, w; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); init(); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); if (!Vis[u - 1]) { Vis[u - 1] = 1; ++n; } if (!Vis[v]) { Vis[v] = 1; ++n; } addEdge(u - 1, v, -w); addEdge(v, u - 1, w); } for (int i = 1; i &lt;= N; ++i) { addEdge(N + 1, i, 0); } if (spfa()) { puts(\"true\"); } else { puts(\"false\"); } } return 0;}","link":"/BZOJ-1202/"},{"title":"【最小割树】[ZJOI 2011] BZOJ 2229 最小割","text":"题目大意$T$ 组数据，$Q$ 个询问。在无向图 $G$ 中，求有多少个点对 $(s,t)$ 使得它们之间的最小割不超过 $x$。 数据范围$T\\leq 10$$n\\leq 150$$m\\leq 3000$$q\\leq 30$ 分析建完最小割树后，问题转化为求树上有多少个点对路径上的边权最小值不超过 $x$。 枚举点对再用倍增判断，复杂度 $O(n^2\\log{n})$。 也存在线性做法，对于边权不超过 $x$ 的边，统计路径通过该边新增的点对数量，复杂度 $O(n)$。 然而由于复杂度瓶颈在建立最小割树上，因此两种方法实际效率相仿。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* * @Author: Skqliao * @Date: 2019-02-02 22:57:06 * @LastEditTime: 2019-02-03 11:53:06 * @Source: ZJOI 2011 * @Problem: 2229: [Zjoi2011]最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2229 */#include &lt;bits/stdc++.h&gt;const int MAXN = 150 + 5;const int MAXM = 3000 + 5;namespace GH_Tree {struct Edge { int v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge){v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, w, H[v]}; H[v] = cntE;}int Fa[MAXN], Sz[MAXN];int dfs(int x) { Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; Sz[x] += dfs(v); } } return Sz[x];}int ans;int dfs(int x, int sz, int mx) { int tot = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { if (E[i].w &lt;= mx) { tot += Sz[v]; ans += Sz[v] * (sz - Sz[v]); sz -= Sz[v]; dfs(v, Sz[v], mx); } else { int tmp = dfs(v, sz, mx); sz -= tmp; tot += tmp; } } } return tot;}void init() { cntE = 0; memset(H, 0, sizeof H);}int query(int x) { ans = 0; dfs(1, Sz[1], x); return ans;}namespace Init { struct Edge { int v, f, cap, nxt; } E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; int Idx[MAXN], Tmp[MAXN]; int S, T; int Dis[MAXN], Cur[MAXN]; int Col[MAXN]; void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; } } void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE; } bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false; } int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left; } int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow; } void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); } } void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); GH_Tree::addEdge(S, T, f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r); } void solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); }} // namespace Init} // namespace GH_Treeint T, N, M, Q;int main() { int x; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); GH_Tree::init(); GH_Tree::Init::solve(N, M); GH_Tree::dfs(1); scanf(\"%d\", &amp;Q); while (Q--) { scanf(\"%d\", &amp;x); printf(\"%d\\n\", GH_Tree::query(x)); } puts(\"\"); } return 0;}","link":"/BZOJ-2229/"},{"title":"【最小割树】[CQOI 2016] BZOJ 4519 不同的最小割","text":"题目大意在无向图 $G$ 中，对于任意点对 $(i,j)$ 有最小割 $cut(i,j)$，求有多少个数值不同的最小割。 数据范围$N\\leq 850$$M\\leq 8500$ 分析最小割树模板题，求出最小割树后将所有边unique得到答案。 复杂度 $O(n\\times f)$，$f$ 为最大流复杂度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* * @Author: Skqliao * @Date: 2019-02-02 22:26:52 * @LastEditTime: 2019-02-02 22:54:36 * @Source: CQOI 2016 * @Problem: 4519: [Cqoi2016]不同的最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4519 */#include &lt;bits/stdc++.h&gt;const int MAXN = 850 + 5;const int MAXM = 8500 + 5;namespace GH_Tree {struct Edge { int v, f, cap, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Idx[MAXN], Tmp[MAXN];int S, T;int Dis[MAXN], Cur[MAXN];int Col[MAXN];void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; }}void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow;}void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); }}std::vector&lt;int&gt; V;void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); V.push_back(f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r);}int solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); std::sort(V.begin(), V.end()); V.erase(std::unique(V.begin(), V.end()), V.end()); return V.size();}} // namespace GH_Treeint N, M;int main() { scanf(\"%d%d\", &amp;N, &amp;M); printf(\"%d\\n\", GH_Tree::solve(N, M)); return 0;}","link":"/BZOJ-4519/"},{"title":"【最小割】[2010 集训队测验] BZOJ 2127 文理分科","text":"题目大意在 $n\\times m$ 的矩阵中，每个格子可以选择 $0/1$，分别获得收益 $A_{i,j},B_{i,j}$。如果上下两个格子选择相同，则额外获得收益 $C_{i,j},D_{i,j}$（都选$0/1$），如果左右两个格子选择相同，则额外获得收益 $E_{i,j},F_{i,j}$。求总收益的最大值。 数据范围$n,m\\leq 100$ $A,B,C,D,E,F_{i,j}\\leq 5000$ 分析这是集训队论文《浅谈一类最小割问题》中的例题，也是网络流建模之二元关系的一道典型题目。 根据相关建图模型，对于每个点 $x$，分别与 $S,T$ 连边，割去 $(S,x)$表示选择文科，割去 $(x,T)$ 表示选择理科。 由于只能求最小割，因此可以先累计所有收益再减去最小割得到最大值。 由于每个点与相邻的点之间的选择会影响结果，因此 $x$ 与相邻的点连边。 对于任意两个相邻点 $x,y$，子图有边 $(S,x),(S,y),(x,y),(y,x),(x,T),(y,T)$。 割去 $(S,x),(S,y)$ 表示都选文，割去 $(x,T),(y,T)$ 表示都选理，割去 $(S,x),(x,y),(y,T)$ 表示 $x$ 选文，$y$选理，剩下一种情况同理第三种。 假设 $x,y$ 选文的收益分别为 $a_x,a_y$，选理的收益为 $b_x,b_y$，都选文/理的收益为 $c,d$，则边权应满足： $$(S,x)+(S,y)=b_x+b_y+d\\(x,T)+(y,T)=a_x+a_y+c\\(S,x)+(x,y)+(y,T)=a_y+b_x+c+d\\(S,y)+(y,x)+(x,T)=a_x+b_y+c+d\\$$得到一组解： $$(x,y)=(y,x)=\\frac{c+d}{2}\\(S,x)=a_x+\\frac{c}{2}\\(S,y)=a_y+\\frac{c}{2}\\(x,T)=b_x+\\frac{d}{2}\\(y,T)=b_y+\\frac{d}{2}\\$$ 由此建图求最大流即可。 Tips：将两点间所有边的边权整合成一条边会大大提高运行速度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* * @Author: Skqliao * @Date: 2019-02-10 20:45:11 * @LastEditTime: 2019-02-10 21:37:48 * @Source: 2010 集训队测试题 * @Problem: 2127: happiness * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2127 */#include &lt;bits/stdc++.h&gt;namespace mxf {const int MAXN = 100 * 100 + 5;const int MAXM = MAXN * 4;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int S, T;int H[MAXN], cntE;void addEdge(int u, int v, int f, bool directed = 1) { E[++cntE] = (Edge){v, f, H[u]}; H[u] = cntE; if (directed) f = 0; E[++cntE] = (Edge){u, f, H[v]}; H[v] = cntE;}int Dis[MAXN], Cur[MAXN];bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memset(Dis, -1, sizeof Dis); memcpy(Cur, H, sizeof H); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) { flow += dfs(S, INT_MAX); } return flow;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}} // namespace mxfusing mxf::addEdge;using mxf::S;using mxf::T;const int MAXN = 100 + 5;int N, M;int Id[MAXN][MAXN];int A[MAXN][MAXN], B[MAXN][MAXN], C[MAXN][MAXN], D[MAXN][MAXN], E[MAXN][MAXN], F[MAXN][MAXN];int ans;int main() { scanf(\"%d%d\", &amp;N, &amp;M); mxf::init(N * M); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { Id[i][j] = (i - 1) * M + j; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); ans += A[i][j]; A[i][j] *= 2; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;B[i][j]); ans += B[i][j]; B[i][j] *= 2; } } for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;C[i][j]); ans += C[i][j]; A[i][j] += C[i][j]; A[i + 1][j] += C[i][j]; } } for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;D[i][j]); ans += D[i][j]; B[i][j] += D[i][j]; B[i + 1][j] += D[i][j]; addEdge(Id[i][j], Id[i + 1][j], C[i][j] + D[i][j], 0); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;E[i][j]); ans += E[i][j]; A[i][j] += E[i][j]; A[i][j + 1] += E[i][j]; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;F[i][j]); ans += F[i][j]; B[i][j] += F[i][j]; B[i][j + 1] += F[i][j]; addEdge(Id[i][j], Id[i][j + 1], E[i][j] + F[i][j], 0); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { addEdge(S, Id[i][j], A[i][j]); addEdge(Id[i][j], T, B[i][j]); } } printf(\"%d\\n\", ans - mxf::dinic() / 2); return 0;}","link":"/BZOJ-2127/"},{"title":"【最小斯坦纳树】[WC 2008] BZOJ 2595 游览计划","text":"题目大意在 $n\\times m$ 的网格图上有 $k$ 个景点，图上选择任意一个点有费用 $a_{i,j}$。求选择若干个点使得这 $k​$ 个景点联通，最小化花费并输出方案。 数据范围$n,m,k\\leq 10$ 分析这是一道最小斯坦纳树（minimum Steiner tree）的模板题。 其实看到这么小的数据范围也不难想到状压DP。用 $F[i][j][S]$ 表示当前选择点 $(i,j)$，图的联通状态为 $S$ 的最小花费。 转移方程有两个，一是状态间转移： $F[i][j][S] = \\min\\limits_{T\\in S}{F[i][j][T]+F[i][j][S-T]-A[i][j]}$；二是在同一个状态内松弛： $F[i][j][S] = \\min{F[i’][j’][S]+A[i][j]}$，其中 $(i’,j’)$ 与 $(i,j)$ 联通且属于 $S$。 前者可以通过枚举子集的方法转移，复杂度$O(6^k\\cdot n\\cdot m)$，后者用spfa或其他最短路算法松弛，复杂度 $O(2^k\\cdot f)$，$f$ 为最短路复杂度。总复杂度 $O(6^k\\cdot nm+2^k\\cdot f)$ 。 在转移/松弛时记录前一个点的状态，最后从终点一遍dfs得到所有被选择的点。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 /* * @Author: Skqliao * @Date: 2019-01-27 10:29:05 * @LastEditTime: 2019-01-27 12:39:07 * @Source: WC2008 * @Problem: 2595: [Wc2008]游览计划 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2595 */#include &lt;bits/stdc++.h&gt;const int MAXN = 10 + 2;const int MAXS = 1 &lt;&lt; MAXN;const int INF = 0x3f3f3f3f;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;int A[MAXN][MAXN];int F[MAXN][MAXN][MAXS];struct Node { int x, y, s;} Pre[MAXN][MAXN][MAXS];std::queue&lt;Node&gt; Que;bool Vis[MAXN][MAXN];void spfa(int s) { while (!Que.empty()) { Node a = Que.front(); Vis[a.x][a.y] = 0; Que.pop(); for (int i = 0; i &lt; 4; ++i) { int x = a.x + Dicx[i]; int y = a.y + Dicy[i]; if (x &lt; 1 || y &lt; 1 || x &gt; N || y &gt; M) { continue; } if (F[a.x][a.y][s] + A[x][y] &lt; F[x][y][s]) { F[x][y][s] = F[a.x][a.y][s] + A[x][y]; Pre[x][y][s] = (Node){a.x, a.y, s}; if (!Vis[x][y]) { Que.push((Node) {x, y, 0}); Vis[x][y] = 1; } } } }}void dfs(int x, int y, int s) { Vis[x][y] = 1; Node &amp;a = Pre[x][y][s]; if (a.x == 0 &amp;&amp; a.y == 0) { return ; } dfs(a.x, a.y, a.s); if (x == a.x &amp;&amp; y == a.y) { dfs(a.x, a.y, s - a.s); }}int main() { int cnt = 0; scanf(\"%d%d\", &amp;N, &amp;M); memset(F, 0x3f, sizeof F); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); if (!A[i][j]) { F[i][j][1 &lt;&lt; cnt++] = 0; } } } int S = (1 &lt;&lt; cnt) - 1; for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { for (int x = s; x; x = (x - 1) &amp; s) { if (F[i][j][x] + F[i][j][s - x] - A[i][j] &lt; F[i][j][s]) { F[i][j][s] = F[i][j][x] + F[i][j][s - x] - A[i][j]; Pre[i][j][s] = (Node) {i, j, x}; } } if (F[i][j][s] &lt; INF) { Que.push((Node) {i, j, 0}); Vis[i][j] = 1; } } } spfa(s); } bool flag = 0; for (int i = 1; i &lt;= N &amp;&amp; !flag; ++i) { for (int j = 1; j &lt;= M; ++j) { if (A[i][j] == 0) { printf(\"%d\\n\", F[i][j][S]); dfs(i, j, S); flag = 1; break; } } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { if (!A[i][j]) { putchar('x'); } else if (Vis[i][j]) { putchar('o'); } else { putchar('_'); } } puts(\"\"); } return 0;}","link":"/BZOJ-2595/"},{"title":"【线段树+Kruskal】JZOJ 5060 公路建设","text":"题目大意有 $n$ 个点， $m$ 条边， $q$ 个询问。每次给定一个区间 $[l_i,r_i]$，求这些边构成的图在保证联通块个数最小的情况下所需最小花费。 数据范围$n\\leq 100$$m\\leq 100000$$q\\leq 15000$ 分析将题意翻译一下就是求区间最小生成树的权值。 假设已知 $[l,m]$ 和 $[m+1,r]$ 的最小生成树，那么 $[l,r]$ 的mst显然是由这两棵mst中的边构成的。 具体地说，在线段树中，通过Kruskal保存子区间mst上的所有边，然后用归并排序合并两个子区间的边，并再做kruskal求出父亲节点的mst上的所有边。查询时按照同样方法合并答案。 复杂度 $O(n\\alpha(n)(m\\log{m}+q\\log{m}))$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 16:40:30 * @LastEditTime: 2019-01-26 17:12:13 * @Source: GDOI2017第二轮模拟day1 * @Problem: JZOJ 5060 公路建设 * @Url: https://jzoj.net/senior/#main/show/5060 */#include &lt;bits/stdc++.h&gt;void open() { freopen(\"highway.in\", \"r\", stdin); freopen(\"highway.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int MAXM = 100000 + 5;int N, M, Q;struct Node { int u, v, w; bool operator &lt; (const Node &amp;x) const { return w &lt; x.w; }} A[MAXM], T[MAXM &lt;&lt; 2][MAXN], Tmp[MAXN &lt;&lt; 1];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Len[MAXM &lt;&lt; 2];int Anc[MAXN];int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) { x = findAnc(x), y = findAnc(y); if (x != y) { Anc[y] = x; return true; } return false;}void pushUp(int x, int l, int r) { int len = std::merge(T[l], T[l] + Len[l], T[r], T[r] + Len[r], Tmp) - Tmp; for (int i = 1; i &lt;= N; ++i) { Anc[i] = i; } Len[x] = 0; for (int i = 0; i &lt; len; ++i) { if (merge(Tmp[i].u, Tmp[i].v)) { T[x][Len[x]++] = Tmp[i]; } }}void build(int rt, int l, int r) { if (l == r) { Len[rt] = 1; T[rt][0] = A[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt, rt &lt;&lt; 1, rt &lt;&lt; 1 | 1);}void query(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { pushUp(0, rt, 0); return ; } int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { query(LT, a, b); } if (m &lt; b) { query(RT, a, b); }}int main() { open(); scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;Q); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;A[i].u, &amp;A[i].v, &amp;A[i].w); } build(1, 1, M); int l, r; while (Q--) { long long sum = 0; scanf(\"%d%d\", &amp;l, &amp;r); Len[0] = 0; query(1, 1, M, l, r); for (int i = 0; i &lt; Len[0]; ++i) { sum += T[0][i].w; } printf(\"%lld\\n\", sum); } return 0;}","link":"/JZOJ-5060/"},{"title":"【最小斯坦纳树+状压DP】[JLOI 2015] BZOJ 4006 管道连接","text":"题目大意无向图中有 $n$ 个 $m$ 条边，边有权值 $W_i$，有 $p$ 个点有编号 $A_i$。现要求选择一些边，使得（有编号且）编号相同的点联通，求最小权值和。 数据范围$n\\leq 1000$$m\\leq 3000$$p\\leq 10$ 分析如果要求所有有编号的点联通，那么这就是一个最小斯坦纳树的模板题。 现在只要求编号相同的点联通，我们可以分别考虑每个编号的点联通的费用，然后组合出最终的答案。 因此依然先求这 $p$ 个点的最小斯坦纳树。然后再用状压DP合并费用，注意合并时（$s=a+b$）， $a,b$ 必须分别完整包含若干个编号的节点，否则不合题意。 复杂度 $O(3^p\\cdot n)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* * @Author: Skqliao * @Date: 2019-01-27 13:24:25 * @LastEditTime: 2019-01-27 14:52:32 * @Source: JLOI 2015 * @Problem: 4006: [JLOI2015]管道连接 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4006 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000 + 2;const int MAXM = 30000 + 5;const int MAXS = 1 &lt;&lt; 12;const int INF = 0x3f3f3f3f;struct Edge { int u, v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int N, M, P;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {v, u, w, H[v]}; H[v] = cntE;}int F[MAXN][MAXS];std::queue&lt;int&gt; Que;bool Vis[MAXN];void spfa(int s) { while (!Que.empty()) { int x = Que.front(); Vis[x] = 0; Que.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (F[x][s] + E[i].w &lt; F[v][s]) { F[v][s] = F[x][s] + E[i].w; if (!Vis[v]) { Que.push(v); Vis[v] = 1; } } } }}int Dp[MAXS];int St[MAXN];std::vector&lt;int&gt; V[MAXN];bool check(int s) { for (int i = 1; i &lt;= 10; ++i) { if (!St[i]) { continue; } if ((St[i] &amp; s) != 0 &amp;&amp; (St[i] &amp; s) != St[i]) { return false; } } return true;}int main() { scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;P); int u, v, w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } memset(F, 0x3f, sizeof F); int p = 0; for (int i = 1; i &lt;= P; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); V[u].push_back(p); F[v][1 &lt;&lt; p++] = 0; } for (int i = 1; i &lt;= 10; ++i) { for (size_t j = 0; j &lt; V[i].size(); ++j) { St[i] |= 1 &lt;&lt; V[i][j]; } } int S = (1 &lt;&lt; p) - 1; memset(Dp, 0x3f, sizeof Dp); for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int x = s; x; x = (x - 1) &amp; s) { F[i][s] = std::min(F[i][s], F[i][x] + F[i][s - x]); } if (F[i][s] &lt; INF) { Que.push(i); } } spfa(s); for (int i = 1; i &lt;= N; ++i) { Dp[s] = std::min(Dp[s], F[i][s]); } } for (int s = 0; s &lt;= S; ++s) { if (check(s)) { for (int x = s; x; x = (x - 1) &amp; s) { if (check(x)) { Dp[s] = std::min(Dp[s], Dp[x] + Dp[s - x]); } } } } printf(\"%d\\n\", Dp[S]); return 0;}","link":"/BZOJ-4006/"},{"title":"斯坦纳树学习笔记（Steiner Tree）","text":"总论斯坦纳树可以理解为一棵使得指定点集合联通的树，而最小斯坦纳树在联通的基础上要求边权和最小。（是不是有点类似于最小生成树？） 通常通过状压DP+最短路松弛的方式来解决此类问题。 过程具体过程不妨从一个简单问题出发。 无向图 $G$ 上有 $n$ 个点，选择若干个点使得它们包含点集合 $S={a_1,a_2,\\cdots,a_m}$，且 $S$ 联通。选择点 $i$ 的代价为 $A_i$，求最小代价。 设 $F[i][S]$ 表示集合 $S$ 的点被选择且当前选择节点 $i$ 的最小花费，则 $F[i][S]$ 有两种方式转移，一是枚举子集合并，二是集合内部松弛。 第一种： $F[i][S]=\\min{F[i][T]+F[i][S-T]-A[i]}$，其中 $T$ 是 $S$ 的一个子集。 可以通过 for (int x = S; x; x = (x - 1) &amp; S) 的方式枚举 $S$ 的所有子集 $x$，复杂度 $O(3^m)$。 由于外层还要枚举当前集合状态 $S$ 和当前点 $i$，因此总复杂度为 $n\\cdot 6^m$。 第二种：$F[i][S]=\\min{F[j][S]+A[i]}$，其中点 $i,j$ 联通。 在状压DP后，可以将所有更新过的点push进队列跑SPFA或其他最短路算法完成松弛。 总复杂度 $O(n\\cdot 6^m+2^m\\cdot f)$，$f$ 为最短路复杂度。 用途最小斯坦树可以得到给定点集合所有子集的最小花费，可能会作为预处理使用。 例题 【最小斯坦纳树】[WC 2008] BZOJ 2595 游览计划 【最小斯坦纳树+状压DP】[JLOI 2015] BZOJ 4006 管道连接","link":"/Steiner-Tree/"},{"title":"最小割树学习笔记（Gomory-Hu Tree）","text":"总论在无向图中，最小割树等价于所有点对间的最小割。 对于任意点对 $(s,t)$，它们之间的最小割为最小割树上 $(s,t)$ 路径间的最小边权值。 过程可以通过求 $n-1$ 次最大流构建出具有 $n$ 个点的无向图 $G$ 的最小割树。 具体步骤如下： 任意选择两点 $s,t$ 求两点间最大流 $f$ 得到最小割隔开的两个集合 最小割树上连接 $(s,t)$，边权为 $f$ 将图恢复成最初形态（还原边权） 递归到这两个新集合中，重复操作1，直到集合中只有 $1$ 个点为止 由于每次集合总数增加 $1$，因此一共做 $n-1$ 次以上流程。 Q &amp; AQ1：如何求最小割隔开的两个集合？ A1：由于最小割上的边一定将流量限制流满了，因此从 $s$ 开始，通过未流满流量限制的边遍历到的且在当前集合中的点为与 $s$ 联通的点集合，剩下的点与 $t$ 联通的点集合。 Q2：用什么算法求最大流啊？会被卡吗？ A2：根据相关法律法规，ISAP和Dinic受到保护，应该不会被卡，EK死就死了。当然你愿意写HLPP也不拦着。 用途可以得到任意点对间的最小割，通常用于预处理。 例题 luogu P4897 【模板】最小割树（Gomory-Hu Tree） 【最小割树】[CQOI 2016] BZOJ 4519 不同的最小割 【最小割树】[ZJOI 2011] BZOJ 2229 最小割","link":"/Gomory-Hu-Tree/"}],"tags":[{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"Pruefer","slug":"Pruefer","link":"/tags/Pruefer/"},{"name":"差分约束","slug":"差分约束","link":"/tags/差分约束/"},{"name":"最小割树","slug":"最小割树","link":"/tags/最小割树/"},{"name":"最小割","slug":"最小割","link":"/tags/最小割/"},{"name":"斯坦纳树","slug":"斯坦纳树","link":"/tags/斯坦纳树/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"状压DP","slug":"状压DP","link":"/tags/状压DP/"}],"categories":[{"name":"51nod","slug":"51nod","link":"/categories/51nod/"},{"name":"BZOJ","slug":"BZOJ","link":"/categories/BZOJ/"},{"name":"JZOJ","slug":"JZOJ","link":"/categories/JZOJ/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/学习笔记/"}]}