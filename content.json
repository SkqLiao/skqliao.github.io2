{"pages":[{"title":"关于我","text":"高二Oier，来自北京。 曾获NOIP2016普及组三等奖，NOIP2017/2018提高组一等奖，WC2019铜牌。","link":"/about/index.html"}],"posts":[{"title":"【01Trie+Pruefer】51nod 1601 完全图的最小生成树计数","text":"有 $n$ 个点，每个点有点权 $a_i$，点 $u,v$ 之间的边边权为 $a_u \\oplus a_v$。求该完全图的最小生成树的权值与方案数。 $n\\leq 10^5,0\\leq a_i&lt; 2^{30}$ 分析从边权为点xor得到，想到可以对点权建立Trie树。 每次合并两子树mst的权值，并加入两子树中节点可以xor得到的最小值作为连接这两棵子树的最小边，自下而上得到整棵Trie的mst的值。 根据Cayley公式，如果存在有 $a(a&gt;2)$ 个相同权值的点时，生成树的方案数为 $a^{a-2}$。每次合并两子树时对方案数做乘法原理即可得到最终的方案数。 复杂度 $O(n\\log{a_i})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 22:59:31 * @LastEditTime: 2019-01-26 23:41:49 * @Source: 51nod * @Problem: 1601 完全图的最小生成树计数 * @Url: https://www.51nod.com/Challenge/Problem.html#!#problemId=1601 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1e5 + 5;const int MOD = 1e9 + 7;int N;int Ch[MAXN &lt;&lt; 5][2], Num[MAXN &lt;&lt; 5], cnt = 1;long long sum, num = 1;void insert(int val) { int x = 1; for (int i = 29; i &gt;= 0; --i) { int d = (val &gt;&gt; i) &amp; 1; if (!Ch[x][d]) { Ch[x][d] = ++cnt; } x = Ch[x][d]; } ++Num[x];}long long poww(long long x, long long t) { long long ans = 1; for (; t; t &gt;&gt;= 1) { if (t &amp; 1) { ans = ans * x % MOD; } x = x * x % MOD; } return ans;}long long min, tmp;void getMin(int x, int y, int d, int v = 0) { if (d &lt; 0) { if (v &lt; min) { min = v; tmp = (long long)Num[x] * Num[y] % MOD; } else if (v == min) { tmp = (tmp + (long long)Num[x] * Num[y]) % MOD; } return; } if (Ch[x][0] &amp;&amp; Ch[y][0]) { getMin(Ch[x][0], Ch[y][0], d - 1, v); if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } } else if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } else { if (Ch[x][0]) { getMin(Ch[x][0], Ch[y][1], d - 1, v + (1 &lt;&lt; d)); } if (Ch[x][1]) { getMin(Ch[x][1], Ch[y][0], d - 1, v + (1 &lt;&lt; d)); } }}void cal(int x, int d) { if (d &lt; 0) { if (Num[x] &gt; 1) { num = num * poww(Num[x], Num[x] - 2); } return; } if (!Ch[x][0]) { cal(Ch[x][1], d - 1); } else if (!Ch[x][1]) { cal(Ch[x][0], d - 1); } else { cal(Ch[x][0], d - 1); cal(Ch[x][1], d - 1); min = 1 &lt;&lt; 30; tmp = 0; getMin(Ch[x][0], Ch[x][1], d - 1, 0); sum = sum + (1 &lt;&lt; d) + min; num = (num * tmp) % MOD; }}int main() { scanf(\"%d\", &amp;N); int x; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); insert(x); } cal(1, 29); printf(\"%lld\\n%lld\\n\", sum, num); return 0;}","link":"/51nod-1601/"},{"title":"【ST表+可持久化Trie】[HEOI 2013] BZOJ 3166 Alo","text":"给定长为 $N$ 的序列 $A[1 \\cdots N]$，定义 $F[i,j]$ 为$A[i \\cdots j]$ 的次大值与区间内另一个数异或的最大值。求 $A$ 所有子区间的 $F$ 最大值。 $1\\leq n\\leq 50000, A_i\\leq 10^9$ 题目链接BZOJ 3166: [Heoi2013]Alo 分析将问题反过来看，其实就是找到每一个数对应的区间，使得它在区间中是次大值，且区间长度最大。 记$L[i],R[i]$ 为 $A[i]$ 左右第一个比它大的数， $LL[i],RR[i]$ 为 $A[i]$ 左右第二个大的数，那么区间为 $[LL[i]+1,R[i]-1]$ 和 $[L[i]+1,RR[i]-1]$。 可以通过在ST表上二分的方法求出 $LL[i],RR[i]$，复杂度 $O(N\\log{N})$。 最后用可持久化Trie求每个区间与 $A[i]$ 的最大异或值，答案为这些值取max，这一步操作的复杂度为 $O(N\\log{max(A_i)})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;const int MAXN = 50000 + 5;const int MAXM = 40;struct Trie { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], cntT;int insert(int pre, int x) { int rt = ++cntT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++cntT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int N, A[MAXN];int L[MAXN], R[MAXN];int Stk[MAXN], top;int LL[MAXN], RR[MAXN];int bSearch(int x) { int l = 1, r = top; int ans = 0; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (A[Stk[m]] &gt; A[x]) { ans = Stk[m]; l = m + 1; } else { r = m - 1; } } return ans;}int F[MAXN][MAXM];void buildST(int n) { for (int i = 1; i &lt;= n; ++i) { F[i][0] = A[i]; } int k = log2(n); for (int j = 1; j &lt;= k; ++j) { for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) { if (F[i][j - 1] &gt; F[i + (1 &lt;&lt; (j - 1))][j - 1]) { F[i][j] = F[i][j - 1]; } else { F[i][j] = F[i + (1 &lt;&lt; (j - 1))][j - 1]; } } }}int queryMax(int l, int r) { int k = log2(r - l + 1); return std::max(F[l][k], F[r - (1 &lt;&lt; k) + 1][k]);}int getL(int i) { int p = L[i], x = A[i]; int l = 1, r = p - 1, ans = 1; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (queryMax(m, p - 1) &gt; x) { ans = m; l = m + 1; } else { r = m - 1; } } return ans;}int getR(int i) { int p = R[i], x = A[i]; int l = p + 1, r = N + 1, ans = N + 1; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (queryMax(p + 1, m) &gt; x) { ans = m; r = m - 1; } else { l = m + 1; } } return ans;}int main() { scanf(\"%d\", &amp;N); Rt[1] = insert(Rt[0], 0); ++N; for (int i = 2; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); Rt[i] = insert(Rt[i - 1], A[i]); } A[1] = A[N + 1] = INT_MAX; Stk[top = 1] = 1; for (int i = 2; i &lt;= N; ++i) { while (A[Stk[top]] &lt;= A[i]) { --top; } L[i] = Stk[top]; Stk[++top] = i; } Stk[top = 1] = N + 1; for (int i = N; i &gt;= 2; --i) { while (A[Stk[top]] &lt;= A[i]) { --top; } R[i] = Stk[top]; Stk[++top] = i; } buildST(N + 1); for (int i = 2; i &lt;= N; ++i) { LL[i] = getL(i); RR[i] = getR(i); } int ans = 0; for (int i = 2; i &lt;= N; ++i) { if (L[i] == 1 &amp;&amp; R[i] == N + 1) { continue; } ans = std::max(ans, query(Rt[LL[i]], Rt[R[i] - 1], A[i])); ans = std::max(ans, query(Rt[L[i]], Rt[RR[i] - 1], A[i])); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-3166/"},{"title":"【可持久化Trie+分块】BZOJ 2741【FOTILE模拟赛】L","text":"给定长为 $N$ 的序列 $A[1 \\cdots N]$，$M$ 个询问。查询 $[l,r]$ 的最大异或和子区间，强制在线。 $N\\leq 12000,M\\leq 6000$ 题目链接BZOJ 2741【FOTILE模拟赛】L 分析可持久化Trie+分块。 记 $s[i]$ 为第 $i$ 块的左端点，$f(i,j)$ 表示$[s[i],r-1]$中的某个点为左端点，右端点为 $r$ 的最大异或子区间。 记 $g(i,j)$ 为$[s[i],r]$ 中的最大异或子区间，则 $g(i,j)=max(g(i,j-1),f(i,j))$。 查询时跨越的完整块直接查 $g$ 数组，剩下的部分在可持久化Trie中查询，取最大值。 复杂度 $O(n\\sqrt{n}\\log{max(A_i)})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;const int MAXN = 12000 + 5;const int MAXM = 40;const int MAXK = 130;int N, M, A[MAXN];struct Trie { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], nT = 1;int insert(int pre, int x) { int rt = ++nT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++nT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int len, n, Belong[MAXN], G[MAXK][MAXN];int queryLR(int l, int r) { int ans = 0, t = r; for (int i = 1; i &lt;= n; ++i) { if ((i - 1) * len + 1 &gt;= l &amp;&amp; (i - 1) * len + 1 &lt;= r) { ans = G[i][r]; t = (i - 1) * len + 1; break; } } for (int i = l; i &lt;= t; ++i) { ans = std::max(ans, query(Rt[l - 1], Rt[r], A[i])); } return ans;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); len = sqrt(N), n = N / len + (N % len &gt; 0); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); A[i] ^= A[i - 1]; Rt[i] = insert(Rt[i - 1], A[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = (i - 1) * len + 1; j &lt;= N; ++j) { G[i][j] = std::max(G[i][j - 1], query(Rt[(i - 1) * len], Rt[j - 1], A[j])); if (i == 1) { G[i][j] = std::max(G[i][j], A[j]); } } } int ans = 0, l, r; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d\", &amp;l, &amp;r); ans %= N; l = (l + ans) % N + 1; r = (r + ans) % N + 1; if (l &gt; r) { std::swap(l, r); } printf(\"%d\\n\", ans = queryLR(l - 1, r)); } return 0;}","link":"/BZOJ-2741/"},{"title":"【可持久化Trie】BZOJ 3261 最大异或和","text":"开始给定一个长为 $N$ 的序列 $A[1\\cdots N]$，有 $M$ 个操作。在 $A$ 的末尾插入 $x$；或者给定 $x,l,r$，查询 $max(x\\oplus A[p]\\oplus\\cdots\\oplus A[N])$，其中$p\\in[l,r]$，$N$为当前序列长度。 $N\\leq 300000,A[i]\\leq 10^7$ 题目链接BZOJ 3261 分析维护前缀异或和，令$S[i]=A[1]\\oplus\\dots\\oplus A[i]$，问题转化为查询 $S[N]\\oplus S[p-1]\\oplus x$ 的最大值，其中 $S[N]$ 和 $x$ 都是已知的。 由于是区间问题，可以用可持久化Trie树维护。对于每个新插入的数在01Trie树新建一条链，并将链上所有点的状态+1。通过权值相减来判断区间内是否存在该点，剩下的就是常规01Tire树求异或最大值的操作。 需要注意的一个细节，由于存在插入操作，因此序列中的元素个数最大可能为 $N+M$，需要开两倍空间。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;const int MAXN = 600000 + 5;const int MAXM = 50;struct Node { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], cntT;int N, M;int insert(int pre, int x) { int rt = ++cntT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++cntT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); int cur = 0, x, l, r; char opt[10]; ++N; Rt[1] = insert(Rt[0], 0); for (int i = 2; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); cur ^= x; Rt[i] = insert(Rt[i - 1], cur); } for (int i = 1; i &lt;= M; ++i) { scanf(\"%s\", opt); if (opt[0] == 'A') { scanf(\"%d\", &amp;x); cur ^= x; ++N; Rt[N] = insert(Rt[N - 1], cur); } else { scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); printf(\"%d\\n\", query(Rt[l - 1], Rt[r], x ^ cur)); } } return 0;}","link":"/BZOJ-3261/"},{"title":"【最小斯坦纳树】[WC 2008] BZOJ 2595 游览计划","text":"在 $n\\times m$ 的网格图上有 $k$ 个景点，图上选择任意一个点有费用 $a_{i,j}$。求选择若干个点使得这 $k​$ 个景点联通，最小化花费并输出方案。 $n,m,k\\leq 10$ 分析这是一道最小斯坦纳树（minimum Steiner tree）的模板题。 其实看到这么小的数据范围也不难想到状压DP。用 $F[i][j][S]$ 表示当前选择点 $(i,j)$，图的联通状态为 $S$ 的最小花费。 转移方程有两个，一是状态间转移： $F[i][j][S] = \\min\\limits_{T\\in S}{F[i][j][T]+F[i][j][S-T]-A[i][j]}$；二是在同一个状态内松弛： $F[i][j][S] = \\min{F[i’][j’][S]+A[i][j]}$，其中 $(i’,j’)$ 与 $(i,j)$ 联通且属于 $S$。 前者可以通过枚举子集的方法转移，复杂度$O(6^k\\cdot n\\cdot m)$，后者用spfa或其他最短路算法松弛，复杂度 $O(2^k\\cdot f)$，$f$ 为最短路复杂度。总复杂度 $O(6^k\\cdot nm+2^k\\cdot f)$ 。 在转移/松弛时记录前一个点的状态，最后从终点一遍dfs得到所有被选择的点。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 /* * @Author: Skqliao * @Date: 2019-01-27 10:29:05 * @LastEditTime: 2019-01-27 12:39:07 * @Source: WC2008 * @Problem: 2595: [Wc2008]游览计划 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2595 */#include &lt;bits/stdc++.h&gt;const int MAXN = 10 + 2;const int MAXS = 1 &lt;&lt; MAXN;const int INF = 0x3f3f3f3f;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;int A[MAXN][MAXN];int F[MAXN][MAXN][MAXS];struct Node { int x, y, s;} Pre[MAXN][MAXN][MAXS];std::queue&lt;Node&gt; Que;bool Vis[MAXN][MAXN];void spfa(int s) { while (!Que.empty()) { Node a = Que.front(); Vis[a.x][a.y] = 0; Que.pop(); for (int i = 0; i &lt; 4; ++i) { int x = a.x + Dicx[i]; int y = a.y + Dicy[i]; if (x &lt; 1 || y &lt; 1 || x &gt; N || y &gt; M) { continue; } if (F[a.x][a.y][s] + A[x][y] &lt; F[x][y][s]) { F[x][y][s] = F[a.x][a.y][s] + A[x][y]; Pre[x][y][s] = (Node){a.x, a.y, s}; if (!Vis[x][y]) { Que.push((Node) {x, y, 0}); Vis[x][y] = 1; } } } }}void dfs(int x, int y, int s) { Vis[x][y] = 1; Node &amp;a = Pre[x][y][s]; if (a.x == 0 &amp;&amp; a.y == 0) { return ; } dfs(a.x, a.y, a.s); if (x == a.x &amp;&amp; y == a.y) { dfs(a.x, a.y, s - a.s); }}int main() { int cnt = 0; scanf(\"%d%d\", &amp;N, &amp;M); memset(F, 0x3f, sizeof F); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); if (!A[i][j]) { F[i][j][1 &lt;&lt; cnt++] = 0; } } } int S = (1 &lt;&lt; cnt) - 1; for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { for (int x = s; x; x = (x - 1) &amp; s) { if (F[i][j][x] + F[i][j][s - x] - A[i][j] &lt; F[i][j][s]) { F[i][j][s] = F[i][j][x] + F[i][j][s - x] - A[i][j]; Pre[i][j][s] = (Node) {i, j, x}; } } if (F[i][j][s] &lt; INF) { Que.push((Node) {i, j, 0}); Vis[i][j] = 1; } } } spfa(s); } bool flag = 0; for (int i = 1; i &lt;= N &amp;&amp; !flag; ++i) { for (int j = 1; j &lt;= M; ++j) { if (A[i][j] == 0) { printf(\"%d\\n\", F[i][j][S]); dfs(i, j, S); flag = 1; break; } } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { if (!A[i][j]) { putchar('x'); } else if (Vis[i][j]) { putchar('o'); } else { putchar('_'); } } puts(\"\"); } return 0;}","link":"/BZOJ-2595/"},{"title":"【分数规划+SPFA】[SCOI 2014] BZOJ 3597 方伯伯运椰子","text":"在有向无环图 $G$ 中，每条边的流量与容量相等。现可以修改每条边的容量，使得新的边依然满足流量与容量相等，且总流量不变。已知扩展/缩小每条边容量的单位花费，以及流量通过该边的单位花费。记原总花费 $X$，现在总花费 $Y$（包括修改容量和流量的花费），修改了 $K$ 条边的容量，则收益为 $w=(X-Y)/K$，求$w$的最大值。 $N\\leq 5000$ 题目链接BZOJ 3597 分析这道题的核心在于理解“总流量不变且每条边跑满”，可以用网络流的模型理解。 所谓扩容即增广，花费为扩容费用+流量费用；压缩即退流，花费为压缩费用-流量费用。 假设 $a\\geq(X-Y)/K$，则 $Y-X+a\\cdot K\\geq 0$。 而 $Y-X$ 就是增广和退流的费用之和，$K$ 可以分摊到每条边上，即让每条边的权值增加 $K$。 $a$ 显然是可以二分的，那么若新图出现负环，则说明 $a$ 的值不够大，直到得到解为止。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;const int MAXN = 5000 + 5;const double INF = 1e9;const double eps = 1e-4;int N, M;struct Edge { int v; double w; int nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}double Dis[MAXN];bool Vis[MAXN];bool dfs_spfa(int x, double xx) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; double dis = Dis[x] + E[i].w + xx; if (Dis[v] &gt; dis) { Dis[v] = dis; if (Vis[v] || dfs_spfa(v, xx)) { return true; } } } return Vis[x] = 0;}bool check(double a) { for (int i = 1; i &lt;= N; ++i) { Dis[i] = INF; } Dis[N - 1] = 0; memset(Vis, 0, sizeof Vis); for (int i = 1; i &lt;= N; ++i) { if (dfs_spfa(i, a)) { return true; } } return false;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); N += 2; int a, b, c, d, u, v; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d%d%d%d\", &amp;u, &amp;v, &amp;a, &amp;b, &amp;c, &amp;d); if (u == N - 1) { continue; } if (c) { addEdge(v, u, a - d); } addEdge(u, v, b + d); } double l = 0, r = INF, ans; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { ans = l = m; } else { r = m; } } printf(\"%.2lf\\n\", ans); return 0;}","link":"/BZOJ-3597/"},{"title":"【01字典树+前后缀】BZOJ 4260 Codechef REBXOR","text":"对于长为 $N$ 的序列 $A[1\\cdots N]$，求两个不相交区间的异或和之和的最大值。 $2\\leq N\\leq 4\\times 10^5,A[i]\\leq 10^9$ 题目链接BZOJ 4260 分析根据异或的性质， 令 $S[i]=A[1]\\oplus A[2]\\cdots \\oplus A[i]$，则$A[l]\\oplus\\cdots \\oplus A[r]=S[r]\\oplus S[l-1]$。 令 $L[i]$ 为 $A[1\\cdots i]$ 中的最大区间异或和， $R[i]$ 为 $A[i\\cdots N]$ 中的最大区间异或和，如此 $L[i],R[i+1]$ 一定不相交，答案为 $max(L[i]+R[i+1])$。 从前往后在01字典树中查询当前前缀异或和 $cur$ 能异或得到的最大值，并将 $cur$插入，则$L[i]=\\max(L[i-1],query(cur))$。 再从后往前插入后缀异或和，则 $R[i]=\\max(R[i+1],query(cur))$。 复杂度 $O(n\\log{n})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;const int MAXN = 4e5 + 5;const int MAXM = 40;struct Node { int sz, num; int ch[2];} T[MAXN * MAXM];int cntT;int N, A[MAXN];int L[MAXN], R[MAXN];void insert(int rt, int x) { for (int i = 32; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (!T[rt].ch[c]) { T[rt].ch[c] = ++cntT; T[cntT].ch[0] = T[cntT].ch[1] = 0; T[cntT].sz = 0; } ++T[rt].sz; rt = T[rt].ch[c]; } T[rt].num = x;}int query(int rt, int x) { for (int i = 32; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (!T[rt].ch[c ^ 1]) { rt = T[rt].ch[c]; } else { rt = T[rt].ch[c ^ 1]; } } return x ^ T[rt].num;}void init() { cntT = 1; T[1].ch[0] = T[1].ch[1] = 0; T[1].sz = T[1].num = 0;}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); } int lst = 0; insert(1, 0); for (int i = 1; i &lt;= N; ++i) { lst ^= A[i]; L[i] = std::max(L[i - 1], query(1, lst)); insert(1, lst); } init(); lst = 0; insert(1, 0); for (int i = N; i &gt;= 1; --i) { lst ^= A[i]; R[i] = std::max(R[i + 1], query(1, lst)); insert(1, lst); } int ans = 0; for (int i = 1; i &lt; N; ++i) { ans = std::max(ans, L[i] + R[i + 1]); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-4260/"},{"title":"【分数规划+费用流】[SDOI 2017] BZOJ 4819 新生舞会","text":"双方各有 $N$ 个人进行两两配对，$i$ 和 $j$ 配对会获得 $x=A[i][j]$ 的收益和 $y=B[i][j]$ 的代价。最小化 $\\sum{x}/\\sum{y}$。 $N\\leq 100,x,y\\leq 10^4$ 题目链接BZOJ 4819 分析若 $\\sum{x}/\\sum{y}\\geq a$，则 $\\sum{x}-a\\cdot\\sum{y} \\geq 0$，再转化变成 $\\sum{x-a\\cdot y}\\geq 0$。 $a$ 显然是可以二分的，然后建图跑最小费用最大流，边权为 $a\\cdot B[i][j]-A[i][j]$，判定合法即总费用是否小于0。 有更快的Dinkelbach算法，考虑用迭代的方式求 $a$。初始化 $a=0$，得到一组合法解后，更新 $a$ 为当前情况下的 $\\sum{x}/\\sum{y}$，直到求得答案。此方法实测比二分快了10倍。 费用流的过程本质就是一个二分图最大权匹配，因此跑KM也是可行的，复杂度上界 $O(\\log{(10^6\\cdot x)}\\cdot n^3)$，实则远远跑不满。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;const int MAXN = 200 + 5;const int MAXM = MAXN * MAXN;const double eps = 1e-7;const double INF = 1e7;int N, A[MAXN][MAXN], B[MAXN][MAXN];struct Edge { int v; double w; int f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w, int f) { E[++cntE] = (Edge) {v, w, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -w, 0, H[v]}; H[v] = cntE;}int S, T;void buildGraph(double x) { memset(H, 0, sizeof H); cntE = 1; S = 0; T = N * 2 + 1; for (int i = 1; i &lt;= N; ++i) { addEdge(S, i, 0, 1); addEdge(i + N, T, 0, 1); for (int j = 1; j &lt;= N; ++j) { addEdge(i, j + N, x * B[i][j] - A[i][j], 1); } }}int Pe[MAXN], Pv[MAXN];double Dis[MAXN];bool Vis[MAXN];struct cmp { inline bool operator () (const int &amp;x, const int &amp;y) const { return Dis[x] &gt; Dis[y]; }};std::priority_queue&lt;int, std::vector&lt;int&gt;, cmp&gt; pq;int spfa(int s, int t) { for (int i = s; i &lt;= t; ++i) { Dis[i] = INF; } memset(Vis, 0, sizeof Vis); Dis[s] = 0, pq.push(s); while (!pq.empty()) { int x = pq.top(); Vis[x] = 0, pq.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &gt; 0 &amp;&amp; Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Pe[v] = i, Pv[v] = x; if (!Vis[v]) { Vis[v] = 1; pq.push(v); } } } } return Dis[t] &lt; INF;}double cost;int flow;double ai, bi;void mcmf(int s, int t) { cost = flow = 0; while (spfa(s, t)) { int f = INF; for (int i = t; i != s; i = Pv[i]) { f = std::min(f, E[Pe[i]].f); } cost += f * Dis[t]; flow += f; for (int i = t; i != s; i = Pv[i]) { E[Pe[i]].f -= f, E[Pe[i] ^ 1].f += f; } } ai = bi = 0; for (int x = 1; x &lt;= N; ++x) { for (int i = H[x]; i; i = E[i].nxt) { if (E[i].f == 0 &amp;&amp; E[i].v &gt; N) { ai += A[x][E[i].v - N]; bi += B[x][E[i].v - N]; break; } } }}bool check(double lim) { buildGraph(lim); mcmf(S, T); return flow == N &amp;&amp; cost &lt; -eps;}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { scanf(\"%d\", &amp;A[i][j]); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { scanf(\"%d\", &amp;B[i][j]); } } double ans = 0; while (check(ans)) { ans = ai / bi; } printf(\"%.6lf\\n\", ans); return 0;}","link":"/BZOJ-4819/"},{"title":"【分数规划+树形DP】[JSOI 2016] BZOJ 4753 最佳团体","text":"每个点有一个父亲，它能被选择当且仅当它父亲被选择，0号节点默认被选择。每个点有收益 $X[i]$，代价 $Y[i]$。选择恰好 $K$ 个点（不算0号），使得其对应的 $\\sum{X[i]}/\\sum{Y[i]}$ 最大。 $N\\leq 2500$ 题目链接BZOJ 4753 分析通过分数规划，二分答案来避免除法。 选择关系是一棵树，被选择的点处于一个联通分量。树形背包，转移时父亲被强制选择。 复杂度 $O(NK\\log{X[i]})$ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;const int MAXN = 2500 + 5;const double eps = 1e-4;int N, K;int A[MAXN], B[MAXN], P[MAXN];std::vector&lt;int&gt; G[MAXN];double F[MAXN][MAXN], Tmp[MAXN];int Sz[MAXN];void dfs(int x, double m) { F[x][0] = 0; F[x][1] = B[x] - A[x] * m; Sz[x] = 1; for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; dfs(v, m); memset(Tmp, 0xc2, sizeof Tmp); Tmp[0] = 0; for (int j = 1; j &lt;= Sz[x]; ++j) { for (int k = 0; k &lt;= Sz[v] &amp;&amp; j + k &lt;= K; ++k) { Tmp[j + k] = std::max(Tmp[j + k], F[x][j] + F[v][k]); } } Sz[x] += Sz[v]; memcpy(F[x], Tmp, sizeof Tmp); }}bool check(double m) { memset(F, 0xc2, sizeof F); dfs(0, m); return F[0][K] &gt;= 0;}int main() { scanf(\"%d%d\", &amp;K, &amp;N); ++K; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d%d\", &amp;A[i], &amp;B[i], &amp;P[i]); G[P[i]].push_back(i); } double l = 0, r = 1e4, ans; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { l = ans = m; } else { r = m; } } printf(\"%.3lf\\n\", ans); return 0;}","link":"/BZOJ-4753/"},{"title":"【最小割树】[ZJOI 2011] BZOJ 2229 最小割","text":"$T$ 组数据，$Q$ 个询问。在无向图 $G$ 中，求有多少个点对 $(s,t)$ 使得它们之间的最小割不超过 $x$。 $T\\leq 10,n\\leq 150,m\\leq 3000,q\\leq 30$ 分析建完最小割树后，问题转化为求树上有多少个点对路径上的边权最小值不超过 $x$。 枚举点对再用倍增判断，复杂度 $O(n^2\\log{n})$。 也存在线性做法，对于边权不超过 $x$ 的边，统计路径通过该边新增的点对数量，复杂度 $O(n)$。 然而由于复杂度瓶颈在建立最小割树上，因此两种方法实际效率相仿。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* * @Author: Skqliao * @Date: 2019-02-02 22:57:06 * @LastEditTime: 2019-02-03 11:53:06 * @Source: ZJOI 2011 * @Problem: 2229: [Zjoi2011]最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2229 */#include &lt;bits/stdc++.h&gt;const int MAXN = 150 + 5;const int MAXM = 3000 + 5;namespace GH_Tree {struct Edge { int v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge){v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, w, H[v]}; H[v] = cntE;}int Fa[MAXN], Sz[MAXN];int dfs(int x) { Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; Sz[x] += dfs(v); } } return Sz[x];}int ans;int dfs(int x, int sz, int mx) { int tot = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { if (E[i].w &lt;= mx) { tot += Sz[v]; ans += Sz[v] * (sz - Sz[v]); sz -= Sz[v]; dfs(v, Sz[v], mx); } else { int tmp = dfs(v, sz, mx); sz -= tmp; tot += tmp; } } } return tot;}void init() { cntE = 0; memset(H, 0, sizeof H);}int query(int x) { ans = 0; dfs(1, Sz[1], x); return ans;}namespace Init { struct Edge { int v, f, cap, nxt; } E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; int Idx[MAXN], Tmp[MAXN]; int S, T; int Dis[MAXN], Cur[MAXN]; int Col[MAXN]; void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; } } void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE; } bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false; } int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left; } int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow; } void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); } } void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); GH_Tree::addEdge(S, T, f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r); } void solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); }} // namespace Init} // namespace GH_Treeint T, N, M, Q;int main() { int x; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); GH_Tree::init(); GH_Tree::Init::solve(N, M); GH_Tree::dfs(1); scanf(\"%d\", &amp;Q); while (Q--) { scanf(\"%d\", &amp;x); printf(\"%d\\n\", GH_Tree::query(x)); } puts(\"\"); } return 0;}","link":"/BZOJ-2229/"},{"title":"【分数规划+背包】[USACO2018 OPEN] BZOJ 5281 Talent Show","text":"$N$ 个点各有权值 $W_i$ 和 $T_i$，在其中选择任意多个点，在满足 $\\sum{W_i} \\geq A$ 的条件下求 $\\sum{T_i}/\\sum{W_i}$ 的最大值。 $1\\leq N\\leq 250,1\\leq W\\leq 1000,1\\leq W_i\\leq 10^6,1\\leq T_i\\leq 10^3$ 题库链接BZOJ 5281 分析套路二分答案 $x$，然后背包求在 $\\sum{W_i}\\geq A$ 的情况下判定 $\\sum{T_i-W_i\\times x}\\geq 0$ 是否成立。 由于答案是 $\\times 1000$ 取整，为了避免浮点数运算，可以直接将 $T_i$ 放大 $1000$ 倍。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;const int MAXN = 250 + 5;const int MAXM = 1000 + 5;int N, M;int A[MAXN], B[MAXN];long long F[MAXM];bool check(int a) { memset(F, 0xc2, sizeof F); long long tmp = F[0]; F[0] = 0; for (int i = 1; i &lt;= N; ++i) { for (int j = M; j &gt;= 0; --j) { if (F[j] != tmp) { int v = std::min(M, j + A[i]); F[v] = std::max(F[v], F[j] - (long long)A[i] * a + B[i]); } } } return F[M] &gt;= 0;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;A[i], &amp;B[i]); B[i] *= 1000; } int l = 0, r = 2e8, ans = 0; while (l &lt;= r) { int m = (l + r) / 2; if (check(m)) { ans = m; l = m + 1; } else { r = m - 1; } } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-5281/"},{"title":"【最小斯坦纳树+状压DP】[JLOI 2015] BZOJ 4006 管道连接","text":"无向图中有 $n$ 个 $m$ 条边，边有权值 $W_i$，有 $p$ 个点有编号 $A_i$。现要求选择一些边，使得（有编号且）编号相同的点联通，求最小权值和。 $n\\leq 1000,m\\leq 3000,p\\leq 10$ 分析如果要求所有有编号的点联通，那么这就是一个最小斯坦纳树的模板题。 现在只要求编号相同的点联通，我们可以分别考虑每个编号的点联通的费用，然后组合出最终的答案。 因此依然先求这 $p$ 个点的最小斯坦纳树。然后再用状压DP合并费用，注意合并时（$s=a+b$）， $a,b$ 必须分别完整包含若干个编号的节点，否则不合题意。 复杂度 $O(3^p\\cdot n)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* * @Author: Skqliao * @Date: 2019-01-27 13:24:25 * @LastEditTime: 2019-01-27 14:52:32 * @Source: JLOI 2015 * @Problem: 4006: [JLOI2015]管道连接 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4006 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000 + 2;const int MAXM = 30000 + 5;const int MAXS = 1 &lt;&lt; 12;const int INF = 0x3f3f3f3f;struct Edge { int u, v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int N, M, P;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {v, u, w, H[v]}; H[v] = cntE;}int F[MAXN][MAXS];std::queue&lt;int&gt; Que;bool Vis[MAXN];void spfa(int s) { while (!Que.empty()) { int x = Que.front(); Vis[x] = 0; Que.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (F[x][s] + E[i].w &lt; F[v][s]) { F[v][s] = F[x][s] + E[i].w; if (!Vis[v]) { Que.push(v); Vis[v] = 1; } } } }}int Dp[MAXS];int St[MAXN];std::vector&lt;int&gt; V[MAXN];bool check(int s) { for (int i = 1; i &lt;= 10; ++i) { if (!St[i]) { continue; } if ((St[i] &amp; s) != 0 &amp;&amp; (St[i] &amp; s) != St[i]) { return false; } } return true;}int main() { scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;P); int u, v, w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } memset(F, 0x3f, sizeof F); int p = 0; for (int i = 1; i &lt;= P; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); V[u].push_back(p); F[v][1 &lt;&lt; p++] = 0; } for (int i = 1; i &lt;= 10; ++i) { for (size_t j = 0; j &lt; V[i].size(); ++j) { St[i] |= 1 &lt;&lt; V[i][j]; } } int S = (1 &lt;&lt; p) - 1; memset(Dp, 0x3f, sizeof Dp); for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int x = s; x; x = (x - 1) &amp; s) { F[i][s] = std::min(F[i][s], F[i][x] + F[i][s - x]); } if (F[i][s] &lt; INF) { Que.push(i); } } spfa(s); for (int i = 1; i &lt;= N; ++i) { Dp[s] = std::min(Dp[s], F[i][s]); } } for (int s = 0; s &lt;= S; ++s) { if (check(s)) { for (int x = s; x; x = (x - 1) &amp; s) { if (check(x)) { Dp[s] = std::min(Dp[s], Dp[x] + Dp[s - x]); } } } } printf(\"%d\\n\", Dp[S]); return 0;}","link":"/BZOJ-4006/"},{"title":"【最小割树】[CQOI 2016] BZOJ 4519 不同的最小割","text":"题目大意在无向图 $G$ 中，对于任意点对 $(i,j)$ 有最小割 $cut(i,j)$，求有多少个数值不同的最小割。 $N\\leq 850,M\\leq 8500$ 分析最小割树模板题，求出最小割树后将所有边unique得到答案。 复杂度 $O(n\\times f)$，$f$ 为最大流复杂度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* * @Author: Skqliao * @Date: 2019-02-02 22:26:52 * @LastEditTime: 2019-02-02 22:54:36 * @Source: CQOI 2016 * @Problem: 4519: [Cqoi2016]不同的最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4519 */#include &lt;bits/stdc++.h&gt;const int MAXN = 850 + 5;const int MAXM = 8500 + 5;namespace GH_Tree {struct Edge { int v, f, cap, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Idx[MAXN], Tmp[MAXN];int S, T;int Dis[MAXN], Cur[MAXN];int Col[MAXN];void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; }}void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow;}void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); }}std::vector&lt;int&gt; V;void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); V.push_back(f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r);}int solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); std::sort(V.begin(), V.end()); V.erase(std::unique(V.begin(), V.end()), V.end()); return V.size();}} // namespace GH_Treeint N, M;int main() { scanf(\"%d%d\", &amp;N, &amp;M); printf(\"%d\\n\", GH_Tree::solve(N, M)); return 0;}","link":"/BZOJ-4519/"},{"title":"【线段树+Kruskal】JZOJ 5060 公路建设","text":"有 $n$ 个点， $m$ 条边， $q$ 个询问。每次给定一个区间 $[l_i,r_i]$，求这些边构成的图在保证联通块个数最小的情况下所需最小花费。 $n\\leq 100,m\\leq 100000,q\\leq 15000$ 分析将题意翻译一下就是求区间最小生成树的权值。 假设已知 $[l,m]$ 和 $[m+1,r]$ 的最小生成树，那么 $[l,r]$ 的mst显然是由这两棵mst中的边构成的。 具体地说，在线段树中，通过Kruskal保存子区间mst上的所有边，然后用归并排序合并两个子区间的边，并再做kruskal求出父亲节点的mst上的所有边。查询时按照同样方法合并答案。 复杂度 $O(n\\alpha(n)(m\\log{m}+q\\log{m}))$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 16:40:30 * @LastEditTime: 2019-01-26 17:12:13 * @Source: GDOI2017第二轮模拟day1 * @Problem: JZOJ 5060 公路建设 * @Url: https://jzoj.net/senior/#main/show/5060 */#include &lt;bits/stdc++.h&gt;void open() { freopen(\"highway.in\", \"r\", stdin); freopen(\"highway.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int MAXM = 100000 + 5;int N, M, Q;struct Node { int u, v, w; bool operator &lt; (const Node &amp;x) const { return w &lt; x.w; }} A[MAXM], T[MAXM &lt;&lt; 2][MAXN], Tmp[MAXN &lt;&lt; 1];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Len[MAXM &lt;&lt; 2];int Anc[MAXN];int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) { x = findAnc(x), y = findAnc(y); if (x != y) { Anc[y] = x; return true; } return false;}void pushUp(int x, int l, int r) { int len = std::merge(T[l], T[l] + Len[l], T[r], T[r] + Len[r], Tmp) - Tmp; for (int i = 1; i &lt;= N; ++i) { Anc[i] = i; } Len[x] = 0; for (int i = 0; i &lt; len; ++i) { if (merge(Tmp[i].u, Tmp[i].v)) { T[x][Len[x]++] = Tmp[i]; } }}void build(int rt, int l, int r) { if (l == r) { Len[rt] = 1; T[rt][0] = A[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt, rt &lt;&lt; 1, rt &lt;&lt; 1 | 1);}void query(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { pushUp(0, rt, 0); return ; } int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { query(LT, a, b); } if (m &lt; b) { query(RT, a, b); }}int main() { open(); scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;Q); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;A[i].u, &amp;A[i].v, &amp;A[i].w); } build(1, 1, M); int l, r; while (Q--) { long long sum = 0; scanf(\"%d%d\", &amp;l, &amp;r); Len[0] = 0; query(1, 1, M, l, r); for (int i = 0; i &lt; Len[0]; ++i) { sum += T[0][i].w; } printf(\"%lld\\n\", sum); } return 0;}","link":"/JZOJ-5060/"},{"title":"斯坦纳树学习笔记（Steiner Tree）","text":"总论斯坦纳树可以理解为一棵使得指定点集合联通的树，而最小斯坦纳树在联通的基础上要求边权和最小。（是不是有点类似于最小生成树？） 通常通过状压DP+最短路松弛的方式来解决此类问题。 过程具体过程不妨从一个简单问题出发。 无向图 $G$ 上有 $n$ 个点，选择若干个点使得它们包含点集合 $S={a_1,a_2,\\cdots,a_m}$，且 $S$ 联通。选择点 $i$ 的代价为 $A_i$，求最小代价。 设 $F[i][S]$ 表示集合 $S$ 的点被选择且当前选择节点 $i$ 的最小花费，则 $F[i][S]$ 有两种方式转移，一是枚举子集合并，二是集合内部松弛。 第一种： $F[i][S]=\\min{F[i][T]+F[i][S-T]-A[i]}$，其中 $T$ 是 $S$ 的一个子集。 可以通过 for (int x = S; x; x = (x - 1) &amp; S) 的方式枚举 $S$ 的所有子集 $x$，复杂度 $O(3^m)$。 由于外层还要枚举当前集合状态 $S$ 和当前点 $i$，因此总复杂度为 $n\\cdot 6^m$。 第二种：$F[i][S]=\\min{F[j][S]+A[i]}$，其中点 $i,j$ 联通。 在状压DP后，可以将所有更新过的点push进队列跑SPFA或其他最短路算法完成松弛。 总复杂度 $O(n\\cdot 6^m+2^m\\cdot f)$，$f$ 为最短路复杂度。 用途最小斯坦树可以得到给定点集合所有子集的最小花费，可能会作为预处理使用。 例题 【最小斯坦纳树】[WC 2008] BZOJ 2595 游览计划 【最小斯坦纳树+状压DP】[JLOI 2015] BZOJ 4006 管道连接","link":"/Steiner-Tree/"},{"title":"【二分+SPFA】[HNOI 2009] BZOJ 1486 最小圈","text":"在有向图 $G$ 中，定义环 $a$ 的权值 $w_a=\\sum{W[i]}/num$，其中 $W[i]$ 为 $a$ 上边的权值， $num$ 为 $a$ 上的节点数。求图中 $w$ 的最小值。 $n\\leq 1000,m\\leq 5000,|W[i]|\\leq 5000$ 题目链接BZOJ 1486 分析设 $w_a=x$，则 $\\sum{W[i]}/num \\geq x$，即 $\\sum{W[i]}\\geq num\\cdot x$。 由于环上点数和边数相同，因此可以改写为 $\\sum(W[i]-x)\\geq 0$。 $x$ 显然可以二分，于是就变成了判断图中是否存在负环的问题，用SPFA可解。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;const int MAXN = 3000 + 5;const int MAXM = 10000 + 5;const double INF = 1e7;const double eps = 1e-9;int N, M;struct Edge { int v; double w; int nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}double Dis[MAXN];bool Vis[MAXN], flag;bool dfs_spfa(int x, double xx) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; double dis = Dis[x] + E[i].w - xx; if (Dis[v] &gt; dis) { Dis[v] = dis; if (Vis[v] || dfs_spfa(v, xx)) { return true; } } } return Vis[x] = 0;}bool check(double a) { flag = 0; for (int i = 1; i &lt;= N; ++i) { Dis[i] = INF; } memset(Vis, 0, sizeof Vis); for (int i = 1; i &lt;= N; ++i) { if (dfs_spfa(i, a)) { return true; } } return false;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); int u, v; double w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%lf\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } double l = -INF, r = INF, ans = 0; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { r = m; ans = m; } else { l = m; } } printf(\"%.8lf\\n\", ans); return 0;}","link":"/BZOJ-1486/"},{"title":"【差分约束】[HNOI 2005] BZOJ 1202 狡猾的商人","text":"给定 $M$ 组关于 $l, r, x$ 的等式，意为 $\\sum\\limits_{i=l}^{r}{A_i}=x$，判断是否可以构造出 $A[1\\cdots N]$ 满足这些等式。 $N\\leq 100,M\\leq 1000$ 题目链接BZOJ 1202 分析将等式写成前缀和的形式，用 $Sum[i]$ 表示 $\\sum\\limits_{j=1}^{i}{A_j}$ ，等式化为 $Sum[r] - Sum[l-1] = x$。 可以将等式变形成两个不等式， $Sum[r] - Sum[l-1] \\geq x$ 和 $Sum[l - 1] - Sum[r] \\geq -x$ 。 那么原问题就转化为差分约束系统求解模型。连接边 $(l - 1, r, x)$ 和 $(r, l - 1, -x)$ ，SPFA判断是否存在负环，复杂度 $O(NM)$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;const int MAXM = 1000 + 5;int N, M;struct Edge { int v, w, nxt;} E[MAXM * 3];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;int Dis[MAXN], Cnt[MAXN], Inq[MAXN];bool Vis[MAXN];int n;bool spfa() { while (!Que.empty()) { Que.pop(); } memset(Dis, 0x3f, sizeof Dis); memset(Inq, 0, sizeof Inq); memset(Cnt, 0, sizeof Cnt); Que.push(N + 1); Dis[N + 1] = 0; while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Cnt[v] = Cnt[x] + 1; if (Cnt[v] &gt; n) { return false; } if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } return true;}void init() { cntE = 0; memset(H, 0, sizeof H); n = 0; memset(Vis, 0, sizeof Vis);}int main() { int T, u, v, w; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); init(); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); if (!Vis[u - 1]) { Vis[u - 1] = 1; ++n; } if (!Vis[v]) { Vis[v] = 1; ++n; } addEdge(u - 1, v, -w); addEdge(v, u - 1, w); } for (int i = 1; i &lt;= N; ++i) { addEdge(N + 1, i, 0); } if (spfa()) { puts(\"true\"); } else { puts(\"false\"); } } return 0;}","link":"/BZOJ-1202/"},{"title":"【最小割】[2010 集训队测验] BZOJ 2127 文理分科","text":"在 $n\\times m$ 的矩阵中，每个格子可以选择 $0/1$，分别获得收益 $A_{i,j},B_{i,j}$。如果上下两个格子选择相同，则额外获得收益 $C_{i,j},D_{i,j}$（都选$0/1$），如果左右两个格子选择相同，则额外获得收益 $E_{i,j},F_{i,j}$。求总收益的最大值。 $n,m\\leq 100,A,B,C,D,E,F_{i,j}\\leq 5000$ 分析这是集训队论文《浅谈一类最小割问题》中的例题，也是网络流建模之二元关系的一道典型题目。 根据相关建图模型，对于每个点 $x$，分别与 $S,T$ 连边，割去 $(S,x)$表示选择文科，割去 $(x,T)$ 表示选择理科。 由于只能求最小割，因此可以先累计所有收益再减去最小割得到最大值。 由于每个点与相邻的点之间的选择会影响结果，因此 $x$ 与相邻的点连边。 对于任意两个相邻点 $x,y$，子图有边 $(S,x),(S,y),(x,y),(y,x),(x,T),(y,T)$。 割去 $(S,x),(S,y)$ 表示都选文，割去 $(x,T),(y,T)$ 表示都选理，割去 $(S,x),(x,y),(y,T)$ 表示 $x$ 选文，$y$选理，剩下一种情况同理第三种。 假设 $x,y$ 选文的收益分别为 $a_x,a_y$，选理的收益为 $b_x,b_y$，都选文/理的收益为 $c,d$，则边权应满足： $$(S,x)+(S,y)=b_x+b_y+d\\(x,T)+(y,T)=a_x+a_y+c\\(S,x)+(x,y)+(y,T)=a_y+b_x+c+d\\(S,y)+(y,x)+(x,T)=a_x+b_y+c+d\\$$得到一组解： $$(x,y)=(y,x)=\\frac{c+d}{2}\\(S,x)=a_x+\\frac{c}{2}\\(S,y)=a_y+\\frac{c}{2}\\(x,T)=b_x+\\frac{d}{2}\\(y,T)=b_y+\\frac{d}{2}\\$$ 由此建图求最大流即可。 Tips：将两点间所有边的边权整合成一条边会大大提高运行速度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* * @Author: Skqliao * @Date: 2019-02-10 20:45:11 * @LastEditTime: 2019-02-10 21:37:48 * @Source: 2010 集训队测试题 * @Problem: 2127: happiness * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2127 */#include &lt;bits/stdc++.h&gt;namespace mxf {const int MAXN = 100 * 100 + 5;const int MAXM = MAXN * 4;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int S, T;int H[MAXN], cntE;void addEdge(int u, int v, int f, bool directed = 1) { E[++cntE] = (Edge){v, f, H[u]}; H[u] = cntE; if (directed) f = 0; E[++cntE] = (Edge){u, f, H[v]}; H[v] = cntE;}int Dis[MAXN], Cur[MAXN];bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memset(Dis, -1, sizeof Dis); memcpy(Cur, H, sizeof H); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) { flow += dfs(S, INT_MAX); } return flow;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}} // namespace mxfusing mxf::addEdge;using mxf::S;using mxf::T;const int MAXN = 100 + 5;int N, M;int Id[MAXN][MAXN];int A[MAXN][MAXN], B[MAXN][MAXN], C[MAXN][MAXN], D[MAXN][MAXN], E[MAXN][MAXN], F[MAXN][MAXN];int ans;int main() { scanf(\"%d%d\", &amp;N, &amp;M); mxf::init(N * M); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { Id[i][j] = (i - 1) * M + j; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); ans += A[i][j]; A[i][j] *= 2; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;B[i][j]); ans += B[i][j]; B[i][j] *= 2; } } for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;C[i][j]); ans += C[i][j]; A[i][j] += C[i][j]; A[i + 1][j] += C[i][j]; } } for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;D[i][j]); ans += D[i][j]; B[i][j] += D[i][j]; B[i + 1][j] += D[i][j]; addEdge(Id[i][j], Id[i + 1][j], C[i][j] + D[i][j], 0); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;E[i][j]); ans += E[i][j]; A[i][j] += E[i][j]; A[i][j + 1] += E[i][j]; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;F[i][j]); ans += F[i][j]; B[i][j] += F[i][j]; B[i][j + 1] += F[i][j]; addEdge(Id[i][j], Id[i][j + 1], E[i][j] + F[i][j], 0); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { addEdge(S, Id[i][j], A[i][j]); addEdge(Id[i][j], T, B[i][j]); } } printf(\"%d\\n\", ans - mxf::dinic() / 2); return 0;}","link":"/BZOJ-2127/"},{"title":"【差分约束】[SCOI 2011] BZOJ 2330 糖果","text":"有 $N$ 个数 $A[1 \\cdots N](A[i] &gt; 0)$，要求满足 $M$ 个条件。条件形如： $A[i] \\leq A[j]$，$A[i] &lt; A[j]$， $A[i] = A[j]$ 。如果可以满足所有条件，求 $\\sum{A_i}$ 的最小值，否则输出 -1。 $N,M\\leq 100000$ 题目链接BZOJ 2330 分析将条件依次转化为 $A[j] - A[i] \\geq 0$，$A[j] - A[i]\\geq 1$，$A[j]-A[i]\\geq 0 \\&amp; A[i]-A[j]\\geq 0$。 根据 $u - v\\geq w$ 建有向边 $(v, u, w)$ 的方式建图，求最长路。 如果单纯通过spfa进队 $N$ 次来判断无解可能会导致超时，发现无解本质为出现正环。因此可以采用Tarjan求联通分量，判断各分量内是否存在非零边的方法做到 $O(N+M)$ 判断无解。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;const int MAXN = 100000 + 5;int N, K;struct Edge { int u, v, w, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;long long Dis[MAXN];bool Inq[MAXN];long long spfa() { for (int i = 1; i &lt;= N; ++i) { Dis[i] = 1; Que.push(i); } while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &lt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } long long res = 0; for (int i = 1; i &lt;= N; ++i) { res += Dis[i]; } return res;}int Dfn[MAXN], Low[MAXN], cntD;int Stk[MAXN], top;int Belong[MAXN], cntB;void dfs(int x) { Dfn[x] = Low[x] = ++cntD; Stk[++top] = x; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (!Dfn[v]) { dfs(v); Low[x] = std::min(Low[x], Low[v]); } else if (!Belong[v]) { Low[x] = std::min(Low[x], Dfn[v]); } } if (Dfn[x] == Low[x]) { Belong[x] = ++cntB; do { Belong[Stk[top]] = cntB; } while (Stk[top--] != x); }}int main() { int opt, x, y; scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 1; i &lt;= K; ++i) { scanf(\"%d%d%d\", &amp;opt, &amp;x, &amp;y); if (opt == 1) { addEdge(x, y, 0); addEdge(y, x, 0); } else if (opt == 2) { addEdge(x, y, 1); } else if (opt == 3) { addEdge(y, x, 0); } else if (opt == 4) { addEdge(y, x, 1); } else if (opt == 5) { addEdge(x, y, 0); } if (opt % 2 == 0 &amp;&amp; x == y) { puts(\"-1\"); return 0; } } for (int i = 1; i &lt;= N; ++i) { if (!Dfn[i]) { dfs(i); } } bool flag = 0; for (int i = 1; i &lt;= cntE; ++i) { if (E[i].w &amp;&amp; Belong[E[i].u] == Belong[E[i].v]) { flag = 1; break; } } if (flag) { puts(\"-1\"); } else { printf(\"%lld\\n\", spfa()); } return 0;}","link":"/BZOJ-2330/"},{"title":"最小割树学习笔记（Gomory-Hu Tree）","text":"总论在无向图中，最小割树等价于所有点对间的最小割。 对于任意点对 $(s,t)$，它们之间的最小割为最小割树上 $(s,t)$ 路径间的最小边权值。 过程可以通过求 $n-1$ 次最大流构建出具有 $n$ 个点的无向图 $G$ 的最小割树。 具体步骤如下： 任意选择两点 $s,t$ 求两点间最大流 $f$ 得到最小割隔开的两个集合 最小割树上连接 $(s,t)$，边权为 $f$ 将图恢复成最初形态（还原边权） 递归到这两个新集合中，重复操作1，直到集合中只有 $1$ 个点为止 由于每次集合总数增加 $1$，因此一共做 $n-1$ 次以上流程。 Q &amp; AQ1：如何求最小割隔开的两个集合？ A1：由于最小割上的边一定将流量限制流满了，因此从 $s$ 开始，通过未流满流量限制的边遍历到的且在当前集合中的点为与 $s$ 联通的点集合，剩下的点与 $t$ 联通的点集合。 Q2：用什么算法求最大流啊？会被卡吗？ A2：根据相关法律法规，ISAP和Dinic受到保护，应该不会被卡，EK死就死了。当然你愿意写HLPP也不拦着。 用途可以得到任意点对间的最小割，通常用于预处理。 例题 luogu P4897 【模板】最小割树（Gomory-Hu Tree） 【最小割树】[CQOI 2016] BZOJ 4519 不同的最小割 【最小割树】[ZJOI 2011] BZOJ 2229 最小割","link":"/Gomory-Hu-Tree/"}],"tags":[{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"Pruefer","slug":"Pruefer","link":"/tags/Pruefer/"},{"name":"ST表","slug":"ST表","link":"/tags/ST表/"},{"name":"可持久化Trie","slug":"可持久化Trie","link":"/tags/可持久化Trie/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"斯坦纳树","slug":"斯坦纳树","link":"/tags/斯坦纳树/"},{"name":"分数规划","slug":"分数规划","link":"/tags/分数规划/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"字典树","slug":"字典树","link":"/tags/字典树/"},{"name":"前后缀","slug":"前后缀","link":"/tags/前后缀/"},{"name":"费用流","slug":"费用流","link":"/tags/费用流/"},{"name":"树形DP","slug":"树形DP","link":"/tags/树形DP/"},{"name":"最小割树","slug":"最小割树","link":"/tags/最小割树/"},{"name":"背包","slug":"背包","link":"/tags/背包/"},{"name":"状压DP","slug":"状压DP","link":"/tags/状压DP/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"差分约束","slug":"差分约束","link":"/tags/差分约束/"},{"name":"最小割","slug":"最小割","link":"/tags/最小割/"}],"categories":[{"name":"51nod","slug":"51nod","link":"/categories/51nod/"},{"name":"BZOJ","slug":"BZOJ","link":"/categories/BZOJ/"},{"name":"JZOJ","slug":"JZOJ","link":"/categories/JZOJ/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/学习笔记/"}]}