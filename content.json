{"pages":[{"title":"关于我","text":"高二Oier，来自北京。 曾获NOIP2016普及组三等奖，NOIP2017/2018提高组一等奖，WC2019铜牌。","link":"/about/index.html"}],"posts":[{"title":"「HNOI 2005」BZOJ 1202 狡猾的商人","text":"给定 $M$ 组关于 $l, r, x$ 的等式，意为 $\\sum\\limits_{i=l}^{r}{A_i}=x$，判断是否可以构造出 $A[1\\cdots N]$ 满足这些等式。 $N\\leq 100,M\\leq 1000$ 题目链接BZOJ 1202 分析将等式写成前缀和的形式，用 $Sum[i]$ 表示 $\\sum\\limits_{j=1}^{i}{A_j}$ ，等式化为 $Sum[r] - Sum[l-1] = x$。 可以将等式变形成两个不等式， $Sum[r] - Sum[l-1] \\geq x$ 和 $Sum[l - 1] - Sum[r] \\geq -x$ 。 那么原问题就转化为差分约束系统求解模型。连接边 $(l - 1, r, x)$ 和 $(r, l - 1, -x)$ ，SPFA判断是否存在负环，复杂度 $O(NM)$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;const int MAXM = 1000 + 5;int N, M;struct Edge { int v, w, nxt;} E[MAXM * 3];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;int Dis[MAXN], Cnt[MAXN], Inq[MAXN];bool Vis[MAXN];int n;bool spfa() { while (!Que.empty()) { Que.pop(); } memset(Dis, 0x3f, sizeof Dis); memset(Inq, 0, sizeof Inq); memset(Cnt, 0, sizeof Cnt); Que.push(N + 1); Dis[N + 1] = 0; while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Cnt[v] = Cnt[x] + 1; if (Cnt[v] &gt; n) { return false; } if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } return true;}void init() { cntE = 0; memset(H, 0, sizeof H); n = 0; memset(Vis, 0, sizeof Vis);}int main() { int T, u, v, w; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); init(); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); if (!Vis[u - 1]) { Vis[u - 1] = 1; ++n; } if (!Vis[v]) { Vis[v] = 1; ++n; } addEdge(u - 1, v, -w); addEdge(v, u - 1, w); } for (int i = 1; i &lt;= N; ++i) { addEdge(N + 1, i, 0); } if (spfa()) { puts(\"true\"); } else { puts(\"false\"); } } return 0;}","link":"/BZOJ-1202/"},{"title":"「AHOI 2009」BZOJ 1798 维护序列","text":"维护序列 $A[1…N]$ ，共 $M$ 次操作，分为三种： $A[l,r]$ 所有数加 $x$ $A[l,r]$ 所有数乘 $x$ $A[l,r]$ 求和 答案对 $P$ 取模。 $N,M\\leq 100000,1\\leq P\\leq 1000000000$ 题库链接[AHOI2009]维护序列 分析线段树模板，注意lazy标签先处理乘法。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;struct Segment { int sum, add, mul;} T[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rll P;template&lt;class T, class G&gt; void inc(T &amp;x, G y) { (x += y) %= P;}template&lt;class T, class G&gt; void inu(T &amp;x, G y) { (x *= y) %= P;}void pushUp(int rt) { inc(T[rt].sum = 0, T[rt &lt;&lt; 1].sum + T[rt &lt;&lt; 1 | 1].sum);}void pushDown(int rt, int L) { Segment &amp;ls = T[rt &lt;&lt; 1], &amp;rs = T[rt &lt;&lt; 1 | 1]; int &amp;add = T[rt].add, &amp;mul = T[rt].mul; if (mul != 1) { inu(ls.sum, mul); inu(rs.sum, mul); inu(ls.add, mul); inu(rs.add, mul); inu(ls.mul, mul); inu(rs.mul, mul); mul = 1; } if (add != 0) { inc(ls.sum, add * (L - (L &gt;&gt; 1))); inc(rs.sum, add * (L &gt;&gt; 1)); inc(ls.add, add); inc(rs.add, add); add = 0; }}void build(int rt, int l, int r) { T[rt].add = 0, T[rt].mul = 1; if (l == r) { inc(T[rt].sum = 0, io::gt&lt;ll&gt;()); return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void mul(int rt, int l, int r, int a, int b, ll x) { if (a &lt;= l &amp;&amp; r &lt;= b) { inu(T[rt].sum, x); inu(T[rt].add, x); inu(T[rt].mul, x); return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { mul(LT, a, b, x); } if (m &lt; b) { mul(RT, a, b, x); } pushUp(rt);}void add(int rt, int l, int r, int a, int b, ll x) { if (a &lt;= l &amp;&amp; r &lt;= b) { inc(T[rt].sum, x * (r - l + 1)); inc(T[rt].add, x); return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { add(LT, a, b, x); } if (m &lt; b) { add(RT, a, b, x); } pushUp(rt);}ll querySum(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt].sum; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; ll res = 0; if (a &lt;= m) { inc(res, querySum(LT, a, b)); } if (m &lt; b) { inc(res, querySum(RT, a, b)); } return res;}int main() { int N = io::gt&lt;int&gt;(); P = io::gt&lt;ll&gt;(); build(1, 1, N); int M = io::gt&lt;int&gt;(); while (M--) { int opt = io::gt&lt;int&gt;(); int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); if (opt == 1) { mul(1, 1, N, l, r, io::gt&lt;ll&gt;() % P); } else if (opt == 2) { add(1, 1, N, l, r, io::gt&lt;ll&gt;() % P); } else { io::pt(querySum(1, 1, N, l, r)); } } io::flush(); return 0;}","link":"/BZOJ-1798/"},{"title":"「ZJOI 2011」BZOJ 2229 最小割","text":"$T$ 组数据，$Q$ 个询问。在无向图 $G$ 中，求有多少个点对 $(s,t)$ 使得它们之间的最小割不超过 $x$。 $T\\leq 10,n\\leq 150,m\\leq 3000,q\\leq 30$ 分析建完最小割树后，问题转化为求树上有多少个点对路径上的边权最小值不超过 $x$。 枚举点对再用倍增判断，复杂度 $O(n^2\\log{n})$。 也存在线性做法，对于边权不超过 $x$ 的边，统计路径通过该边新增的点对数量，复杂度 $O(n)$。 然而由于复杂度瓶颈在建立最小割树上，因此两种方法实际效率相仿。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* * @Author: Skqliao * @Date: 2019-02-02 22:57:06 * @LastEditTime: 2019-02-03 11:53:06 * @Source: ZJOI 2011 * @Problem: 2229: [Zjoi2011]最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2229 */#include &lt;bits/stdc++.h&gt;const int MAXN = 150 + 5;const int MAXM = 3000 + 5;namespace GH_Tree {struct Edge { int v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge){v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, w, H[v]}; H[v] = cntE;}int Fa[MAXN], Sz[MAXN];int dfs(int x) { Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; Sz[x] += dfs(v); } } return Sz[x];}int ans;int dfs(int x, int sz, int mx) { int tot = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { if (E[i].w &lt;= mx) { tot += Sz[v]; ans += Sz[v] * (sz - Sz[v]); sz -= Sz[v]; dfs(v, Sz[v], mx); } else { int tmp = dfs(v, sz, mx); sz -= tmp; tot += tmp; } } } return tot;}void init() { cntE = 0; memset(H, 0, sizeof H);}int query(int x) { ans = 0; dfs(1, Sz[1], x); return ans;}namespace Init { struct Edge { int v, f, cap, nxt; } E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; int Idx[MAXN], Tmp[MAXN]; int S, T; int Dis[MAXN], Cur[MAXN]; int Col[MAXN]; void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; } } void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE; } bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false; } int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left; } int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow; } void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); } } void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); GH_Tree::addEdge(S, T, f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r); } void solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); }} // namespace Init} // namespace GH_Treeint T, N, M, Q;int main() { int x; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); GH_Tree::init(); GH_Tree::Init::solve(N, M); GH_Tree::dfs(1); scanf(\"%d\", &amp;Q); while (Q--) { scanf(\"%d\", &amp;x); printf(\"%d\\n\", GH_Tree::query(x)); } puts(\"\"); } return 0;}","link":"/BZOJ-2229/"},{"title":"「中山市选 2009」 BZOJ 2464 小明的游戏","text":"在一个 $N\\times M$ 的01网格图中，每次可以向相邻的格子移动，移动到同一类型的格子的花费为 $0$，否则为 $1$，求起点到终点的最小花费。 $1\\leq n, m\\leq 500$ 分析由于边权非 $0$ 即 $1$，因此SPFA的复杂度上限就是点数，即 $N^2$ 。 复杂度 $O(T\\times N^2)$ ，其中 $T$ 为数据组数。 题库链接2464 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"game.in\", \"r\", stdin); freopen(\"game.out\", \"w\", stdout);}const int MAXN = 500 + 5;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;char Str[MAXN][MAXN];int sx, sy, ex, ey;bool check(int x, int y) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &lt; M;}int spfa() { static int Dis[MAXN][MAXN]; static bool Inq[MAXN][MAXN]; std::queue&lt;int, std::deque&lt;int&gt; &gt; Qx, Qy; memset(Inq, 0, sizeof Inq); memset(Dis, 0x3f, sizeof Dis); Qx.push(sx); Qy.push(sy); Dis[sx][sy] = 0; while (!Qx.empty()) { int x = Qx.front(), y = Qy.front(); Qx.pop(), Qy.pop(); Inq[x][y] = 0; rep(i, 0, 4) { int nx = x + Dicx[i];; int ny = y + Dicy[i]; if (!check(nx, ny)) { continue ; } int dis = Dis[x][y] + (Str[x][y] != Str[nx][ny]); if (Dis[nx][ny] &gt; dis) { Dis[nx][ny] = dis; if (!Inq[nx][ny]) { Inq[nx][ny] = 1; Qx.push(nx); Qy.push(ny); } } } } return Dis[ex][ey];}int main() { //open(); while (true) { scanf(\"%d%d\", &amp;N, &amp;M); if (N + M == 0) { break; } rep(i, 0, N) { scanf(\"%s\", Str[i]); } scanf(\"%d%d%d%d\", &amp;sx, &amp;sy, &amp;ex, &amp;ey); printf(\"%d\\n\", spfa()); } return 0;}","link":"/BZOJ-2464/"},{"title":"「中山市选 2009」BZOJ 2465 小球","text":"$n$ 个球放进 $m$ 个瓶子里，每个球有分数$A_i$，每个瓶子有容积 $B_i$，且瓶中球的分数都不能超过 $C_i$，求可放入球的最大数量以及在该条件下的最大分数和。 $1\\leq n\\leq 200,0\\leq m\\leq 200,1 \\leq p\\leq 10^6, 0\\leq c\\leq 200, 1\\leq q\\leq 10^6$ 分析费用流第一看看就是个很裸的费用流，用最大流来保证取的球最多，最小费用来保证总分数最大（分数取反作费用）。 用 $(u,v,f,c)$ 表示一条由 $u$ 到 $v$ 流量限制为 $f$ 费用为 $c$ 的边，那么本题建图方法如下： $(S, i, 1, 0) ,i \\in[1, n]$ $(i,T,B_i,0),i\\in[n+1,n+m]$ $(i,j,1,-A_i),A_i\\leq C_j$ 复杂度 $O(NMF)$，$F$ 为最大流的值。 贪心其实此题更明显的做法应该是贪心。 将球按照分数排序，由于它们空间相同（都是 $1$），因此将分数大的球放到分数限制大的瓶子里一定会放置最多的球。 复杂度 $O(M\\log{M}+N\\log{N})$ 。 题库链接2465 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt; #define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"ball.in\", \"r\", stdin); freopen(\"ball.out\", \"w\", stdout);} const int MAXN = 400 + 5;const int INF = INT_MAX;int A[MAXN], B[MAXN], C[MAXN]; struct Edge { int v, c, f, nxt;} E[MAXN * MAXN];int N, M, S, T;int cost, flow;int H[MAXN], cntE;int Lp[MAXN], Le[MAXN], Dis[MAXN];std::bitset&lt;MAXN&gt; Inq; void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE;} bool spfa() { static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if (!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;} void buildGraph() { S = N + M + 1, T = N + M + 2; memset(H, -1, sizeof H); cntE = -1; rep(i, 1, N + 1) { addEdge(S, i, 1, 0); } rep(i, 1, M + 1) { addEdge(i + N, T, B[i], 0); } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (::A[i] &lt;= ::C[j]) { addEdge(i, N + j, INF, -::A[i]); } } }} void mcmf() { buildGraph(); cost = flow = 0; while (spfa()) { int f = INF; for (int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } cost += f * Dis[T]; flow += f; for (int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } }} int main() { //open(); while (true) { scanf(\"%d%d\", &amp;N, &amp;M); if (N + M == 0) { break; } rep(i, 1, N + 1) { scanf(\"%d\", &amp;A[i]); } rep(i, 1, M + 1) { scanf(\"%d%d\", &amp;B[i], &amp;C[i]); } mcmf(); printf(\"%d %d\\n\", flow, -cost); } return 0;}","link":"/BZOJ-2465/"},{"title":"「SCOI 2011」BZOJ 2330 糖果","text":"有 $N$ 个数 $A[1 \\cdots N](A[i] &gt; 0)$，要求满足 $M$ 个条件。条件形如： $A[i] \\leq A[j]$，$A[i] &lt; A[j]$， $A[i] = A[j]$ 。如果可以满足所有条件，求 $\\sum{A_i}$ 的最小值，否则输出 -1。 $N,M\\leq 100000$ 题目链接BZOJ 2330 分析将条件依次转化为 $A[j] - A[i] \\geq 0$，$A[j] - A[i]\\geq 1$，$A[j]-A[i]\\geq 0 \\&amp; A[i]-A[j]\\geq 0$。 根据 $u - v\\geq w$ 建有向边 $(v, u, w)$ 的方式建图，求最长路。 如果单纯通过spfa进队 $N$ 次来判断无解可能会导致超时，发现无解本质为出现正环。因此可以采用Tarjan求联通分量，判断各分量内是否存在非零边的方法做到 $O(N+M)$ 判断无解。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;const int MAXN = 100000 + 5;int N, K;struct Edge { int u, v, w, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;long long Dis[MAXN];bool Inq[MAXN];long long spfa() { for (int i = 1; i &lt;= N; ++i) { Dis[i] = 1; Que.push(i); } while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &lt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } long long res = 0; for (int i = 1; i &lt;= N; ++i) { res += Dis[i]; } return res;}int Dfn[MAXN], Low[MAXN], cntD;int Stk[MAXN], top;int Belong[MAXN], cntB;void dfs(int x) { Dfn[x] = Low[x] = ++cntD; Stk[++top] = x; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (!Dfn[v]) { dfs(v); Low[x] = std::min(Low[x], Low[v]); } else if (!Belong[v]) { Low[x] = std::min(Low[x], Dfn[v]); } } if (Dfn[x] == Low[x]) { Belong[x] = ++cntB; do { Belong[Stk[top]] = cntB; } while (Stk[top--] != x); }}int main() { int opt, x, y; scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 1; i &lt;= K; ++i) { scanf(\"%d%d%d\", &amp;opt, &amp;x, &amp;y); if (opt == 1) { addEdge(x, y, 0); addEdge(y, x, 0); } else if (opt == 2) { addEdge(x, y, 1); } else if (opt == 3) { addEdge(y, x, 0); } else if (opt == 4) { addEdge(y, x, 1); } else if (opt == 5) { addEdge(x, y, 0); } if (opt % 2 == 0 &amp;&amp; x == y) { puts(\"-1\"); return 0; } } for (int i = 1; i &lt;= N; ++i) { if (!Dfn[i]) { dfs(i); } } bool flag = 0; for (int i = 1; i &lt;= cntE; ++i) { if (E[i].w &amp;&amp; Belong[E[i].u] == Belong[E[i].v]) { flag = 1; break; } } if (flag) { puts(\"-1\"); } else { printf(\"%lld\\n\", spfa()); } return 0;}","link":"/BZOJ-2330/"},{"title":"「中山市选 2009」BZOJ 2466 树","text":"树 $T$ 上的每个节点都一盏熄灭的灯，已知按下某个节点的开关会改变它与它相连的所有节点的灯的状态，求将所有灯变亮的最少操作次数。 $1\\leq n\\leq 100$。 分析发现每个操作都是独立的，也就是说至多每个开关按一次。 再根据按开关会改变所有与它相连的灯的状态，想到一定是自叶子到根进行操作，那么就树形DP。 DP中注意当前节点无论亮与否，它的子树一定是全亮的（因为操作是一直往根上走的）。 对于一个节点有四种状态：按开关且亮、按开关且灭、不按开关且亮、不按开关且灭。 可以发现第二种没有意义（不按都亮了那还按它干什么）。 考虑剩余三种的状态如何从儿子转移。 其中“按开关且亮”的状态最简单，因为按了它之后要保证它的子树的灯全是亮的，因此从“它的所有儿子都灭且没按”的状态转移而来。 “不按开关且灭”的状态从“当前亮+当前儿子按且亮”或“当前灭+当前儿子不按且亮”转移。 “不按开关且亮”的状态从“当前亮+当前儿子不按且亮”或“当前灭+当前儿子按且亮”转移。 复杂度 $O(n)$ 。 题库链接2466 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"tree.in\", \"r\", stdin); freopen(\"tree.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int INF = 0x03ffffff;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int N;int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}int F[MAXN][2][2];void dfs(int x, int fa) { int a = 0, b = INF, c = 0; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa) { int aa = a, bb = b; dfs(v, x); a = std::min(aa + F[v][0][1], bb + F[v][1][1]); b = std::min(aa + F[v][1][1], bb + F[v][0][1]); c += F[v][0][0]; } } F[x][0][0] = a; F[x][0][1] = b; F[x][1][1] = c + 1;}int main() { //open(); int u, v; while (true) { scanf(\"%d\", &amp;N); if (N == 0) { break; } cntE = -1; memset(H, -1, sizeof H); rep(i, 1, N) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); } dfs(1, 0); printf(\"%d\\n\", std::min(F[1][0][1], F[1][1][1])); } return 0;}","link":"/BZOJ-2466/"},{"title":"「WC 2008」BZOJ 2595 游览计划","text":"在 $n\\times m$ 的网格图上有 $k$ 个景点，图上选择任意一个点有费用 $a_{i,j}$。求选择若干个点使得这 $k​$ 个景点联通，最小化花费并输出方案。 $n,m,k\\leq 10$ 分析这是一道最小斯坦纳树（minimum Steiner tree）的模板题。 其实看到这么小的数据范围也不难想到状压DP。用 $F[i][j][S]$ 表示当前选择点 $(i,j)$，图的联通状态为 $S$ 的最小花费。 转移方程有两个，一是状态间转移： $F[i][j][S] = \\min\\limits_{T\\in S}{F[i][j][T]+F[i][j][S-T]-A[i][j]}$；二是在同一个状态内松弛： $F[i][j][S] = \\min{F[i’][j’][S]+A[i][j]}$，其中 $(i’,j’)$ 与 $(i,j)$ 联通且属于 $S$。 前者可以通过枚举子集的方法转移，复杂度$O(6^k\\cdot n\\cdot m)$，后者用spfa或其他最短路算法松弛，复杂度 $O(2^k\\cdot f)$，$f$ 为最短路复杂度。总复杂度 $O(6^k\\cdot nm+2^k\\cdot f)$ 。 在转移/松弛时记录前一个点的状态，最后从终点一遍dfs得到所有被选择的点。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 /* * @Author: Skqliao * @Date: 2019-01-27 10:29:05 * @LastEditTime: 2019-01-27 12:39:07 * @Source: WC2008 * @Problem: 2595: [Wc2008]游览计划 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2595 */#include &lt;bits/stdc++.h&gt;const int MAXN = 10 + 2;const int MAXS = 1 &lt;&lt; MAXN;const int INF = 0x3f3f3f3f;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;int A[MAXN][MAXN];int F[MAXN][MAXN][MAXS];struct Node { int x, y, s;} Pre[MAXN][MAXN][MAXS];std::queue&lt;Node&gt; Que;bool Vis[MAXN][MAXN];void spfa(int s) { while (!Que.empty()) { Node a = Que.front(); Vis[a.x][a.y] = 0; Que.pop(); for (int i = 0; i &lt; 4; ++i) { int x = a.x + Dicx[i]; int y = a.y + Dicy[i]; if (x &lt; 1 || y &lt; 1 || x &gt; N || y &gt; M) { continue; } if (F[a.x][a.y][s] + A[x][y] &lt; F[x][y][s]) { F[x][y][s] = F[a.x][a.y][s] + A[x][y]; Pre[x][y][s] = (Node){a.x, a.y, s}; if (!Vis[x][y]) { Que.push((Node) {x, y, 0}); Vis[x][y] = 1; } } } }}void dfs(int x, int y, int s) { Vis[x][y] = 1; Node &amp;a = Pre[x][y][s]; if (a.x == 0 &amp;&amp; a.y == 0) { return ; } dfs(a.x, a.y, a.s); if (x == a.x &amp;&amp; y == a.y) { dfs(a.x, a.y, s - a.s); }}int main() { int cnt = 0; scanf(\"%d%d\", &amp;N, &amp;M); memset(F, 0x3f, sizeof F); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); if (!A[i][j]) { F[i][j][1 &lt;&lt; cnt++] = 0; } } } int S = (1 &lt;&lt; cnt) - 1; for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { for (int x = s; x; x = (x - 1) &amp; s) { if (F[i][j][x] + F[i][j][s - x] - A[i][j] &lt; F[i][j][s]) { F[i][j][s] = F[i][j][x] + F[i][j][s - x] - A[i][j]; Pre[i][j][s] = (Node) {i, j, x}; } } if (F[i][j][s] &lt; INF) { Que.push((Node) {i, j, 0}); Vis[i][j] = 1; } } } spfa(s); } bool flag = 0; for (int i = 1; i &lt;= N &amp;&amp; !flag; ++i) { for (int j = 1; j &lt;= M; ++j) { if (A[i][j] == 0) { printf(\"%d\\n\", F[i][j][S]); dfs(i, j, S); flag = 1; break; } } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { if (!A[i][j]) { putchar('x'); } else if (Vis[i][j]) { putchar('o'); } else { putchar('_'); } } puts(\"\"); } return 0;}","link":"/BZOJ-2595/"},{"title":"「2010 集训队测验」BZOJ 2127 文理分科","text":"在 $n\\times m$ 的矩阵中，每个格子可以选择 $0/1$，分别获得收益 $A_{i,j},B_{i,j}$。如果上下两个格子选择相同，则额外获得收益 $C_{i,j},D_{i,j}$（都选$0/1$），如果左右两个格子选择相同，则额外获得收益 $E_{i,j},F_{i,j}$。求总收益的最大值。 $n,m\\leq 100,A,B,C,D,E,F_{i,j}\\leq 5000$ 分析这是集训队论文《浅谈一类最小割问题》中的例题，也是网络流建模之二元关系的一道典型题目。 根据相关建图模型，对于每个点 $x$，分别与 $S,T$ 连边，割去 $(S,x)$表示选择文科，割去 $(x,T)$ 表示选择理科。 由于只能求最小割，因此可以先累计所有收益再减去最小割得到最大值。 由于每个点与相邻的点之间的选择会影响结果，因此 $x$ 与相邻的点连边。 对于任意两个相邻点 $x,y$，子图有边 $(S,x),(S,y),(x,y),(y,x),(x,T),(y,T)$。 割去 $(S,x),(S,y)$ 表示都选文，割去 $(x,T),(y,T)$ 表示都选理，割去 $(S,x),(x,y),(y,T)$ 表示 $x$ 选文，$y$选理，剩下一种情况同理第三种。 假设 $x,y$ 选文的收益分别为 $a_x,a_y$，选理的收益为 $b_x,b_y$，都选文/理的收益为 $c,d$，则边权应满足： $$(S,x)+(S,y)=b_x+b_y+d\\(x,T)+(y,T)=a_x+a_y+c\\(S,x)+(x,y)+(y,T)=a_y+b_x+c+d\\(S,y)+(y,x)+(x,T)=a_x+b_y+c+d\\$$得到一组解： $$(x,y)=(y,x)=\\frac{c+d}{2}\\(S,x)=a_x+\\frac{c}{2}\\(S,y)=a_y+\\frac{c}{2}\\(x,T)=b_x+\\frac{d}{2}\\(y,T)=b_y+\\frac{d}{2}\\$$ 由此建图求最大流即可。 Tips：将两点间所有边的边权整合成一条边会大大提高运行速度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* * @Author: Skqliao * @Date: 2019-02-10 20:45:11 * @LastEditTime: 2019-02-10 21:37:48 * @Source: 2010 集训队测试题 * @Problem: 2127: happiness * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2127 */#include &lt;bits/stdc++.h&gt;namespace mxf {const int MAXN = 100 * 100 + 5;const int MAXM = MAXN * 4;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int S, T;int H[MAXN], cntE;void addEdge(int u, int v, int f, bool directed = 1) { E[++cntE] = (Edge){v, f, H[u]}; H[u] = cntE; if (directed) f = 0; E[++cntE] = (Edge){u, f, H[v]}; H[v] = cntE;}int Dis[MAXN], Cur[MAXN];bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memset(Dis, -1, sizeof Dis); memcpy(Cur, H, sizeof H); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) { flow += dfs(S, INT_MAX); } return flow;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}} // namespace mxfusing mxf::addEdge;using mxf::S;using mxf::T;const int MAXN = 100 + 5;int N, M;int Id[MAXN][MAXN];int A[MAXN][MAXN], B[MAXN][MAXN], C[MAXN][MAXN], D[MAXN][MAXN], E[MAXN][MAXN], F[MAXN][MAXN];int ans;int main() { scanf(\"%d%d\", &amp;N, &amp;M); mxf::init(N * M); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { Id[i][j] = (i - 1) * M + j; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); ans += A[i][j]; A[i][j] *= 2; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;B[i][j]); ans += B[i][j]; B[i][j] *= 2; } } for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;C[i][j]); ans += C[i][j]; A[i][j] += C[i][j]; A[i + 1][j] += C[i][j]; } } for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;D[i][j]); ans += D[i][j]; B[i][j] += D[i][j]; B[i + 1][j] += D[i][j]; addEdge(Id[i][j], Id[i + 1][j], C[i][j] + D[i][j], 0); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;E[i][j]); ans += E[i][j]; A[i][j] += E[i][j]; A[i][j + 1] += E[i][j]; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;F[i][j]); ans += F[i][j]; B[i][j] += F[i][j]; B[i][j + 1] += F[i][j]; addEdge(Id[i][j], Id[i][j + 1], E[i][j] + F[i][j], 0); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { addEdge(S, Id[i][j], A[i][j]); addEdge(Id[i][j], T, B[i][j]); } } printf(\"%d\\n\", ans - mxf::dinic() / 2); return 0;}","link":"/BZOJ-2127/"},{"title":"「SCOI 2014」BZOJ 3597 方伯伯运椰子","text":"在有向无环图 $G$ 中，每条边的流量与容量相等。现可以修改每条边的容量，使得新的边依然满足流量与容量相等，且总流量不变。已知扩展/缩小每条边容量的单位花费，以及流量通过该边的单位花费。记原总花费 $X$，现在总花费 $Y$（包括修改容量和流量的花费），修改了 $K$ 条边的容量，则收益为 $w=(X-Y)/K$，求$w$的最大值。 $N\\leq 5000$ 题目链接BZOJ 3597 分析这道题的核心在于理解“总流量不变且每条边跑满”，可以用网络流的模型理解。 所谓扩容即增广，花费为扩容费用+流量费用；压缩即退流，花费为压缩费用-流量费用。 假设 $a\\geq(X-Y)/K$，则 $Y-X+a\\cdot K\\geq 0$。 而 $Y-X$ 就是增广和退流的费用之和，$K$ 可以分摊到每条边上，即让每条边的权值增加 $K$。 $a$ 显然是可以二分的，那么若新图出现负环，则说明 $a$ 的值不够大，直到得到解为止。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;const int MAXN = 5000 + 5;const double INF = 1e9;const double eps = 1e-4;int N, M;struct Edge { int v; double w; int nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}double Dis[MAXN];bool Vis[MAXN];bool dfs_spfa(int x, double xx) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; double dis = Dis[x] + E[i].w + xx; if (Dis[v] &gt; dis) { Dis[v] = dis; if (Vis[v] || dfs_spfa(v, xx)) { return true; } } } return Vis[x] = 0;}bool check(double a) { for (int i = 1; i &lt;= N; ++i) { Dis[i] = INF; } Dis[N - 1] = 0; memset(Vis, 0, sizeof Vis); for (int i = 1; i &lt;= N; ++i) { if (dfs_spfa(i, a)) { return true; } } return false;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); N += 2; int a, b, c, d, u, v; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d%d%d%d\", &amp;u, &amp;v, &amp;a, &amp;b, &amp;c, &amp;d); if (u == N - 1) { continue; } if (c) { addEdge(v, u, a - d); } addEdge(u, v, b + d); } double l = 0, r = INF, ans; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { ans = l = m; } else { r = m; } } printf(\"%.2lf\\n\", ans); return 0;}","link":"/BZOJ-3597/"},{"title":"「JLOI 2015」BZOJ 4006 管道连接","text":"无向图中有 $n$ 个 $m$ 条边，边有权值 $W_i$，有 $p$ 个点有编号 $A_i$。现要求选择一些边，使得（有编号且）编号相同的点联通，求最小权值和。 $n\\leq 1000,m\\leq 3000,p\\leq 10$ 分析如果要求所有有编号的点联通，那么这就是一个最小斯坦纳树的模板题。 现在只要求编号相同的点联通，我们可以分别考虑每个编号的点联通的费用，然后组合出最终的答案。 因此依然先求这 $p$ 个点的最小斯坦纳树。然后再用状压DP合并费用，注意合并时（$s=a+b$）， $a,b$ 必须分别完整包含若干个编号的节点，否则不合题意。 复杂度 $O(3^p\\cdot n)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* * @Author: Skqliao * @Date: 2019-01-27 13:24:25 * @LastEditTime: 2019-01-27 14:52:32 * @Source: JLOI 2015 * @Problem: 4006: [JLOI2015]管道连接 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4006 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000 + 2;const int MAXM = 30000 + 5;const int MAXS = 1 &lt;&lt; 12;const int INF = 0x3f3f3f3f;struct Edge { int u, v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int N, M, P;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {v, u, w, H[v]}; H[v] = cntE;}int F[MAXN][MAXS];std::queue&lt;int&gt; Que;bool Vis[MAXN];void spfa(int s) { while (!Que.empty()) { int x = Que.front(); Vis[x] = 0; Que.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (F[x][s] + E[i].w &lt; F[v][s]) { F[v][s] = F[x][s] + E[i].w; if (!Vis[v]) { Que.push(v); Vis[v] = 1; } } } }}int Dp[MAXS];int St[MAXN];std::vector&lt;int&gt; V[MAXN];bool check(int s) { for (int i = 1; i &lt;= 10; ++i) { if (!St[i]) { continue; } if ((St[i] &amp; s) != 0 &amp;&amp; (St[i] &amp; s) != St[i]) { return false; } } return true;}int main() { scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;P); int u, v, w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } memset(F, 0x3f, sizeof F); int p = 0; for (int i = 1; i &lt;= P; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); V[u].push_back(p); F[v][1 &lt;&lt; p++] = 0; } for (int i = 1; i &lt;= 10; ++i) { for (size_t j = 0; j &lt; V[i].size(); ++j) { St[i] |= 1 &lt;&lt; V[i][j]; } } int S = (1 &lt;&lt; p) - 1; memset(Dp, 0x3f, sizeof Dp); for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int x = s; x; x = (x - 1) &amp; s) { F[i][s] = std::min(F[i][s], F[i][x] + F[i][s - x]); } if (F[i][s] &lt; INF) { Que.push(i); } } spfa(s); for (int i = 1; i &lt;= N; ++i) { Dp[s] = std::min(Dp[s], F[i][s]); } } for (int s = 0; s &lt;= S; ++s) { if (check(s)) { for (int x = s; x; x = (x - 1) &amp; s) { if (check(x)) { Dp[s] = std::min(Dp[s], Dp[x] + Dp[s - x]); } } } } printf(\"%d\\n\", Dp[S]); return 0;}","link":"/BZOJ-4006/"},{"title":"BZOJ 4260 Codechef REBXOR","text":"对于长为 $N$ 的序列 $A[1\\cdots N]$，求两个不相交区间的异或和之和的最大值。 $2\\leq N\\leq 4\\times 10^5,A[i]\\leq 10^9$ 题目链接BZOJ 4260 分析根据异或的性质， 令 $S[i]=A[1]\\oplus A[2]\\cdots \\oplus A[i]$，则$A[l]\\oplus\\cdots \\oplus A[r]=S[r]\\oplus S[l-1]$。 令 $L[i]$ 为 $A[1\\cdots i]$ 中的最大区间异或和， $R[i]$ 为 $A[i\\cdots N]$ 中的最大区间异或和，如此 $L[i],R[i+1]$ 一定不相交，答案为 $max(L[i]+R[i+1])$。 从前往后在01字典树中查询当前前缀异或和 $cur$ 能异或得到的最大值，并将 $cur$插入，则$L[i]=\\max(L[i-1],query(cur))$。 再从后往前插入后缀异或和，则 $R[i]=\\max(R[i+1],query(cur))$。 复杂度 $O(n\\log{n})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;const int MAXN = 4e5 + 5;const int MAXM = 40;struct Node { int sz, num; int ch[2];} T[MAXN * MAXM];int cntT;int N, A[MAXN];int L[MAXN], R[MAXN];void insert(int rt, int x) { for (int i = 32; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (!T[rt].ch[c]) { T[rt].ch[c] = ++cntT; T[cntT].ch[0] = T[cntT].ch[1] = 0; T[cntT].sz = 0; } ++T[rt].sz; rt = T[rt].ch[c]; } T[rt].num = x;}int query(int rt, int x) { for (int i = 32; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (!T[rt].ch[c ^ 1]) { rt = T[rt].ch[c]; } else { rt = T[rt].ch[c ^ 1]; } } return x ^ T[rt].num;}void init() { cntT = 1; T[1].ch[0] = T[1].ch[1] = 0; T[1].sz = T[1].num = 0;}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); } int lst = 0; insert(1, 0); for (int i = 1; i &lt;= N; ++i) { lst ^= A[i]; L[i] = std::max(L[i - 1], query(1, lst)); insert(1, lst); } init(); lst = 0; insert(1, 0); for (int i = N; i &gt;= 1; --i) { lst ^= A[i]; R[i] = std::max(R[i + 1], query(1, lst)); insert(1, lst); } int ans = 0; for (int i = 1; i &lt; N; ++i) { ans = std::max(ans, L[i] + R[i + 1]); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-4260/"},{"title":"「CQOI 2016」BZOJ 4519 不同的最小割","text":"题目大意在无向图 $G$ 中，对于任意点对 $(i,j)$ 有最小割 $cut(i,j)$，求有多少个数值不同的最小割。 $N\\leq 850,M\\leq 8500$ 分析最小割树模板题，求出最小割树后将所有边unique得到答案。 复杂度 $O(n\\times f)$，$f$ 为最大流复杂度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* * @Author: Skqliao * @Date: 2019-02-02 22:26:52 * @LastEditTime: 2019-02-02 22:54:36 * @Source: CQOI 2016 * @Problem: 4519: [Cqoi2016]不同的最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4519 */#include &lt;bits/stdc++.h&gt;const int MAXN = 850 + 5;const int MAXM = 8500 + 5;namespace GH_Tree {struct Edge { int v, f, cap, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Idx[MAXN], Tmp[MAXN];int S, T;int Dis[MAXN], Cur[MAXN];int Col[MAXN];void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; }}void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow;}void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); }}std::vector&lt;int&gt; V;void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); V.push_back(f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r);}int solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); std::sort(V.begin(), V.end()); V.erase(std::unique(V.begin(), V.end()), V.end()); return V.size();}} // namespace GH_Treeint N, M;int main() { scanf(\"%d%d\", &amp;N, &amp;M); printf(\"%d\\n\", GH_Tree::solve(N, M)); return 0;}","link":"/BZOJ-4519/"},{"title":"「JSOI 2016」BZOJ 4753 最佳团体","text":"每个点有一个父亲，它能被选择当且仅当它父亲被选择，0号节点默认被选择。每个点有收益 $X[i]$，代价 $Y[i]$。选择恰好 $K$ 个点（不算0号），使得其对应的 $\\sum{X[i]}/\\sum{Y[i]}$ 最大。 $N\\leq 2500$ 题目链接BZOJ 4753 分析通过分数规划，二分答案来避免除法。 选择关系是一棵树，被选择的点处于一个联通分量。树形背包，转移时父亲被强制选择。 复杂度 $O(NK\\log{X[i]})$ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;const int MAXN = 2500 + 5;const double eps = 1e-4;int N, K;int A[MAXN], B[MAXN], P[MAXN];std::vector&lt;int&gt; G[MAXN];double F[MAXN][MAXN], Tmp[MAXN];int Sz[MAXN];void dfs(int x, double m) { F[x][0] = 0; F[x][1] = B[x] - A[x] * m; Sz[x] = 1; for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; dfs(v, m); memset(Tmp, 0xc2, sizeof Tmp); Tmp[0] = 0; for (int j = 1; j &lt;= Sz[x]; ++j) { for (int k = 0; k &lt;= Sz[v] &amp;&amp; j + k &lt;= K; ++k) { Tmp[j + k] = std::max(Tmp[j + k], F[x][j] + F[v][k]); } } Sz[x] += Sz[v]; memcpy(F[x], Tmp, sizeof Tmp); }}bool check(double m) { memset(F, 0xc2, sizeof F); dfs(0, m); return F[0][K] &gt;= 0;}int main() { scanf(\"%d%d\", &amp;K, &amp;N); ++K; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d%d\", &amp;A[i], &amp;B[i], &amp;P[i]); G[P[i]].push_back(i); } double l = 0, r = 1e4, ans; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { l = ans = m; } else { r = m; } } printf(\"%.3lf\\n\", ans); return 0;}","link":"/BZOJ-4753/"},{"title":"51nod 1601 完全图的最小生成树计数","text":"有 $n$ 个点，每个点有点权 $a_i$，点 $u,v$ 之间的边边权为 $a_u \\oplus a_v$。求该完全图的最小生成树的权值与方案数。 $n\\leq 10^5,0\\leq a_i&lt; 2^{30}$ 分析从边权为点xor得到，想到可以对点权建立Trie树。 每次合并两子树mst的权值，并加入两子树中节点可以xor得到的最小值作为连接这两棵子树的最小边，自下而上得到整棵Trie的mst的值。 根据Cayley公式，如果存在有 $a(a&gt;2)$ 个相同权值的点时，生成树的方案数为 $a^{a-2}$。每次合并两子树时对方案数做乘法原理即可得到最终的方案数。 复杂度 $O(n\\log{a_i})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 22:59:31 * @LastEditTime: 2019-01-26 23:41:49 * @Source: 51nod * @Problem: 1601 完全图的最小生成树计数 * @Url: https://www.51nod.com/Challenge/Problem.html#!#problemId=1601 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1e5 + 5;const int MOD = 1e9 + 7;int N;int Ch[MAXN &lt;&lt; 5][2], Num[MAXN &lt;&lt; 5], cnt = 1;long long sum, num = 1;void insert(int val) { int x = 1; for (int i = 29; i &gt;= 0; --i) { int d = (val &gt;&gt; i) &amp; 1; if (!Ch[x][d]) { Ch[x][d] = ++cnt; } x = Ch[x][d]; } ++Num[x];}long long poww(long long x, long long t) { long long ans = 1; for (; t; t &gt;&gt;= 1) { if (t &amp; 1) { ans = ans * x % MOD; } x = x * x % MOD; } return ans;}long long min, tmp;void getMin(int x, int y, int d, int v = 0) { if (d &lt; 0) { if (v &lt; min) { min = v; tmp = (long long)Num[x] * Num[y] % MOD; } else if (v == min) { tmp = (tmp + (long long)Num[x] * Num[y]) % MOD; } return; } if (Ch[x][0] &amp;&amp; Ch[y][0]) { getMin(Ch[x][0], Ch[y][0], d - 1, v); if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } } else if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } else { if (Ch[x][0]) { getMin(Ch[x][0], Ch[y][1], d - 1, v + (1 &lt;&lt; d)); } if (Ch[x][1]) { getMin(Ch[x][1], Ch[y][0], d - 1, v + (1 &lt;&lt; d)); } }}void cal(int x, int d) { if (d &lt; 0) { if (Num[x] &gt; 1) { num = num * poww(Num[x], Num[x] - 2); } return; } if (!Ch[x][0]) { cal(Ch[x][1], d - 1); } else if (!Ch[x][1]) { cal(Ch[x][0], d - 1); } else { cal(Ch[x][0], d - 1); cal(Ch[x][1], d - 1); min = 1 &lt;&lt; 30; tmp = 0; getMin(Ch[x][0], Ch[x][1], d - 1, 0); sum = sum + (1 &lt;&lt; d) + min; num = (num * tmp) % MOD; }}int main() { scanf(\"%d\", &amp;N); int x; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); insert(x); } cal(1, 29); printf(\"%lld\\n%lld\\n\", sum, num); return 0;}","link":"/51nod-1601/"},{"title":"BZOJ 2741【FOTILE模拟赛】L","text":"给定长为 $N$ 的序列 $A[1 \\cdots N]$，$M$ 个询问。查询 $[l,r]$ 的最大异或和子区间，强制在线。 $N\\leq 12000,M\\leq 6000$ 题目链接BZOJ 2741【FOTILE模拟赛】L 分析可持久化Trie+分块。 记 $s[i]$ 为第 $i$ 块的左端点，$f(i,j)$ 表示$[s[i],r-1]$中的某个点为左端点，右端点为 $r$ 的最大异或子区间。 记 $g(i,j)$ 为$[s[i],r]$ 中的最大异或子区间，则 $g(i,j)=max(g(i,j-1),f(i,j))$。 查询时跨越的完整块直接查 $g$ 数组，剩下的部分在可持久化Trie中查询，取最大值。 复杂度 $O(n\\sqrt{n}\\log{max(A_i)})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;const int MAXN = 12000 + 5;const int MAXM = 40;const int MAXK = 130;int N, M, A[MAXN];struct Trie { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], nT = 1;int insert(int pre, int x) { int rt = ++nT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++nT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int len, n, Belong[MAXN], G[MAXK][MAXN];int queryLR(int l, int r) { int ans = 0, t = r; for (int i = 1; i &lt;= n; ++i) { if ((i - 1) * len + 1 &gt;= l &amp;&amp; (i - 1) * len + 1 &lt;= r) { ans = G[i][r]; t = (i - 1) * len + 1; break; } } for (int i = l; i &lt;= t; ++i) { ans = std::max(ans, query(Rt[l - 1], Rt[r], A[i])); } return ans;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); len = sqrt(N), n = N / len + (N % len &gt; 0); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); A[i] ^= A[i - 1]; Rt[i] = insert(Rt[i - 1], A[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = (i - 1) * len + 1; j &lt;= N; ++j) { G[i][j] = std::max(G[i][j - 1], query(Rt[(i - 1) * len], Rt[j - 1], A[j])); if (i == 1) { G[i][j] = std::max(G[i][j], A[j]); } } } int ans = 0, l, r; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d\", &amp;l, &amp;r); ans %= N; l = (l + ans) % N + 1; r = (r + ans) % N + 1; if (l &gt; r) { std::swap(l, r); } printf(\"%d\\n\", ans = queryLR(l - 1, r)); } return 0;}","link":"/BZOJ-2741/"},{"title":"「HNOI 2009」BZOJ 1486 最小圈","text":"在有向图 $G$ 中，定义环 $a$ 的权值 $w_a=\\sum{W[i]}/num$，其中 $W[i]$ 为 $a$ 上边的权值， $num$ 为 $a$ 上的节点数。求图中 $w$ 的最小值。 $n\\leq 1000,m\\leq 5000,|W[i]|\\leq 5000$ 题目链接BZOJ 1486 分析设 $w_a=x$，则 $\\sum{W[i]}/num \\geq x$，即 $\\sum{W[i]}\\geq num\\cdot x$。 由于环上点数和边数相同，因此可以改写为 $\\sum(W[i]-x)\\geq 0$。 $x$ 显然可以二分，于是就变成了判断图中是否存在负环的问题，用SPFA可解。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;const int MAXN = 3000 + 5;const int MAXM = 10000 + 5;const double INF = 1e7;const double eps = 1e-9;int N, M;struct Edge { int v; double w; int nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}double Dis[MAXN];bool Vis[MAXN], flag;bool dfs_spfa(int x, double xx) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; double dis = Dis[x] + E[i].w - xx; if (Dis[v] &gt; dis) { Dis[v] = dis; if (Vis[v] || dfs_spfa(v, xx)) { return true; } } } return Vis[x] = 0;}bool check(double a) { flag = 0; for (int i = 1; i &lt;= N; ++i) { Dis[i] = INF; } memset(Vis, 0, sizeof Vis); for (int i = 1; i &lt;= N; ++i) { if (dfs_spfa(i, a)) { return true; } } return false;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); int u, v; double w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%lf\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } double l = -INF, r = INF, ans = 0; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { r = m; ans = m; } else { l = m; } } printf(\"%.8lf\\n\", ans); return 0;}","link":"/BZOJ-1486/"},{"title":"「SDOI 2017」BZOJ 4819 新生舞会","text":"双方各有 $N$ 个人进行两两配对，$i$ 和 $j$ 配对会获得 $x=A[i][j]$ 的收益和 $y=B[i][j]$ 的代价。最小化 $\\sum{x}/\\sum{y}$。 $N\\leq 100,x,y\\leq 10^4$ 题目链接BZOJ 4819 分析若 $\\sum{x}/\\sum{y}\\geq a$，则 $\\sum{x}-a\\cdot\\sum{y} \\geq 0$，再转化变成 $\\sum{x-a\\cdot y}\\geq 0$。 $a$ 显然是可以二分的，然后建图跑最小费用最大流，边权为 $a\\cdot B[i][j]-A[i][j]$，判定合法即总费用是否小于0。 有更快的Dinkelbach算法，考虑用迭代的方式求 $a$。初始化 $a=0$，得到一组合法解后，更新 $a$ 为当前情况下的 $\\sum{x}/\\sum{y}$，直到求得答案。此方法实测比二分快了10倍。 费用流的过程本质就是一个二分图最大权匹配，因此跑KM也是可行的，复杂度上界 $O(\\log{(10^6\\cdot x)}\\cdot n^3)$，实则远远跑不满。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;const int MAXN = 200 + 5;const int MAXM = MAXN * MAXN;const double eps = 1e-7;const double INF = 1e7;int N, A[MAXN][MAXN], B[MAXN][MAXN];struct Edge { int v; double w; int f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w, int f) { E[++cntE] = (Edge) {v, w, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -w, 0, H[v]}; H[v] = cntE;}int S, T;void buildGraph(double x) { memset(H, 0, sizeof H); cntE = 1; S = 0; T = N * 2 + 1; for (int i = 1; i &lt;= N; ++i) { addEdge(S, i, 0, 1); addEdge(i + N, T, 0, 1); for (int j = 1; j &lt;= N; ++j) { addEdge(i, j + N, x * B[i][j] - A[i][j], 1); } }}int Pe[MAXN], Pv[MAXN];double Dis[MAXN];bool Vis[MAXN];struct cmp { inline bool operator () (const int &amp;x, const int &amp;y) const { return Dis[x] &gt; Dis[y]; }};std::priority_queue&lt;int, std::vector&lt;int&gt;, cmp&gt; pq;int spfa(int s, int t) { for (int i = s; i &lt;= t; ++i) { Dis[i] = INF; } memset(Vis, 0, sizeof Vis); Dis[s] = 0, pq.push(s); while (!pq.empty()) { int x = pq.top(); Vis[x] = 0, pq.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &gt; 0 &amp;&amp; Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Pe[v] = i, Pv[v] = x; if (!Vis[v]) { Vis[v] = 1; pq.push(v); } } } } return Dis[t] &lt; INF;}double cost;int flow;double ai, bi;void mcmf(int s, int t) { cost = flow = 0; while (spfa(s, t)) { int f = INF; for (int i = t; i != s; i = Pv[i]) { f = std::min(f, E[Pe[i]].f); } cost += f * Dis[t]; flow += f; for (int i = t; i != s; i = Pv[i]) { E[Pe[i]].f -= f, E[Pe[i] ^ 1].f += f; } } ai = bi = 0; for (int x = 1; x &lt;= N; ++x) { for (int i = H[x]; i; i = E[i].nxt) { if (E[i].f == 0 &amp;&amp; E[i].v &gt; N) { ai += A[x][E[i].v - N]; bi += B[x][E[i].v - N]; break; } } }}bool check(double lim) { buildGraph(lim); mcmf(S, T); return flow == N &amp;&amp; cost &lt; -eps;}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { scanf(\"%d\", &amp;A[i][j]); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { scanf(\"%d\", &amp;B[i][j]); } } double ans = 0; while (check(ans)) { ans = ai / bi; } printf(\"%.6lf\\n\", ans); return 0;}","link":"/BZOJ-4819/"},{"title":"「BJOI 2018」BZOJ 5293 求和","text":"在一棵有 $n$ 个节点，根节点为 $1$ 的树上进行 $m$ 次询问。 每次查询 $(u,v)$ 之间的简单路径的“ $k$ 次深度和”。 $k$ 次深度和即 $\\sum_{i\\in(u,v)}Depth(i)^k$，$Depth(1)=0$。 询问的结果对 $998244353$ 取模。 $1\\leq n,m\\leq 300000,1\\leq k\\leq 50$ 分析首先注意到没有修改操作，只有查询。 其次注意到 $k$ 很小，$k$ 次方可以预处理。 最后注意到每次查询就是一个 $k$ 次的两段连续区间的求和。 记 $lca$ 为 $(u,v)$ 的最近公共祖先。 那么查询的结果即为 $\\sum_{i=Depth(lca)}^{Depth(u)}i^k+\\sum_{i=Depth(lca)+1}^{Depth(v)}i^k$ 预处理 $F_{i,j} = \\sum_{u=0}^{j}u^i$ 则查询的结果为 $F_{k,Depth(v)}-F_{k,Depth(lca)}+F_{k,Depth(u)}-F_{k,Depth(lca)}+Depth(lca)^k$ 对于 $m$ 组 $(u,v)$ 求LCA，树剖、倍增、Tarjan都可以。 如果选择树剖、倍增，复杂度 $O(n\\times k+m\\times \\log{n})$； 如果选择Tarjan，复杂度 $O(n\\times k+m)$。 实测Tarjan常数较大，运行时间相对更长（可能是写渣了）。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEinline char gc() { return getchar();}template &lt;class T&gt; inline T gt() { register T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') {std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst static int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { register char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-'); register bool f = c == '-'; register T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif}const int MAXN = 300000 + 5;const int MOD = 998244353;std::vector&lt;int&gt; G[MAXN];int maxDep;int Fa[MAXN], Sz[MAXN], Depth[MAXN];int Son[MAXN], Top[MAXN];void dfs1(int x) { Sz[x] = 1; if(x == 1) { Depth[x] = 0; } else { Depth[x] = Depth[Fa[x]] + 1; } maxDep = std::max(maxDep, Depth[x]); rep(i, 0, SZ(G[x])) { int &amp;v = G[x][i]; if(Fa[x] != v) { Fa[v] = x; dfs1(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]] || !Son[x]) { Son[x] = v; } } }}void dfs2(int x, int fa) { Top[x] = fa; if(Son[x]) { dfs2(Son[x], fa); } rep(i, 0, SZ(G[x])) { int &amp;v = G[x][i]; if(v != Fa[x] &amp;&amp; v != Son[x]) { dfs2(v, v); } }}int query(int u, int v) { while(Top[u] ^ Top[v]) { if(Depth[Top[u]] &gt; Depth[Top[v]]) { u = Fa[Top[u]]; } else { v = Fa[Top[v]]; } } return Depth[u] &lt; Depth[v] ? u : v;}std::vector&lt;int&gt; Sum[MAXN];ll poww(ll x, ll t) { ll ans = 1; for(; t; t &gt;&gt;= 1, x = x * x % MOD) { if(t &amp; 1) { ans = ans * x % MOD; } } return ans;}void pre() { rep(i, 1, 51) { Sum[i].push_back(0); rep(j, 1, maxDep + 1) { ll cur = (poww(j, i) + Sum[i].back()) % MOD; Sum[i].push_back(cur); } }}int main() { rep(i, 1, io::gt&lt;int&gt;()) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); G[u].push_back(v); G[v].push_back(u); } dfs1(1); dfs2(1, 1); pre(); rep(i, 0, io::gt&lt;int&gt;()) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(), k = io::gt&lt;int&gt;(); int lca = query(u, v); int &amp;depx = Depth[u], &amp;depy = Depth[v]; int &amp;depl = Depth[lca]; int ans = ((Sum[k][depy] - Sum[k][depl] + Sum[k][depx] - Sum[k][depl] + poww(depl, k)) % MOD + MOD) % MOD; io::pt(ans); } io::fflush(); return 0;}","link":"/BZOJ-5293/"},{"title":"斯坦纳树学习笔记（Steiner Tree）","text":"总论斯坦纳树可以理解为一棵使得指定点集合联通的树，而最小斯坦纳树在联通的基础上要求边权和最小。（是不是有点类似于最小生成树？） 通常通过状压DP+最短路松弛的方式来解决此类问题。 过程具体过程不妨从一个简单问题出发。 无向图 $G$ 上有 $n$ 个点，选择若干个点使得它们包含点集合 $S={a_1,a_2,\\cdots,a_m}$，且 $S$ 联通。选择点 $i$ 的代价为 $A_i$，求最小代价。 设 $F[i][S]$ 表示集合 $S$ 的点被选择且当前选择节点 $i$ 的最小花费，则 $F[i][S]$ 有两种方式转移，一是枚举子集合并，二是集合内部松弛。 第一种： $F[i][S]=\\min{F[i][T]+F[i][S-T]-A[i]}$，其中 $T$ 是 $S$ 的一个子集。 可以通过 for (int x = S; x; x = (x - 1) &amp; S) 的方式枚举 $S$ 的所有子集 $x$，复杂度 $O(3^m)$。 由于外层还要枚举当前集合状态 $S$ 和当前点 $i$，因此总复杂度为 $n\\cdot 6^m$。 第二种：$F[i][S]=\\min{F[j][S]+A[i]}$，其中点 $i,j$ 联通。 在状压DP后，可以将所有更新过的点push进队列跑SPFA或其他最短路算法完成松弛。 总复杂度 $O(n\\cdot 6^m+2^m\\cdot f)$，$f$ 为最短路复杂度。 用途最小斯坦树可以得到给定点集合所有子集的最小花费，可能会作为预处理使用。 例题 【最小斯坦纳树】[WC 2008] BZOJ 2595 游览计划 【最小斯坦纳树+状压DP】[JLOI 2015] BZOJ 4006 管道连接","link":"/Steiner-Tree/"},{"title":"「HEOI 2013」BZOJ 3166 Alo","text":"给定长为 $N$ 的序列 $A[1 \\cdots N]$，定义 $F[i,j]$ 为$A[i \\cdots j]$ 的次大值与区间内另一个数异或的最大值。求 $A$ 所有子区间的 $F$ 最大值。 $1\\leq N\\leq 50000, A_i\\leq 10^9$ 题目链接BZOJ 3166: [Heoi2013]Alo 分析将问题反过来看，其实就是找到每一个数对应的区间，使得它在区间中是次大值，且区间长度最大。 记$L[i],R[i]$ 为 $A[i]$ 左右第一个比它大的数， $LL[i],RR[i]$ 为 $A[i]$ 左右第二个大的数，那么区间为 $[LL[i]+1,R[i]-1]$ 和 $[L[i]+1,RR[i]-1]$。 可以通过在ST表上二分的方法求出 $LL[i],RR[i]$，复杂度 $O(N\\log{N})$。 最后用可持久化Trie求每个区间与 $A[i]$ 的最大异或值，答案为这些值取max，这一步操作的复杂度为 $O(N\\log{max(A_i)})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;const int MAXN = 50000 + 5;const int MAXM = 40;struct Trie { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], cntT;int insert(int pre, int x) { int rt = ++cntT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++cntT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int N, A[MAXN];int L[MAXN], R[MAXN];int Stk[MAXN], top;int LL[MAXN], RR[MAXN];int bSearch(int x) { int l = 1, r = top; int ans = 0; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (A[Stk[m]] &gt; A[x]) { ans = Stk[m]; l = m + 1; } else { r = m - 1; } } return ans;}int F[MAXN][MAXM];void buildST(int n) { for (int i = 1; i &lt;= n; ++i) { F[i][0] = A[i]; } int k = log2(n); for (int j = 1; j &lt;= k; ++j) { for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) { if (F[i][j - 1] &gt; F[i + (1 &lt;&lt; (j - 1))][j - 1]) { F[i][j] = F[i][j - 1]; } else { F[i][j] = F[i + (1 &lt;&lt; (j - 1))][j - 1]; } } }}int queryMax(int l, int r) { int k = log2(r - l + 1); return std::max(F[l][k], F[r - (1 &lt;&lt; k) + 1][k]);}int getL(int i) { int p = L[i], x = A[i]; int l = 1, r = p - 1, ans = 1; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (queryMax(m, p - 1) &gt; x) { ans = m; l = m + 1; } else { r = m - 1; } } return ans;}int getR(int i) { int p = R[i], x = A[i]; int l = p + 1, r = N + 1, ans = N + 1; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (queryMax(p + 1, m) &gt; x) { ans = m; r = m - 1; } else { l = m + 1; } } return ans;}int main() { scanf(\"%d\", &amp;N); Rt[1] = insert(Rt[0], 0); ++N; for (int i = 2; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); Rt[i] = insert(Rt[i - 1], A[i]); } A[1] = A[N + 1] = INT_MAX; Stk[top = 1] = 1; for (int i = 2; i &lt;= N; ++i) { while (A[Stk[top]] &lt;= A[i]) { --top; } L[i] = Stk[top]; Stk[++top] = i; } Stk[top = 1] = N + 1; for (int i = N; i &gt;= 2; --i) { while (A[Stk[top]] &lt;= A[i]) { --top; } R[i] = Stk[top]; Stk[++top] = i; } buildST(N + 1); for (int i = 2; i &lt;= N; ++i) { LL[i] = getL(i); RR[i] = getR(i); } int ans = 0; for (int i = 2; i &lt;= N; ++i) { if (L[i] == 1 &amp;&amp; R[i] == N + 1) { continue; } ans = std::max(ans, query(Rt[LL[i]], Rt[R[i] - 1], A[i])); ans = std::max(ans, query(Rt[L[i]], Rt[RR[i] - 1], A[i])); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-3166/"},{"title":"「USACO2018 OPEN」BZOJ 5281 Talent Show","text":"$N$ 个点各有权值 $W_i$ 和 $T_i$，在其中选择任意多个点，在满足 $\\sum{W_i} \\geq A$ 的条件下求 $\\sum{T_i}/\\sum{W_i}$ 的最大值。 $1\\leq N\\leq 250,1\\leq W\\leq 1000,1\\leq W_i\\leq 10^6,1\\leq T_i\\leq 10^3$ 题库链接BZOJ 5281 分析套路二分答案 $x$，然后背包求在 $\\sum{W_i}\\geq A$ 的情况下判定 $\\sum{T_i-W_i\\times x}\\geq 0$ 是否成立。 由于答案是 $\\times 1000$ 取整，为了避免浮点数运算，可以直接将 $T_i$ 放大 $1000$ 倍。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;const int MAXN = 250 + 5;const int MAXM = 1000 + 5;int N, M;int A[MAXN], B[MAXN];long long F[MAXM];bool check(int a) { memset(F, 0xc2, sizeof F); long long tmp = F[0]; F[0] = 0; for (int i = 1; i &lt;= N; ++i) { for (int j = M; j &gt;= 0; --j) { if (F[j] != tmp) { int v = std::min(M, j + A[i]); F[v] = std::max(F[v], F[j] - (long long)A[i] * a + B[i]); } } } return F[M] &gt;= 0;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;A[i], &amp;B[i]); B[i] *= 1000; } int l = 0, r = 2e8, ans = 0; while (l &lt;= r) { int m = (l + r) / 2; if (check(m)) { ans = m; l = m + 1; } else { r = m - 1; } } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-5281/"},{"title":"最小割树学习笔记（Gomory-Hu Tree）","text":"总论在无向图中，最小割树等价于所有点对间的最小割。 对于任意点对 $(s,t)$，它们之间的最小割为最小割树上 $(s,t)$ 路径间的最小边权值。 过程可以通过求 $n-1$ 次最大流构建出具有 $n$ 个点的无向图 $G$ 的最小割树。 具体步骤如下： 任意选择两点 $s,t$ 求两点间最大流 $f$ 得到最小割隔开的两个集合 最小割树上连接 $(s,t)$，边权为 $f$ 将图恢复成最初形态（还原边权） 递归到这两个新集合中，重复操作1，直到集合中只有 $1$ 个点为止 由于每次集合总数增加 $1$，因此一共做 $n-1$ 次以上流程。 Q &amp; AQ1：如何求最小割隔开的两个集合？ A1：由于最小割上的边一定将流量限制流满了，因此从 $s$ 开始，通过未流满流量限制的边遍历到的且在当前集合中的点为与 $s$ 联通的点集合，剩下的点与 $t$ 联通的点集合。 Q2：用什么算法求最大流啊？会被卡吗？ A2：根据相关法律法规，ISAP和Dinic受到保护，应该不会被卡，EK死就死了。当然你愿意写HLPP也不拦着。 用途可以得到任意点对间的最小割，通常用于预处理。 例题 luogu P4897 【模板】最小割树（Gomory-Hu Tree） 【最小割树】[CQOI 2016] BZOJ 4519 不同的最小割 【最小割树】[ZJOI 2011] BZOJ 2229 最小割","link":"/Gomory-Hu-Tree/"},{"title":"JZOJ 5060 公路建设","text":"有 $n$ 个点， $m$ 条边， $q$ 个询问。每次给定一个区间 $[l_i,r_i]$，求这些边构成的图在保证联通块个数最小的情况下所需最小花费。 $n\\leq 100,m\\leq 100000,q\\leq 15000$ 分析将题意翻译一下就是求区间最小生成树的权值。 假设已知 $[l,m]$ 和 $[m+1,r]$ 的最小生成树，那么 $[l,r]$ 的mst显然是由这两棵mst中的边构成的。 具体地说，在线段树中，通过Kruskal保存子区间mst上的所有边，然后用归并排序合并两个子区间的边，并再做kruskal求出父亲节点的mst上的所有边。查询时按照同样方法合并答案。 复杂度 $O(n\\alpha(n)(m\\log{m}+q\\log{m}))$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 16:40:30 * @LastEditTime: 2019-01-26 17:12:13 * @Source: GDOI2017第二轮模拟day1 * @Problem: JZOJ 5060 公路建设 * @Url: https://jzoj.net/senior/#main/show/5060 */#include &lt;bits/stdc++.h&gt;void open() { freopen(\"highway.in\", \"r\", stdin); freopen(\"highway.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int MAXM = 100000 + 5;int N, M, Q;struct Node { int u, v, w; bool operator &lt; (const Node &amp;x) const { return w &lt; x.w; }} A[MAXM], T[MAXM &lt;&lt; 2][MAXN], Tmp[MAXN &lt;&lt; 1];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Len[MAXM &lt;&lt; 2];int Anc[MAXN];int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) { x = findAnc(x), y = findAnc(y); if (x != y) { Anc[y] = x; return true; } return false;}void pushUp(int x, int l, int r) { int len = std::merge(T[l], T[l] + Len[l], T[r], T[r] + Len[r], Tmp) - Tmp; for (int i = 1; i &lt;= N; ++i) { Anc[i] = i; } Len[x] = 0; for (int i = 0; i &lt; len; ++i) { if (merge(Tmp[i].u, Tmp[i].v)) { T[x][Len[x]++] = Tmp[i]; } }}void build(int rt, int l, int r) { if (l == r) { Len[rt] = 1; T[rt][0] = A[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt, rt &lt;&lt; 1, rt &lt;&lt; 1 | 1);}void query(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { pushUp(0, rt, 0); return ; } int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { query(LT, a, b); } if (m &lt; b) { query(RT, a, b); }}int main() { open(); scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;Q); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;A[i].u, &amp;A[i].v, &amp;A[i].w); } build(1, 1, M); int l, r; while (Q--) { long long sum = 0; scanf(\"%d%d\", &amp;l, &amp;r); Len[0] = 0; query(1, 1, M, l, r); for (int i = 0; i &lt; Len[0]; ++i) { sum += T[0][i].w; } printf(\"%lld\\n\", sum); } return 0;}","link":"/JZOJ-5060/"},{"title":"「BJWC 2018」BZOJ 5148 kakuro","text":"kakuro是一个神奇的数独游戏，大致规则如下： $N\\times M​$ 的网格图中，由一些格子为空格需要填数，一些格子填线索，一些格子什么都不填 线索有两个方向，分别为右和下，线索的值表示该方向连续空格所填数之和 对于任意一个空格，其左边与上边的一定存在一个格子为线 参考下图 游戏规则： 空格中填入正整数。 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。 Apia 给了Rimbaud 一个Kakuro 谜题。心不灵手不巧的Rimbaud 根本不会做Kakuro，所以只在空格里面填上了一些随机的数字，称这个为一个局面，即包含了谜题一开始给出的线索和后面填入的数字。 现在Rimbaud 希望能修改这个局面使得她的答案是一个合法解。这个局面中有些数字(包括一开始的给出线索和后面填入的数字) 是可以修改的。每个数字都有个特定的代价，将这个数字加 $1$ 或者减 $1$ 都得付出这个数字对应的代价。注意对于一组合法解，必须满足游戏规则，也就是空格中填的数字必须是正整数并且满足和的条件，但是不要求不重复。 Rimbaud 希望用最少的代价让这个局面变得合法，如果不可能那么输出-1 。 $3 \\leq n,m \\leq 30$，保证初始局面中的每个数字不超过 $10^6$ ，保证每个数字的代价不超过 $10^6$ 。 分析致谢感谢AloNE的讲解。 正题一个思路就是先做出一个合法解，然后再去修改权值以减少总花费。 那么最简单的合法解，就是每个空格都填 $1$ ，线索填对应格子的个数。 如此保证了每个空格都是正整数，这是一个最小解。 记当前花费为 $Ans$ 。 记某个格子现在的值为 $A(x,y)$ ，原来的值为 $O(x,y)$ ，修改 $1$ 的价格为 $C(x,y)$ 。 那么每个空格和线索只能往大修改，那么有两种情况。 $A(x,y) \\leq O(x,y)$ ，那么当 $A(x,y)$ 最初变大直到 $O(x,y)$ 时，相当于对最开始的修改进行反悔，也就是说花费 $-C(x,y)$；当然对于超出 $O(x,y)$ 的部分继续花费 $C(x,y)$ 。 $A(x,y) \\geq O(x,y)$ ，那么修改继续增加花费 $C(x,y)$ 。 转化成网络流问题，将这些关系抽象成如下的边： 发现对于修改一个空格会对其左边和上边的两个线索产生影响，约束方法很简单，就是流量从其上面的线索流入，从其左边的线索流出，那么保证所有增加的流量都是合法的；也就是说空格本质就是一条连接横向和竖向线索的边； 根据上面的建模方法，$S$ 连接所有竖向线索，费用为 $C(x,y)$ ，流量不限； 所有横向线索连接 $T$ ，费用为 $C(x,y)$ ，流量不限； 对于所有空格，如果 $A(x,y) \\leq O(x,y)$ ，连接费用为 $-C(x,y)$ 流量为 $O(x,y) - A(x,y)$ ，意为对最初的修改进行反悔；（对应的两个线索之间连边） 对于所有空格，连接费用为 $C(x,y)$ ，流量不限的边，因为每个格子都可以无限增大。 跑最小费用可行流，当前费用 $Cost \\geq 0$ 时结束。 得到最小费用 $C$ ，那么最终结果 $Ans + C$ 。 那么如何判断无解的情况？ 无解也就是说修改了不能修改的边。 那么将不能修改的边的费用置为 $INF$ ，跑完最小费用可行流之后检查残余与网络是否存在费用为 $INF$ 的反向边流量不为 $0$ 或者费用为 $-INF$ 的边流量不为 $0$ 。 如果出现这种情况，说明了必须修改不能修改的格子权值以满足流量平衡，输出 -1 即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 30 + 5;const int INF = 1e9 + 7;namespace mcf {const int MAXN = ::MAXN * ::MAXN * 4;const int MAXM = MAXN;struct Edge { int v, c, f, nxt;} E[MAXM &lt;&lt; 1];int S, T;ll C, F, Dis[MAXN];int H[MAXN], cntE;int Lp[MAXN], Le[MAXN];void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE;}bool spfa() { static std::bitset&lt;MAXN&gt; Inq; static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if (!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] &lt; 0;}void mcf() { while (spfa()) { int f = INF; for (int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } C += f * Dis[T]; F += f; for (int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } }}void init() { memset(H, -1, sizeof H); cntE = -1; C = F = 0;}bool check() { for (int i = 0; i &lt;= cntE; i += 2) { if (E[i].c == INF &amp;&amp; E[i ^ 1].f &gt; 0) { return false; } if (E[i].c == -INF &amp;&amp; E[i].f &gt; 0) { return false; } } return true;}}int N, M;int Type[MAXN][MAXN];int Column[MAXN][MAXN], Line[MAXN][MAXN], Ori[MAXN][MAXN];int ChangeC[MAXN][MAXN], ChangeL[MAXN][MAXN], ChangeO[MAXN][MAXN];int IdC[MAXN][MAXN], IdL[MAXN][MAXN];int Left[MAXN][MAXN], Up[MAXN][MAXN];int AfterC[MAXN][MAXN], AfterL[MAXN][MAXN], AfterO[MAXN][MAXN];int main() { mcf::init(); int cnt = 0; N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { rep(j, 1, M + 1) { Type[i][j] = io::gt&lt;int&gt;(); } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { Column[i][j] = io::gt&lt;int&gt;(); IdC[i][j] = ++cnt; } if (Type[i][j] == 2 || Type[i][j] == 3) { Line[i][j] = io::gt&lt;int&gt;(); IdL[i][j] = ++cnt; } if (Type[i][j] == 4) { Ori[i][j] = io::gt&lt;int&gt;(); } } } mcf::S = 0, mcf::T = cnt + 1; rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { ChangeC[i][j] = io::gt&lt;int&gt;(); if (ChangeC[i][j] == -1) { ChangeC[i][j] = INF; } } if (Type[i][j] == 2 || Type[i][j] == 3) { ChangeL[i][j] = io::gt&lt;int&gt;(); if (ChangeL[i][j] == -1) { ChangeL[i][j] = INF; } } if (Type[i][j] == 4) { ChangeO[i][j] = io::gt&lt;int&gt;(); if (ChangeO[i][j] == -1) { ChangeO[i][j] = INF; } } } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { int k = i + 1; while (k &lt;= N &amp;&amp; Type[k][j] == 4) { Up[k++][j] = IdC[i][j]; } AfterC[i][j] = k - i - 1; mcf::C += 1ll * ChangeC[i][j] * std::abs(AfterC[i][j] - Column[i][j]); } if (Type[i][j] == 2 || Type[i][j] == 3) { int k = j + 1; while (k &lt;= M &amp;&amp; Type[i][k] == 4) { Left[i][k++] = IdL[i][j]; } AfterL[i][j] = k - j - 1; mcf::C += 1ll * ChangeL[i][j] * std::abs(AfterL[i][j] - Line[i][j]); } if (Type[i][j] == 4) { AfterO[i][j] = 1; mcf::C += 1ll * ChangeO[i][j] * std::abs(AfterO[i][j] - Ori[i][j]); } } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { if (AfterC[i][j] &lt; Column[i][j]) { mcf::addEdge(mcf::S, IdC[i][j], Column[i][j] - AfterC[i][j], -ChangeC[i][j]); } mcf::addEdge(mcf::S, IdC[i][j], INF, ChangeC[i][j]); } if (Type[i][j] == 2 || Type[i][j] == 3) { if (AfterL[i][j] &lt; Line[i][j]) { mcf::addEdge(IdL[i][j], mcf::T, Line[i][j] - AfterL[i][j], -ChangeL[i][j]); } mcf::addEdge(IdL[i][j], mcf::T, INF, ChangeL[i][j]); } if (Type[i][j] == 4) { if (AfterO[i][j] &lt; Ori[i][j]) { mcf::addEdge(Up[i][j], Left[i][j], Ori[i][j] - AfterO[i][j], -ChangeO[i][j]); } mcf::addEdge(Up[i][j], Left[i][j], INF, ChangeO[i][j]); } } } mcf::mcf(); if (!mcf::check()) { printf(\"-1\\n\"); } else { printf(\"%lld\\n\", mcf::C); } return 0;}","link":"/BZOJ-5148/"},{"title":"BZOJ 3261 最大异或和","text":"开始给定一个长为 $N$ 的序列 $A[1\\cdots N]$，有 $M$ 个操作。在 $A$ 的末尾插入 $x$；或者给定 $x,l,r$，查询 $max(x\\oplus A[p]\\oplus\\cdots\\oplus A[N])$，其中$p\\in[l,r]$，$N$为当前序列长度。 $N\\leq 300000,A[i]\\leq 10^7$ 题目链接BZOJ 3261 分析维护前缀异或和，令$S[i]=A[1]\\oplus\\dots\\oplus A[i]$，问题转化为查询 $S[N]\\oplus S[p-1]\\oplus x$ 的最大值，其中 $S[N]$ 和 $x$ 都是已知的。 由于是区间问题，可以用可持久化Trie树维护。对于每个新插入的数在01Trie树新建一条链，并将链上所有点的状态+1。通过权值相减来判断区间内是否存在该点，剩下的就是常规01Tire树求异或最大值的操作。 需要注意的一个细节，由于存在插入操作，因此序列中的元素个数最大可能为 $N+M$，需要开两倍空间。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;const int MAXN = 600000 + 5;const int MAXM = 50;struct Node { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], cntT;int N, M;int insert(int pre, int x) { int rt = ++cntT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++cntT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); int cur = 0, x, l, r; char opt[10]; ++N; Rt[1] = insert(Rt[0], 0); for (int i = 2; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); cur ^= x; Rt[i] = insert(Rt[i - 1], cur); } for (int i = 1; i &lt;= M; ++i) { scanf(\"%s\", opt); if (opt[0] == 'A') { scanf(\"%d\", &amp;x); cur ^= x; ++N; Rt[N] = insert(Rt[N - 1], cur); } else { scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); printf(\"%d\\n\", query(Rt[l - 1], Rt[r], x ^ cur)); } } return 0;}","link":"/BZOJ-3261/"}],"tags":[{"name":"差分约束","slug":"差分约束","link":"/tags/差分约束/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"最小割树","slug":"最小割树","link":"/tags/最小割树/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"费用流","slug":"费用流","link":"/tags/费用流/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"树形DP","slug":"树形DP","link":"/tags/树形DP/"},{"name":"斯坦纳树","slug":"斯坦纳树","link":"/tags/斯坦纳树/"},{"name":"最小割","slug":"最小割","link":"/tags/最小割/"},{"name":"分数规划","slug":"分数规划","link":"/tags/分数规划/"},{"name":"状压DP","slug":"状压DP","link":"/tags/状压DP/"},{"name":"字典树","slug":"字典树","link":"/tags/字典树/"},{"name":"前后缀","slug":"前后缀","link":"/tags/前后缀/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"Pruefer","slug":"Pruefer","link":"/tags/Pruefer/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"可持久化Trie","slug":"可持久化Trie","link":"/tags/可持久化Trie/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"ST表","slug":"ST表","link":"/tags/ST表/"},{"name":"背包","slug":"背包","link":"/tags/背包/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"}],"categories":[{"name":"BZOJ","slug":"BZOJ","link":"/categories/BZOJ/"},{"name":"51nod","slug":"51nod","link":"/categories/51nod/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/学习笔记/"},{"name":"JZOJ","slug":"JZOJ","link":"/categories/JZOJ/"}]}