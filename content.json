{"pages":[{"title":"record","text":"OJ 每周刷题记录02.11 - 02.17 BZOJ 3894 文理分科：二元关系 BZOJ 1497 最大获利：最大权闭合子图 BZOJ 1312 Neerc2006 Hard Life：最大密度子图 BZOJ 1001 狼抓兔子：平面图最大流转对偶图最短路 BZOJ 1003 物流运输：最短路+DP BZOJ 1002 轮状病毒：矩阵树定理，高精度","link":"/record/index.html"},{"title":"关于我","text":"高二Oier，来自北京。 曾获NOIP2016普及组三等奖，NOIP2017/2018提高组一等奖，WC2019铜牌。","link":"/about/index.html"}],"posts":[{"title":"51nod 1601 完全图的最小生成树计数","text":"有 $n$ 个点，每个点有点权 $a_i$，点 $u,v$ 之间的边边权为 $a_u \\oplus a_v$。求该完全图的最小生成树的权值与方案数。 $n\\leq 10^5,0\\leq a_i&lt; 2^{30}$ 分析从边权为点xor得到，想到可以对点权建立Trie树。 每次合并两子树mst的权值，并加入两子树中节点可以xor得到的最小值作为连接这两棵子树的最小边，自下而上得到整棵Trie的mst的值。 根据Cayley公式，如果存在有 $a(a&gt;2)$ 个相同权值的点时，生成树的方案数为 $a^{a-2}$。每次合并两子树时对方案数做乘法原理即可得到最终的方案数。 复杂度 $O(n\\log{a_i})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 22:59:31 * @LastEditTime: 2019-01-26 23:41:49 * @Source: 51nod * @Problem: 1601 完全图的最小生成树计数 * @Url: https://www.51nod.com/Challenge/Problem.html#!#problemId=1601 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1e5 + 5;const int MOD = 1e9 + 7;int N;int Ch[MAXN &lt;&lt; 5][2], Num[MAXN &lt;&lt; 5], cnt = 1;long long sum, num = 1;void insert(int val) { int x = 1; for (int i = 29; i &gt;= 0; --i) { int d = (val &gt;&gt; i) &amp; 1; if (!Ch[x][d]) { Ch[x][d] = ++cnt; } x = Ch[x][d]; } ++Num[x];}long long poww(long long x, long long t) { long long ans = 1; for (; t; t &gt;&gt;= 1) { if (t &amp; 1) { ans = ans * x % MOD; } x = x * x % MOD; } return ans;}long long min, tmp;void getMin(int x, int y, int d, int v = 0) { if (d &lt; 0) { if (v &lt; min) { min = v; tmp = (long long)Num[x] * Num[y] % MOD; } else if (v == min) { tmp = (tmp + (long long)Num[x] * Num[y]) % MOD; } return; } if (Ch[x][0] &amp;&amp; Ch[y][0]) { getMin(Ch[x][0], Ch[y][0], d - 1, v); if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } } else if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } else { if (Ch[x][0]) { getMin(Ch[x][0], Ch[y][1], d - 1, v + (1 &lt;&lt; d)); } if (Ch[x][1]) { getMin(Ch[x][1], Ch[y][0], d - 1, v + (1 &lt;&lt; d)); } }}void cal(int x, int d) { if (d &lt; 0) { if (Num[x] &gt; 1) { num = num * poww(Num[x], Num[x] - 2); } return; } if (!Ch[x][0]) { cal(Ch[x][1], d - 1); } else if (!Ch[x][1]) { cal(Ch[x][0], d - 1); } else { cal(Ch[x][0], d - 1); cal(Ch[x][1], d - 1); min = 1 &lt;&lt; 30; tmp = 0; getMin(Ch[x][0], Ch[x][1], d - 1, 0); sum = sum + (1 &lt;&lt; d) + min; num = (num * tmp) % MOD; }}int main() { scanf(\"%d\", &amp;N); int x; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); insert(x); } cal(1, 29); printf(\"%lld\\n%lld\\n\", sum, num); return 0;}","link":"/51nod-1601/"},{"title":"「FJOI 2007」BZOJ 1002 轮状病毒","text":"求 $N$ 轮状病毒的不同状态数。 $N\\leq 100$ 分析发现中间的点度数为 $N$，其他点度数为 $3$，用矩阵树定理解即可。 也可以暴力打表找规律，记 $f(i)$ 为 $i$ 轮状病毒的状态数，递推式为 $f(i)=3\\cdot f(i-1)-f(i-2)+2$。 python打表或者写高精度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* * @Author: Skqliao * @Date: 2019-02-16 20:21:57 * @LastEditTime: 2019-02-16 21:10:05 * @Source: FJOI 2007 * @Problem: 1002: [FJOI2007]轮状病毒 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1002 */#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;int N;struct Int { static const int MAXN = 10000 + 5; int len, S[MAXN]; Int operator=(int x) { memset(S, 0, sizeof S); len = 0; while (x) { S[len++] = x % 10; x /= 10; } return *this; } Int operator+(const Int &amp;x) { Int c; c.len = std::max(len, x.len); memset(c.S, 0, sizeof c.S); for (int i = 0; i &lt; c.len; ++i) { c.S[i] += S[i] + x.S[i]; c.S[i + 1] += c.S[i] / 10; c.S[i] %= 10; } if (c.S[c.len]) ++c.len; return c; } Int operator-(const Int &amp;x) { Int c; c.len = len; memset(c.S, 0, sizeof c.S); for (int i = 0; i &lt; c.len; ++i) { c.S[i] = S[i] - x.S[i]; while (c.S[i] &lt; 0) { c.S[i] += 10; S[i + 1]--; } } while (!c.S[c.len - 1]) --c.len; return c; } Int operator*(const Int &amp;x) { Int c; c.len = len + x.len - 1; memset(c.S, 0, sizeof c.S); for (int i = 0; i &lt; len; ++i) { for (int j = 0; j &lt; x.len; ++j) { c.S[i + j] += S[i] * x.S[j]; } } for (int i = 0; i &lt; c.len; ++i) { c.S[i + 1] += c.S[i] / 10; c.S[i] %= 10; } if (c.S[c.len]) ++c.len; return c; } void print() { for (int i = len - 1; i &gt;= 0; --i) { printf(\"%d\", S[i]); } }} F[MAXN], x, y;int main() { scanf(\"%d\", &amp;N); x = 2; y = 3; F[1] = 1; F[2] = 5; for (int i = 3; i &lt;= N; ++i) { F[i] = y * F[i - 1] - F[i - 2] + x; } F[N].print(); return 0;}","link":"/BZOJ-1002/"},{"title":"「ICPC-Beijing 2006」BZOJ 1001 狼抓兔子","text":"在网格图中，任意点 $(x,y)$ 都有 $(x,y)\\rightarrow (x+1,y)$ / $(x,y)\\rightarrow (x,y+1)$ / $(x,y)\\rightarrow (x+1,y+1)$ 这三种边。起点 $S$ 位于 $(1,1)$，终点 $T$ 位于 $(n,m)$。求 $S-T$ 最小割。 $n,m\\leq 1000$ 分析如果根据最大流最小割定理，通过求 $S-T$ 最大流得到最小割的话，是行不通的，因为该图有最多 $1000^2$ 个点。 但是本题特殊的一点在于这是一个平面图，可以将其转化为对偶图，通过求对偶图上的最短路得到原图的最小割。 平面图转对偶图的流程如下： 用一条不与其他任何边相交的新边连接 $S,T$ ，构成一个新面 将平面图的每个面对应为对偶图的点，第一步构造的新面和无边界的面作为新图的起点 $s$ 和终点 $t$ 如果原图中边 $e$ 同时属于两个面 $s1,s2$，则在新图中 $s1$ 和 $s2$ 之间连一条权值与 $e$ 相同的无向边 删去 $s,t$ 之间的边 则 $s-t$ 最短路对应 $S-T$ 最大流。 复杂度 $O(nm\\lg{nm})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* * @Author: Skqliao * @Date: 2019-02-13 12:36:43 * @LastEditTime: 2019-02-13 18:20:57 * @Source: BJOI 2006 * @Problem: 1001: [BeiJing2006]狼抓兔子 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1001 */#include &lt;bits/stdc++.h&gt;const int MAXN = 2 * 1000 * 1000 + 5;const int MAXM = MAXN * 3;struct Edge { int v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, w, H[v]}; H[v] = cntE;}int N, M;int S, T;typedef std::pair&lt;int, int&gt; pii;int Dis[MAXN];int dijkstra() { static std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt; &gt; Pq; memset(Dis, 0x3f, sizeof Dis); Dis[S] = 0; Pq.push(std::make_pair(Dis[S], S)); while (!Pq.empty()) { while (!Pq.empty() &amp;&amp; Dis[Pq.top().second] &lt; Pq.top().first) Pq.pop(); if (Pq.empty()) break; int x = Pq.top().second; Pq.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Pq.push(std::make_pair(Dis[v], v)); } } } return Dis[T];}int main() { int x; scanf(\"%d%d\", &amp;N, &amp;M); if (N == 1 || M == 1) { int ans = INT_MAX; while (~scanf(\"%d\", &amp;x)) ans = std::min(ans, x); printf(\"%d\\n\", ans); } else { N--, M--; S = 0, T = N * M * 2 + 1; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d\", &amp;x); addEdge(i, T, x); } for (int i = 2; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); addEdge((2 * i - 3) * M + j, (2 * i - 2) * M + j, x); } } for (int i = 1; i &lt;= M; ++i) { scanf(\"%d\", &amp;x); addEdge((2 * N - 1) * M + i, S, x); } for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); addEdge((2 * i - 1) * M + 1, S, x); for (int j = 1; j &lt;= M - 1; ++j) { scanf(\"%d\", &amp;x); addEdge((2 * i - 2) * M + j, (2 * i - 2) * M + j + M + 1, x); } scanf(\"%d\", &amp;x); addEdge((2 * i - 1) * M, T, x); } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); addEdge((2 * i - 2) * M + j, (2 * i - 2) * M + j + M, x); } } printf(\"%d\\n\", dijkstra()); } return 0;}","link":"/BZOJ-1001/"},{"title":"「ZJOI 2008」BZOJ 1036 树的统计","text":"一棵有 $N$ 个节点的树，每个节点有初始权值 $W_i$ 。共有 $M$ 次操作，分别为： 查询节点 $(u,v)$ 间所有节点的权值和 查询节点 $(u,v)$ 间所有节点的最大权值 修改 $W_u$ 为 $x$ $1\\leq N\\leq30000,0\\leq M\\leq 200000$，中途操作中保证每个节点的权值 $w$ 在$-30000$到$30000$之间。 分析又是一道树链剖分模板题… 树剖后，线段树维护区间最大值和区间和。 复杂度 $O(N+M\\log^2{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;#define ONLINE_JUDGEnamespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace iostruct Graph { static const int MAXN = 30000 + 5; struct Edge { int v, nxt; } E[MAXN &lt;&lt; 1]; int N, R; int H[MAXN], cntE; int Depth[MAXN], Fa[MAXN], Son[MAXN], Sz[MAXN]; int Dfn[MAXN], Top[MAXN], cntD; int W[MAXN], Wp[MAXN]; void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; } void dfs(int x) { Son[x] = 0, Sz[x] = 1; for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { Fa[v] = x; Depth[v] = Depth[x] + 1; dfs(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } } } void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; W[cntD] = Wp[x]; if(Son[x]) { dfs2(Son[x], top); } for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Son[x] &amp;&amp; v != Fa[x]) { dfs2(v, v); } } }#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, r int Sum[MAXN &lt;&lt; 2], Max[MAXN &lt;&lt; 2]; void pushUp(int rt) { Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1]; Max[rt] = std::max(Max[rt &lt;&lt; 1], Max[rt &lt;&lt; 1 | 1]); } void build(int rt, int l, int r) { if(l == r) { Max[rt] = Sum[rt] = W[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt); } void modify(int rt, int l, int r, int p, int x) { if(l == r) { Sum[rt] = Max[rt] = x; return ; } int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { modify(LT, p, x); } else { modify(RT, p, x); } pushUp(rt); } int querySum(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Sum[rt]; } int m = (l + r) &gt;&gt; 1; int res = 0; if(a &lt;= m) { res += querySum(LT, a, b); } if(m &lt; b) { res += querySum(RT, a, b); } return res; } int queryMax(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Max[rt]; } int m = (l + r) &gt;&gt; 1; int res = -INT_MAX; if(a &lt;= m) { res = std::max(res, queryMax(LT, a, b)); } if(m &lt; b) { res = std::max(res, queryMax(RT, a, b)); } return res; } void change(int u, int x) { modify(1, 1, N, Dfn[u], x); } int queryPathS(int u, int v) { int res = 0; int tu = Top[u], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } res += querySum(1, 1, N, Dfn[tv], Dfn[v]); v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } res += querySum(1, 1, N, Dfn[u], Dfn[v]); return res; } int queryPathM(int u, int v) { int res = -INT_MAX; int tu = Top[u], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } res = std::max(res, queryMax(1, 1, N, Dfn[tv], Dfn[v])); v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } res = std::max(res, queryMax(1, 1, N, Dfn[u], Dfn[v])); return res; } void prepare() { dfs(R); dfs2(R, R); build(1, 1, N); }} G;int main() { G.N = io::gt&lt;int&gt;(); G.R = 1; rep(i, 1, G.N) { G.addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } rep(i, 1, G.N + 1) { G.Wp[i] = io::gt&lt;int&gt;(); } G.prepare(); int M = io::gt&lt;int&gt;(); rep(i, 0, M) { char ch = io::gc(); while(!isalpha(ch)) { ch = io::gc(); } if(ch == 'Q') { ch = io::gc(); int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); if(ch == 'S') { io::pt(G.queryPathS(u, v)); } else { io::pt(G.queryPathM(u, v)); } } else { int u = io::gt&lt;int&gt;(), x = io::gt&lt;int&gt;(); G.change(u, x); } } io::flush(); return 0;}","link":"/BZOJ-1036/"},{"title":"「JSOI 2008」BZOJ 1012 最大数","text":"维护一个数列，具有 $M$ 个以下两种操作： 查询并输出当前数列中末尾L个数中的最大的数 将 $n$ 加上最近一次查询操作的答案，对 $D$ 取模后，插入到数列的末尾 $M \\leq 200000$ 分析对 $[1…M]$ 建线段树，记录当前序列末尾的下标。 那么问题就变成了线段树区间查询最大值，单点修改（开始默认每个元素都是 $0$）。 值得注意的一点是，对 $D​$ 取模并不意味着一定要变成正数。例如 $D=5​$，上次结果为 $1​$，$n=-10​$ ，那么实际插入的数就是 $-4​$ ，而不是 $1​$ ，这一点题目并没有明确。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 200000 + 5;#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint N = 1, M, P;int Max[MAXN &lt;&lt; 2];void pushUp(int rt) { Max[rt] = std::max(Max[rt &lt;&lt; 1], Max[rt &lt;&lt; 1 | 1]);}void modify(int rt, int l, int r, int p, int x) { if (l == r) { Max[rt] = x; return ; } int m = (l + r) &gt;&gt; 1; if (p &lt;= m) { modify(LT, p, x); } else { modify(RT, p, x); } pushUp(rt);}int queryMax(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return Max[rt]; } int m = (l + r) &gt;&gt; 1; int res = 0; if (a &lt;= m) { res = std::max(res, queryMax(LT, a, b)); } if (m &lt; b) { res = std::max(res, queryMax(RT, a, b)); } return res;}int main() { int res = 0; M = io::gt&lt;int&gt;(), P = io::gt&lt;int&gt;(); while (M--) { char opt = io::gc(); while (!isalpha(opt)) { opt = io::gc(); } int x = io::gt&lt;int&gt;(); if (opt == 'Q') { io::pt(res = queryMax(1, 1, MAXN, N - x, N - 1)); } else { modify(1, 1, MAXN, N++, (x + res) % P); } } io::flush(); return 0;}","link":"/BZOJ-1012/"},{"title":"「HAOI 2008」BZOJ 1054 移动玩具","text":"给定两个 $4\\times 4$ 的01矩阵，每次可以交换一对相邻的 $0,1$，求前一个矩阵转移到后一个矩阵的最少步数。 分析BFS+Hash。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * @Author: Skqliao * @Source: HAOI 2008 * @Problem: 1054: [HAOI2008]移动玩具 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1054 * @Date: 2019-02-18 22:53:30 * @LastEditTime: 2019-02-21 15:15:00 */#include &lt;bits/stdc++.h&gt;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};struct Node { std::string code; int step;};std::string s, t, x;std::multiset&lt;std::string&gt; Vis;std::queue&lt;Node&gt; Que;int bfs() { Que.push((Node) {s, 0}); while (!Que.empty()) { Node a = Que.front(); Que.pop(); for (int p = 0; p &lt; 16; ++p) { if (a.code[p] == '0') continue; int i = p / 4, j = p % 4; for (int k = 0; k &lt; 4; ++k) { int x = i + Dicx[k], y = j + Dicy[k]; if (x &lt; 0 || y &lt; 0 || x &gt; 3 || y &gt; 3) continue; if (a.code[x * 4 + y] == '1') continue; std::string b = a.code; b[p] = '0'; b[x * 4 + y] = '1'; if (Vis.count(b)) continue; Vis.insert(b); if (t == b) return a.step + 1; Que.push((Node) {b, a.step + 1}); } } }}int main() { for (int i = 0; i &lt; 4; ++i) { std::cin &gt;&gt; x; s += x; } for (int i = 0; i &lt; 4; ++i) { std::cin &gt;&gt; x; t += x; } if (s == t) std::cout &lt;&lt; 0; else std::cout &lt;&lt; bfs(); return 0;}","link":"/BZOJ-1054/"},{"title":"「HAOI 2007」BZOJ1053 反素数","text":"求 $[1,N]​$ 中最大的反素数。 记 $g(x)$ 为 $x$ 的约束个数，反素数即满足 $y \\in [1,x-1], g(x) &gt; g(y)$ 。 $1\\leq N\\leq 2000000000$ 分析根据约数个数定理。设 $x = \\prod{A_{i}^{P_i}}$，则 $x$ 的约数个数为 $\\prod{(P_i+1)}$ 。 假设 $A_i$ 单调递增，那么 $P_i$ 一定单调递减。 反证法：若 $x$ 分解后，存在 $A_i &lt; A_j, P_i \\leq P_j$ ，那么互换 $P_i, P_j$ 一定更优。 根据 $N$ 的数据范围，发现前 $11$ 个素数的乘积就已经超过 $2e9$ ，因此最多枚举 $10$ 个素数 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;int Pri[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59};ll ans, N;int res;void dfs(int x, ll cur, int num, int last) { if(cur * Pri[x] &gt; N) { if(num &gt; res || num == res &amp;&amp; ans &gt; cur) { res = num; ans = cur; } return ; } ll mul = Pri[x]; rep(i, 1, last + 1) { if(cur * mul &gt; N) { break; } dfs(x + 1, cur * mul, num * (i + 1), i); mul *= Pri[x]; }}int main() { scanf(\"%lld\", &amp;N); dfs(0, 1, 1, 64); printf(\"%lld\\n\", ans); return 0;}","link":"/BZOJ-1053/"},{"title":"「HNOI 2004」BZOJ 1212 L语言","text":"有 $N$ 个字符串作为字典，一个字符串能被该字典理解当且仅当它可以被拆成若干个字串，每个字串都是字典中的单词。 现每次查询某个字符串 $S_i$ 能被该字典理解的最长前缀大小，查询 $M$ 次。 $1\\leq N,M\\leq 20$，单词长度不超过 $10$ ，$S_i$ 的长度不超过 $1M$。 分析看到多个字符串做字典查询，想到Trie树。 Trie树能够进行字符串的最长前缀匹配，很明显与这道题关系密切。 记 $F_i = 1$ 当 $S[0…i]$ 能被若干个单词拼接而成，如果 $S[i+1…k]$ 也能被若干个单词拼接，那么 $F_k=1$ 。 因此在进行匹配过程中，如果中间恰好为某个单词的结束，那么置对应位置的 $F$ 值为 $1$ 。 进行以 $S[i]$ 为首的字符串匹配的条件为 $F_{i-1}=1$ （ $S[0]$ 除外）。 那么答案满足即为满足 $F_i=1$ 的最大值。 复杂度不好分析，为 $O(\\sum{len})$ 级别。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 1000 + 5;const int MAXM = 1024 * 1024 + 5;struct Node { static const int MAX_SIZE = 26; bool flag; int Nxt[MAX_SIZE];}Pool[MAXN];int cntP = -1, root;int newNode() { Node &amp;x = Pool[++cntP]; x.flag = 0; memset(x.Nxt, -1, sizeof x.Nxt); return cntP;}void insert(int rt, char *S) { while(*S) { int id = *S++ - 'a'; if(!~Pool[rt].Nxt[id]) { Pool[rt].Nxt[id] = newNode(); } rt = Pool[rt].Nxt[id]; } Pool[rt].flag = true;}void match(int rt, char *S, int st, int F[]) { char *s = S + st; while(*s) { int id = *s++ - 'a'; if(!~Pool[rt].Nxt[id]) { return ; } rt = Pool[rt].Nxt[id]; if(Pool[rt].flag) { F[s - S] = 1; } }}int solve(char *S) { static int F[MAXM]; memset(F, 0, sizeof F); match(root, S, 0, F); F[0] = 1; rep(i, 1, strlen(S)) { if(F[i]) { match(root, S, i, F); } } rof(i, strlen(S) + 1, 0) { if(F[i]) { return i; } }}int main() { int n, m; root = newNode(); char Str[MAXM]; scanf(\"%d%d\", &amp;n, &amp;m); rep(i, 0, n) { scanf(\"%s\", Str); insert(root, Str); } rep(i, 0, m) { scanf(\"%s\", Str); printf(\"%d\\n\", solve(Str)); } return 0;}","link":"/BZOJ-1212/"},{"title":"「SCOI 2007」BZOJ 1067 降雨量","text":"已知 $N$ 个年份 $Y_i$ 的降雨量 $R_i$。 现有 $M$ 个询问。给定年份 $X,Y$ ，判断“X年是自Y年以来降雨量最多的”的正确性。 该语句正确的当且仅当 $R_X\\leq R_Y$ 且对于所有 $Y&lt;Z&lt;X$，满足 $R_Z&lt;R_X$ 。 如果判断语句正确，输出true；如果可能正确，输出maybe；如果一定错误输出false。 $1\\leq N\\leq 50000, 1\\leq M\\leq 10000, -10^9\\leq Y_i\\leq 10^9 , 1\\leq R_i\\leq 10^9$ 分析比较细节的题，听取WA声一片后改起来很烦… 思路其实很简单，就是找到 $X,Y$ 年对应的降水量和 $(X,Y)$ 年间降水量的最大值进行一番比较。 下面分析各种情况对应的结果是什么。 如果 $[X,Y]$ 中所有年份的降水量信息已知。那么当 $R_Y\\leq R_X$ 且 $MAX(X+1,Y-1) &lt; R_Y$ 时，该语句是true，反之则是false。（其中 $MAX(L,R)$ 为 $[L,R]$ 年间已知降水量的最大值） 如果 $X,Y$ 降水量已知。那么当 $R_Y\\leq R_X $ 且 $MAX(X+1,Y-1) &lt; R_Y$ 时，该语句是maybe，反之则是false。 如果 $X,Y$ 已知其一 $Z$ 年的降水量。那么当 $MAX(X+1,Y-1) &lt; R_Z$ 时，该语句是maybe，反之则是false。 如果 $X,Y$ 的降水量皆未知，则该语句是maybe。 由于没有修改操作，因此用Sparse Table来查询区间最大值。 至于如何判断 $X,Y$ 是否降水量已知，可以直接在 $Y[1…N]$ 中二分寻找，复杂度 $O(\\log{N})$； 判断是否 $[X,Y]$ 中所有年份降水量已知，直接检查 $Y-X=P_Y-P_X$ 。（其中 $P_i$ 为 $i$ 在 $Y[1…N]$ 中的下标） 需要特别注意的一点，便是当 $P_Y=P_X+1$ 时， $[X+1,Y-1]\\in \\empty$ 。查询该区间时应该直接返回一个极小值或者单独判断。不然只有稳稳50分…. 复杂度 $O((N+M)\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 50000 + 5;int A[MAXN], B[MAXN];int F[MAXN][20], Log[MAXN], Pow[20];void buildST(int n) { rep(i, 1, n + 1) { F[i][0] = B[i]; } rep(i, 2, n + 1) { Log[i] = Log[i &gt;&gt; 1] + 1; } int k = log2(n); Pow[0] = 1; rep(i, 1, k + 1) { Pow[i] = Pow[i - 1] &lt;&lt; 1; } rep(j, 1, k + 1) { rof(i, n + 1, 1) { if (i + Pow[j - 1] &lt;= n) { F[i][j] = std::max(F[i][j - 1], F[i + Pow[j - 1]][j - 1]); } } } return ;}int queryMax(int l, int r) { if(l &gt; r) { return -1; } int k = Log[r - l + 1]; return std::max(F[l][k], F[r - Pow[k] + 1][k]);}int main() { int N = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { A[i] = io::gt&lt;int&gt;(); B[i] = io::gt&lt;int&gt;(); } buildST(N); int M = io::gt&lt;int&gt;(); while (M--) { int x = io::gt&lt;int&gt;(), y = io::gt&lt;int&gt;(); int p1 = std::lower_bound(A + 1, A + N + 1, x) - A; int p2 = std::lower_bound(A + 1, A + N + 1, y) - A; if (A[p1] == x &amp;&amp; A[p2] == y &amp;&amp; p2 - p1 == y - x) { int mx = queryMax(p1 + 1, p2 - 1); if (B[p2] &lt;= B[p1] &amp;&amp; B[p2] &gt; mx) { puts(\"true\"); } else { puts(\"false\"); } } else { if (A[p1] != x &amp;&amp; A[p2] != y) { puts(\"maybe\"); } else if (A[p1] == x &amp;&amp; A[p2] != y) { int mx = queryMax(p1 + 1, p2 - 1); if (mx &lt; B[p1]) { puts(\"maybe\"); } else { puts(\"false\"); } } else if (A[p1] != x &amp;&amp; A[p2] == y) { int mx = queryMax(p1, p2 - 1); if (mx &lt; B[p2]) { puts(\"maybe\"); } else { puts(\"false\"); } } else { int mx = queryMax(p1 + 1, p2 - 1); if (mx &lt; B[p2] &amp;&amp; B[p2] &lt;= B[p1]) { puts(\"maybe\"); } else { puts(\"false\"); } } } } return 0;}","link":"/BZOJ-1067/"},{"title":"BZOJ 1312 Neerc2006 Hard Life","text":"无向图 $G$ 有 $n$ 个点 $m$ 条边，对于任意子图 $G’\\in G$，定义它的权值为 $|E|/|V|$，其中 $|E|,|V|$ 分别为子图的边数和点数。求在最大化子图权值的条件下，子图点数的最大值。 $n\\leq 100,m\\leq 1000$ 分析如果将 $|E|,|V|$ 拓展为边权和与点权和，那么最大化子图 $|E|/|V|$ 即求最大密度子图。而本题只是边权点权皆为 $1$ 的特殊情况。 对于这类问题，可采用分数规划+最小割来解决。 首先二分 $k=|E|/|V|$，则 $|E| = k\\cdot |V|$。如果两个点被选择，则可以获得这条边的权值，由此问题可以转化为求最大权闭合子图。 将每条边 $(u_i,v_i)$ 抽象为新点 $A_i$，连接 $(S,A_i)$，容量为 $1$。$A_i$ 向 $u_i,v_i$ 连接容量为无穷的边。原点向 $T$ 连边，容量为二分的 $k$ 值。 二分 $k$ 直到求得最大权闭合子图权值 $&lt; 0$ 为止。 既然要求在最大化权值情况下的点个数的最大值，那么再跑一遍最小割（$k$ 取允许的最大值），与 $S$ 联通的原点即为子图的点。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* * @Author: Skqliao * @Date: 2019-02-12 18:50:43 * @LastEditTime: 2019-02-12 22:17:09 * @Source: BZOJ * @Problem: Neerc2006 Hard Life * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1312 */#include &lt;bits/stdc++.h&gt;const int MAXN = 2100 + 5;const int MAXM = MAXN * 5;const double eps = 8e-6;struct Edge { int v; double f, cap; int nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Cur[MAXN], Dis[MAXN];int S, T;void addEdge(int u, int v, double f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, 0, 0, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); if (x == T) return true; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f &gt; eps) { Dis[v] = Dis[x] + 1; Que.push(v); } } } return false;}double dfs(int x, double maxf) { if (x == T) return maxf; double left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f &gt; eps) { double flow = dfs(v, std::min(left, E[i].f)); if (flow &gt; eps) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (left &lt; eps) return maxf; } else Dis[v] = -1; } } return maxf - left;}double dinic() { double flow = 0; while (bfs()) { flow += dfs(S, INT_MAX); } return flow;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}int N, M;bool check(double x) { for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } for (int i = 1; i &lt;= N; ++i) { for (int j = H[i]; ~j; j = E[j].nxt) { if (E[j].v == T) { E[j].f = E[j].cap = x; } } } return M - dinic() &gt; eps;}int main() { int u, v; scanf(\"%d%d\", &amp;N, &amp;M); if (M == 0) { puts(\"1\"); return 0; } init(N + M); for (int i = 1; i &lt;= N; ++i) { addEdge(i, T, 0); } for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(S, i + N, 1); addEdge(i + N, u, INT_MAX); addEdge(i + N, v, INT_MAX); } double l = 0, r = M; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { l = m; } else r = m; } check(l - eps); int ans = 0; for (int i = 1; i &lt;= N; ++i) { if (Dis[i] != -1) ++ans; } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-1312/"},{"title":"「NOI 2006」BZOJ 1497 最大获利","text":"有 $N$ 个点，选择点 $i$ 花费 $A_i$ 的代价。有 $M$ 个关系，如果点 $x_i,y_i$ 均被选择，则可以获得收益 $B_i$。求收益-代价的最大值。 $N\\leq 5000,M\\leq 50000$ 分析这类问题也是常见的二元关系类题目，称之为最大权闭合子图。 将每个点的花费作为该点的点权（负数），将两点间的边抽象成一个点，点权为收益，新点向这两个点连有向边。 那么如果选择收益对应的点，就必须也选择其所有后继。最终求选择的子图点权和的最大值，这正是求最大权闭合子图。 根据相关建图方法，该问题可以转化为求最小割。 $S$ 向所有正点权的点连边，容量为该点点权。所有负权点向 $T$ 连边，容量为点权的绝对值。原图的所有边保留，容量为无穷大。则原图的最大权闭合子图的权值和为原图中所有正点权权值之和-新图最小割。 简易证明如下： 考虑一条有向边 $x\\rightarrow y$，如果 $x$ 被选择则 $y$ 必须被选择。即若 $y$ 不选且 $x$ 选，需要付出无穷的代价。清楚这一点后，根据网络流之二元关系的建图套路便能得到新图。 按照常理说这么多点和边的图跑网络流是很慢的，1s的时间跑不出来。但是对于这道题而言，图只有四层，即 $S$/正权点/负权点/$T$，所以每次增广时的深度很小，也就跑的很快。（纯粹口胡） 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-02-12 18:09:52 * @LastEditTime: 2019-02-12 18:23:18 * @Source: NOI 2006 * @Problem: 1497: [NOI2006]最大获利 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1497 */#include &lt;bits/stdc++.h&gt;const int MAXN = 55000 + 5;const int MAXM = MAXN * 3;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int S, T;int Cur[MAXN], Dis[MAXN];void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memset(Dis, -1, sizeof Dis); memcpy(Cur, H, sizeof H); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) { flow += dfs(S, INT_MAX); } return flow;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}int N, M;int ans;int main() { int x, y, z; scanf(\"%d%d\", &amp;N, &amp;M); init(N + M); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); addEdge(i, T, x); } for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); addEdge(S, i + N, z); addEdge(i + N, x, INT_MAX); addEdge(i + N, y, INT_MAX); ans += z; } printf(\"%d\\n\", ans - dinic()); return 0;}","link":"/BZOJ-1497/"},{"title":"「HNOI 2004」BZOJ 1208 宠物收养所","text":"有两个正整数集合 $A,B$ ，起初都是它们都是空集。 现按顺序插入 $N$ 个数 $A[1…N]$，每个数属于 $A$ 或 $B$ 。 如果插入的数 $x$ 属于集合 $A$ ，当集合 $B$ 不为空时，删去 $B$ 中 与 $x$ 差绝对值最小的数 $y$ 。如果存在 $b = x+a,c=x-a$ ，则优先删去 $c$ 。该操作的代价为两数差的绝对值。当集合 $B$ 为空时，将 $x$ 直接插入集合 $A$ 中，没有代价。 如果插入的数属于集合 $B$ ，操作同理。 求插入完 $N$ 个数后的代价，答案对 $1000000$ 取模。 $N\\leq 80000,0&lt; A_i&lt; 2^{31}$ 分析根据题意可得，在任何时候集合 $A,B$ 至少有一个为空，因此只需要维护一个集合。 通过Treap等数据结构维护当前有数的集合。每次插入 $x$ 后，查询集合中 $x$ 的前驱后继，取较小值删去，并计算代价。 由于可能存在没有前驱后继的情况，初始化时插入一个极大值和一个极小值可以避免各种讨论，当树的 $size=2$ 时认为其为空即可。 复杂度 $O(N\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 80000 + 5;struct TreapTree { struct Treap { int key, fix; int cnt, sz; Treap *ch[2]; int cmp(int x) { return key == x ? -1 : key &lt; x; } void pushUp() { sz = cnt; if (ch[0]) { sz += ch[0]-&gt;sz; } if (ch[1]) { sz += ch[1]-&gt;sz; } } } Pool[MAXN], *R; int cntP; Treap* newTreap(int x) { Pool[++cntP] = (Treap) {x, rand(), 1, 1, NULL, NULL}; return &amp;Pool[cntP]; } void rotate(Treap* &amp;t, int d) { Treap* k = t-&gt;ch[d ^ 1]; t-&gt;ch[d ^ 1] = k-&gt;ch[d]; k-&gt;ch[d] = t; t-&gt;pushUp(); k-&gt;pushUp(); t = k; } void insert(Treap* &amp;t, int x) { if (!t) { t = newTreap(x); return ; } int d = t-&gt;cmp(x); ++t-&gt;sz; if (d == -1) { ++t-&gt;cnt; } else { insert(t-&gt;ch[d], x); if (t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix) { rotate(t, d ^ 1); } } } void erase(Treap* &amp;t, int x) { if (!t) { return ; } int d = t-&gt;cmp(x); if (d == -1) { if (t-&gt;cnt &gt; 1) { --t-&gt;cnt; --t-&gt;sz; } else if (!t-&gt;ch[0]) { t = t-&gt;ch[1]; } else if (!t-&gt;ch[1]) { t = t-&gt;ch[0]; } else { int e = t-&gt;ch[0]-&gt;fix &gt; t-&gt;ch[1]-&gt;fix; rotate(t, e); erase(t-&gt;ch[e], x); } } else { erase(t-&gt;ch[d], x); } if (t) { t-&gt;pushUp(); } } int res; void queryPre(Treap* &amp;t, int x) { if (!t) { return ; } if (t-&gt;key &lt;= x) { res = t-&gt;key; queryPre(t-&gt;ch[1], x); } else { queryPre(t-&gt;ch[0], x); } } void querySub(Treap* &amp;t, int x) { if (!t) { return ; } if (t-&gt;key &gt;= x) { res = t-&gt;key; querySub(t-&gt;ch[0], x); } else { querySub(t-&gt;ch[1], x); } }} T;int main() { int N = io::gt&lt;int&gt;(); int type; ll res = 0; T.insert(T.R, -INT_MAX); T.insert(T.R, INT_MAX); while (N--) { int opt = io::gt&lt;int&gt;(); int x = io::gt&lt;int&gt;(); if (T.R-&gt;sz == 2 || type == opt) { T.insert(T.R, x); type = opt; } else { T.queryPre(T.R, x); int pre = T.res; T.querySub(T.R, x); int sub = T.res; if (pre == -INT_MAX) { res += sub - x; T.erase(T.R, sub); } else if (sub == INT_MAX) { res += x - pre; T.erase(T.R, pre); } else { if (x - pre &lt;= sub - x) { res += x - pre; T.erase(T.R, pre); } else { res += sub - x; T.erase(T.R, sub); } } } } printf(\"%lld\\n\", res % 1000000); return 0;}","link":"/BZOJ-1208/"},{"title":"「HNOI 2005」BZOJ 1202 狡猾的商人","text":"给定 $M$ 组关于 $l, r, x$ 的等式，意为 $\\sum\\limits_{i=l}^{r}{A_i}=x$，判断是否可以构造出 $A[1\\cdots N]$ 满足这些等式。 $N\\leq 100,M\\leq 1000$ 分析将等式写成前缀和的形式，用 $Sum[i]$ 表示 $\\sum\\limits_{j=1}^{i}{A_j}$ ，等式化为 $Sum[r] - Sum[l-1] = x$。 可以将等式变形成两个不等式， $Sum[r] - Sum[l-1] \\geq x$ 和 $Sum[l - 1] - Sum[r] \\geq -x$ 。 那么原问题就转化为差分约束系统求解模型。连接边 $(l - 1, r, x)$ 和 $(r, l - 1, -x)$ ，SPFA判断是否存在负环，复杂度 $O(NM)$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;const int MAXM = 1000 + 5;int N, M;struct Edge { int v, w, nxt;} E[MAXM * 3];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;int Dis[MAXN], Cnt[MAXN], Inq[MAXN];bool Vis[MAXN];int n;bool spfa() { while (!Que.empty()) { Que.pop(); } memset(Dis, 0x3f, sizeof Dis); memset(Inq, 0, sizeof Inq); memset(Cnt, 0, sizeof Cnt); Que.push(N + 1); Dis[N + 1] = 0; while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Cnt[v] = Cnt[x] + 1; if (Cnt[v] &gt; n) { return false; } if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } return true;}void init() { cntE = 0; memset(H, 0, sizeof H); n = 0; memset(Vis, 0, sizeof Vis);}int main() { int T, u, v, w; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); init(); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); if (!Vis[u - 1]) { Vis[u - 1] = 1; ++n; } if (!Vis[v]) { Vis[v] = 1; ++n; } addEdge(u - 1, v, -w); addEdge(v, u - 1, w); } for (int i = 1; i &lt;= N; ++i) { addEdge(N + 1, i, 0); } if (spfa()) { puts(\"true\"); } else { puts(\"false\"); } } return 0;}","link":"/BZOJ-1202/"},{"title":"「SCOI 2010」BZOJ 1858 序列操作","text":"在一个01序列中，有五种变换操作和询问操作： 0 a b 把$[a, b]$区间内的所有数全变成$0$ 1 a b 把$[a, b]$区间内的所有数全变成$1$ 2 a b 把$[a,b]$区间内的所有数全部取反，也就是说把所有的$0$变成$1$，把所有的$1$变成$0$ 3 a b 询问$[a, b]$区间内总共有多少个$1$ 4 a b 询问$[a, b]$区间内最多有多少个连续的$1$ $1\\leq n, m\\leq 100000$ 分析这种区间操作、区间查询，且满足区间加法的题，再看一下 $1e5$ 的数据范围，很显然是用线段树来维护。 维护区间中 $1$ 的数目（即区间和），左右连续 $0,1$ 的长度，最长的连续的 $0,1$ 的长度，当然还有取反和重置 $0/1$ 的标记。 那么合并的时候，连续的 $0,1$ 有两种合并方式：继承左右，或者左右合并（即左区间的右+右区间的左，这两段拼起来是连续的）。 区间取反，即交换所有关于 $0,1$ 的信息；区间重置，根据区间长度直接更新信息。 复杂度 $O(m\\log{n})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rstruct Segment { int l, r; int sum, rev, trn; int ln[2], rn[2], mx[2];} T[MAXN &lt;&lt; 2];int max3(int a, int b, int c) { return std::max(a, std::max(b, c));}Segment merge(Segment x, Segment y) { Segment a; a.trn = -1, a.rev = 0; a.l = x.l, a.r = y.r; a.sum = x.sum + y.sum; rep(i, 0, 2) { a.ln[i] = x.ln[i], a.rn[i] = y.rn[i]; a.mx[i] = max3(x.mx[i], y.mx[i], x.rn[i] + y.ln[i]); if (!x.mx[i ^ 1]) { a.ln[i] = x.mx[i] + y.ln[i]; } if (!y.mx[i ^ 1]) { a.rn[i] = y.mx[i] + x.rn[i]; } } return a;}void turn(Segment &amp;x, int d) { x.rev = 0; x.ln[d] = x.rn[d] = x.mx[d] = x.r - x.l + 1; x.ln[d ^ 1] = x.rn[d ^ 1] = x.mx[d ^ 1] = 0; if (d == 1) { x.sum = x.r - x.l + 1; } else { x.sum = 0; }}void rever(Segment &amp;x) { x.sum = x.r - x.l + 1 - x.sum; std::swap(x.mx[0], x.mx[1]); std::swap(x.ln[0], x.ln[1]); std::swap(x.rn[0], x.rn[1]);}void pushDown(int rt) { Segment &amp;x = T[rt], &amp;ls = T[rt &lt;&lt; 1], &amp;rs = T[rt &lt;&lt; 1 | 1]; if (x.trn != -1) { ls.trn = rs.trn = x.trn; turn(ls, x.trn); turn(rs, x.trn); x.trn = -1; } if (x.rev) { ls.rev ^= 1; rs.rev ^= 1; rever(ls); rever(rs); x.rev = 0; }}void build(int rt, int l, int r) { if (l == r) { Segment &amp;x = T[rt]; x.rev = 0, x.trn = -1; x.l = x.r = l; x.sum = io::gt&lt;int&gt;(); x.ln[x.sum] = x.rn[x.sum] = x.mx[x.sum] = 1; x.ln[x.sum ^ 1] = x.rn[x.sum ^ 1] = x.mx[x.sum ^ 1] = 0; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); T[rt] = merge(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}void change(int rt, int a, int b, int x) { int l = T[rt].l, r = T[rt].r; if (a &lt;= l &amp;&amp; r &lt;= b) { T[rt].trn = x; turn(T[rt], x); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { change(rt &lt;&lt; 1, a, b, x); } if (m &lt; b) { change(rt &lt;&lt; 1 | 1, a, b, x); } T[rt] = merge(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}void reverse(int rt, int a, int b) { int l = T[rt].l, r = T[rt].r; if (a &lt;= l &amp;&amp; r &lt;= b) { T[rt].rev ^= 1; rever(T[rt]); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { reverse(rt &lt;&lt; 1, a, b); } if (m &lt; b) { reverse(rt &lt;&lt; 1 | 1, a, b); } T[rt] = merge(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}int querySum(int rt, int a, int b) { int l = T[rt].l, r = T[rt].r; if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt].sum; } pushDown(rt); int res = 0; int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { res += querySum(rt &lt;&lt; 1, a, b); } if (m &lt; b) { res += querySum(rt &lt;&lt; 1 | 1, a, b); } return res;}Segment queryMax(int rt, int a, int b) { int l = T[rt].l, r = T[rt].r; if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt]; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (b &lt;= m) { return queryMax(rt &lt;&lt; 1, a, b); } else if (m &lt; a) { return queryMax(rt &lt;&lt; 1 | 1, a, b); } else { return merge(queryMax(rt &lt;&lt; 1, a, b), queryMax(rt &lt;&lt; 1 | 1, a, b)); }}int main() { int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); build(1, 1, N); while (M--) { int opt = io::gt&lt;int&gt;(); int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); ++l, ++r; if (opt == 0 || opt == 1) { change(1, l, r, opt); } else if (opt == 2) { reverse(1, l, r); } else if (opt == 3) { io::pt(querySum(1, l, r)); } else if (opt == 4) { io::pt(queryMax(1, l, r).mx[1]); } } io::flush(); return 0;}","link":"/BZOJ-1858/"},{"title":"「2010 集训队测验」BZOJ 2127 文理分科","text":"在 $n\\times m$ 的矩阵中，每个格子可以选择 $0/1$，分别获得收益 $A_{i,j},B_{i,j}$。如果上下两个格子选择相同，则额外获得收益 $C_{i,j}$ 与 $D_{i,j}$（都选 $0$ 或都选 $1$），如果左右两个格子选择相同，则额外获得收益 $E_{i,j}$ 与 $F_{i,j}$。求总收益的最大值。 $n,m\\leq 100,A,B,C,D,E,F_{i,j}\\leq 5000$ 分析这是集训队论文《浅谈一类最小割问题》中的例题，也是网络流建模之二元关系的一道典型题目。 根据相关建图模型，对于每个点 $x$，分别与 $S,T$ 连边，割去 $(S,x)$表示选择文科，割去 $(x,T)$ 表示选择理科。 由于只能求最小割，因此可以先累计所有收益再减去最小割得到最大值。 由于每个点与相邻的点之间的选择会影响结果，因此 $x$ 与相邻的点连边。 对于任意两个相邻点 $x,y$，子图有边 $(S,x),(S,y),(x,y),(y,x),(x,T),(y,T)$。 割去 $(S,x),(S,y)$ 表示都选文，割去 $(x,T),(y,T)$ 表示都选理，割去 $(S,x),(x,y),(y,T)$ 表示 $x$ 选文，$y$选理，剩下一种情况同理第三种。 假设 $x,y$ 选文的收益分别为 $a_x,a_y$，选理的收益为 $b_x,b_y$，都选文/理的收益为 $c,d$，则边权应满足： $$(S,x)+(S,y)=b_x+b_y+d\\(x,T)+(y,T)=a_x+a_y+c\\(S,x)+(x,y)+(y,T)=a_y+b_x+c+d\\(S,y)+(y,x)+(x,T)=a_x+b_y+c+d\\$$得到一组解： $$(x,y)=(y,x)=\\frac{c+d}{2}\\(S,x)=a_x+\\frac{c}{2}\\(S,y)=a_y+\\frac{c}{2}\\(x,T)=b_x+\\frac{d}{2}\\(y,T)=b_y+\\frac{d}{2}\\$$ 由此建图求最大流即可。 Tips：将两点间所有边的边权整合成一条边会大大提高运行速度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* * @Author: Skqliao * @Date: 2019-02-10 20:45:11 * @LastEditTime: 2019-02-10 21:37:48 * @Source: 2010 集训队测试题 * @Problem: 2127: happiness * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2127 */#include &lt;bits/stdc++.h&gt;namespace mxf {const int MAXN = 100 * 100 + 5;const int MAXM = MAXN * 4;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int S, T;int H[MAXN], cntE;void addEdge(int u, int v, int f, bool directed = 1) { E[++cntE] = (Edge){v, f, H[u]}; H[u] = cntE; if (directed) f = 0; E[++cntE] = (Edge){u, f, H[v]}; H[v] = cntE;}int Dis[MAXN], Cur[MAXN];bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memset(Dis, -1, sizeof Dis); memcpy(Cur, H, sizeof H); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) { flow += dfs(S, INT_MAX); } return flow;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}} // namespace mxfusing mxf::addEdge;using mxf::S;using mxf::T;const int MAXN = 100 + 5;int N, M;int Id[MAXN][MAXN];int A[MAXN][MAXN], B[MAXN][MAXN], C[MAXN][MAXN], D[MAXN][MAXN], E[MAXN][MAXN], F[MAXN][MAXN];int ans;int main() { scanf(\"%d%d\", &amp;N, &amp;M); mxf::init(N * M); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { Id[i][j] = (i - 1) * M + j; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); ans += A[i][j]; A[i][j] *= 2; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;B[i][j]); ans += B[i][j]; B[i][j] *= 2; } } for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;C[i][j]); ans += C[i][j]; A[i][j] += C[i][j]; A[i + 1][j] += C[i][j]; } } for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;D[i][j]); ans += D[i][j]; B[i][j] += D[i][j]; B[i + 1][j] += D[i][j]; addEdge(Id[i][j], Id[i + 1][j], C[i][j] + D[i][j], 0); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;E[i][j]); ans += E[i][j]; A[i][j] += E[i][j]; A[i][j + 1] += E[i][j]; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;F[i][j]); ans += F[i][j]; B[i][j] += F[i][j]; B[i][j + 1] += F[i][j]; addEdge(Id[i][j], Id[i][j + 1], E[i][j] + F[i][j], 0); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { addEdge(S, Id[i][j], A[i][j]); addEdge(Id[i][j], T, B[i][j]); } } printf(\"%d\\n\", ans - mxf::dinic() / 2); return 0;}","link":"/BZOJ-2127/"},{"title":"「ZJOI 2006」BZOJ 1003 物流运输","text":"一共有 $n$ 天，每天要在无向图 $G$ 中从 $1$ 走到 $m$。有 $k$ 个限制条件，即不能在第 $[l,r]$ 天中经过点 $i$。每天的花费为路径总长度，每次更换线路（相比于前一天）会额外增加 $k$ 的花费，求最小花费。 $n\\leq 100,m\\leq 20$ 分析点数极少，因此我们可以通过 $n^2$ 次最短路，预处理出来第 $[l,r]$ 天的每天的最小花费 $C[l][r]$（保证该花费对应的路径在第 $[l,r]$ 天都是合法的）。 然后DP， $F[i]$ 表示前 $i$ 天最小的总花费。枚举上一次更换的时间 $j$，则 $F[i]=\\min{F[j-1]+(j-i+1)\\cdot C[j][i]+K\\cdot[j\\not = 1]}(1\\leq j\\leq i)$。 复杂度 $O(n^2m\\log{m})$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * @Author: Skqliao * @Date: 2019-02-16 18:54:21 * @LastEditTime: 2019-02-16 20:02:16 * @Source: ZJOI 2006 * @Problem: 1003: [ZJOI2006]物流运输 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1003 */#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;int N, M, K, P, D;int W[MAXN][MAXN];struct Edge { int v, w, nxt;} E[MAXN * MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, w, H[v]}; H[v] = cntE;}typedef std::pair&lt;int, int&gt; pii;int dijkstra(int l, int r) { static std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt; &gt; Pq; static int Dis[MAXN]; static bool Vis[MAXN]; memset(Vis, 0, sizeof Vis); memset(Dis, 0x3f, sizeof Dis); Dis[1] = 0; Pq.push(std::make_pair(0, 1)); for (int i = l; i &lt;= r; ++i) { for (int j = 1; j &lt;= M; ++j) { if (W[i][j]) Vis[j] = 1; } } while (!Pq.empty()) { while (!Pq.empty() &amp;&amp; Pq.top().first &gt; Dis[Pq.top().second]) Pq.pop(); if (Pq.empty()) break; int x = Pq.top().second; Pq.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Vis[v] || Dis[v] &lt; Dis[x] + E[i].w) continue; Dis[v] = Dis[x] + E[i].w; Pq.push(std::make_pair(Dis[v], v)); } } return Dis[M];}int F[MAXN], G[MAXN][MAXN];int main() { int u, v, w; scanf(\"%d%d%d%d\", &amp;N, &amp;M, &amp;K, &amp;P); for (int i = 1; i &lt;= P; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } scanf(\"%d\", &amp;D); for (int i = 1; i &lt;= D; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); for (int j = v; j &lt;= w; ++j) W[j][u] = 1; } for (int i = 1; i &lt;= N; ++i) { for (int j = i; j &lt;= N; ++j) { G[i][j] = dijkstra(i, j); } } for (int i = 1; i &lt;= N; ++i) { F[i] = INT_MAX; if (G[1][i] != 0x3f3f3f3f) F[i] = i * G[1][i]; for (int j = 2; j &lt;= i; ++j) { if (G[j][i] != 0x3f3f3f3f) F[i] = std::min(F[i], F[j - 1] + G[j][i] * (i - j + 1) + K); } } printf(\"%d\\n\", F[N]); return 0;}","link":"/BZOJ-1003/"},{"title":"「ZJOI 2008」BZOJ 1040 骑士","text":"每个点有权值 $W_i$，选择点 $i$ 后不能选择点 $A_i$。选择任意多个点，使得权值和最大。 $N\\leq 1000000$ 分析根据题意，不能同时选择点 $i$ 和 $A_i$。 该图有 $N$ 个点 $N$ 条边，因此是个基环树森林。 对于每棵基环树，断掉环上任意一条边 $(u,v)$。以 $u,v$ 分别为根跑树形DP，父亲儿子不能被同时选择，且根节点不能被选。则这棵基环树的贡献为两次DP的较大值。 复杂度 $O(n)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* * @Author: Skqliao * @Source: BZOJ 2008 * @Problem: 1040: [ZJOI2008]骑士 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1040 * @Date: 2019-02-21 15:39:58 * @LastEditTime: 2019-02-21 16:12:59 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000000 + 5;int N;int W[MAXN];struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE = -1;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}int Vis[MAXN], cnt;int fir, sec, cut;void dfs(int x, int fa) { Vis[x] = cnt; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa) { if (!Vis[v]) { dfs(v, x); } else { fir = x; sec = v; cut = i; } } }}long long F[MAXN][2];long long dp(int x, int fa) { F[x][1] = W[x]; F[x][0] = 0; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (i == cut || i == (cut ^ 1) || v == fa) continue; dp(v, x); F[x][0] += std::max(F[v][0], F[v][1]); F[x][1] += F[v][0]; } return F[x][0];}int main() { memset(H, -1, sizeof H); scanf(\"%d\", &amp;N); int x; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;W[i], &amp;x); addEdge(x, i); } long long ans = 0; for (int i = 1; i &lt;= N; ++i) { if (Vis[i]) continue; ++cnt; dfs(i, 0); ans += std::max(dp(fir, 0), dp(sec, 0)); } printf(\"%lld\\n\", ans); return 0;}","link":"/BZOJ-1040/"},{"title":"「HNOI 2002」BZOJ 1224 彩票","text":"从 $[1,M]$ 中选取 $N$ 个不同整数 $A_i$，使得 $\\sum{\\frac{1}{A_i}} = \\frac{p}{q}$ 。求有多少种不同选法。 $1\\leq p,q\\leq 100$，$1\\leq N\\leq10$，$1\\leq M\\leq 50$，结果不超过 $10^5$。 分析看到这个数据范围，$N\\leq 10$，比较显然是一个搜索+剪枝。 那么如何剪枝？ 最简单的便是如果当前没选完且 $sum\\geq \\frac{p}{q}$ ，那么就立即返回。 还有两个比较显然的优化。 假设顺序搜索，当前值为 $x$ ，当前和为 $sum$ ，剩余选取 $n$ 个数。 那么如果可能得到 $\\frac{p}{q}$ ，至少要满足$sum + \\frac{1}{x} n \\geq \\frac{p}{q}$ 且 $sum + \\frac{1}{M} n\\leq \\frac{p}{q}$ 。 即当前值加上选取剩余数的最小值 $min$ 一定小于结果，加上最大值 $max$ 一定大于结果，否则不可能存在 $min\\leq a\\leq max$ 使得 $sum + a = \\frac{p}{q}$ 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const double eps = 1e-10;int N, M, X, Y;int ans;double goal;void dfs(int x, int total, double sum) { if(goal - sum - 1.0 / x * (N - total) &gt; eps) { return ; } if(sum + 1.0 / M * (N - total) - goal &gt; eps) { return ; } if(total == N) { if(fabs(sum - goal) &lt;= eps) { ++ans; } return ; } if(x &lt;= M) { dfs(x + 1, total + 1, sum + 1.0 / x); dfs(x + 1, total, sum); }}int main() { scanf(\"%d%d%d%d\", &amp;N, &amp;M, &amp;X, &amp;Y); goal = 1.0 * X / Y; dfs(1, 0, 0); printf(\"%d\\n\", ans); return 0;}`","link":"/BZOJ-1224/"},{"title":"「中山市选 2009」 BZOJ 2464 小明的游戏","text":"在一个 $N\\times M$ 的01网格图中，每次可以向相邻的格子移动，移动到同一类型的格子的花费为 $0$，否则为 $1$，求起点到终点的最小花费。 $1\\leq n, m\\leq 500$ 分析由于边权非 $0$ 即 $1$，因此SPFA的复杂度上限就是点数，即 $N^2$ 。 复杂度 $O(T\\times N^2)$ ，其中 $T$ 为数据组数。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"game.in\", \"r\", stdin); freopen(\"game.out\", \"w\", stdout);}const int MAXN = 500 + 5;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;char Str[MAXN][MAXN];int sx, sy, ex, ey;bool check(int x, int y) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &lt; M;}int spfa() { static int Dis[MAXN][MAXN]; static bool Inq[MAXN][MAXN]; std::queue&lt;int, std::deque&lt;int&gt; &gt; Qx, Qy; memset(Inq, 0, sizeof Inq); memset(Dis, 0x3f, sizeof Dis); Qx.push(sx); Qy.push(sy); Dis[sx][sy] = 0; while (!Qx.empty()) { int x = Qx.front(), y = Qy.front(); Qx.pop(), Qy.pop(); Inq[x][y] = 0; rep(i, 0, 4) { int nx = x + Dicx[i];; int ny = y + Dicy[i]; if (!check(nx, ny)) { continue ; } int dis = Dis[x][y] + (Str[x][y] != Str[nx][ny]); if (Dis[nx][ny] &gt; dis) { Dis[nx][ny] = dis; if (!Inq[nx][ny]) { Inq[nx][ny] = 1; Qx.push(nx); Qy.push(ny); } } } } return Dis[ex][ey];}int main() { //open(); while (true) { scanf(\"%d%d\", &amp;N, &amp;M); if (N + M == 0) { break; } rep(i, 0, N) { scanf(\"%s\", Str[i]); } scanf(\"%d%d%d%d\", &amp;sx, &amp;sy, &amp;ex, &amp;ey); printf(\"%d\\n\", spfa()); } return 0;}","link":"/BZOJ-2464/"},{"title":"「ZJOI 2011」BZOJ 2229 最小割","text":"$T$ 组数据，$Q$ 个询问。在无向图 $G$ 中，求有多少个点对 $(s,t)$ 使得它们之间的最小割不超过 $x$。 $T\\leq 10,n\\leq 150,m\\leq 3000,q\\leq 30$ 分析建完最小割树后，问题转化为求树上有多少个点对路径上的边权最小值不超过 $x$。 枚举点对再用倍增判断，复杂度 $O(n^2\\log{n})$。 也存在线性做法，对于边权不超过 $x$ 的边，统计路径通过该边新增的点对数量，复杂度 $O(n)$。 然而由于复杂度瓶颈在建立最小割树上，因此两种方法实际效率相仿。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* * @Author: Skqliao * @Date: 2019-02-02 22:57:06 * @LastEditTime: 2019-02-03 11:53:06 * @Source: ZJOI 2011 * @Problem: 2229: [Zjoi2011]最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2229 */#include &lt;bits/stdc++.h&gt;const int MAXN = 150 + 5;const int MAXM = 3000 + 5;namespace GH_Tree {struct Edge { int v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge){v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, w, H[v]}; H[v] = cntE;}int Fa[MAXN], Sz[MAXN];int dfs(int x) { Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; Sz[x] += dfs(v); } } return Sz[x];}int ans;int dfs(int x, int sz, int mx) { int tot = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { if (E[i].w &lt;= mx) { tot += Sz[v]; ans += Sz[v] * (sz - Sz[v]); sz -= Sz[v]; dfs(v, Sz[v], mx); } else { int tmp = dfs(v, sz, mx); sz -= tmp; tot += tmp; } } } return tot;}void init() { cntE = 0; memset(H, 0, sizeof H);}int query(int x) { ans = 0; dfs(1, Sz[1], x); return ans;}namespace Init { struct Edge { int v, f, cap, nxt; } E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; int Idx[MAXN], Tmp[MAXN]; int S, T; int Dis[MAXN], Cur[MAXN]; int Col[MAXN]; void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; } } void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE; } bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false; } int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left; } int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow; } void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); } } void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); GH_Tree::addEdge(S, T, f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r); } void solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); }} // namespace Init} // namespace GH_Treeint T, N, M, Q;int main() { int x; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); GH_Tree::init(); GH_Tree::Init::solve(N, M); GH_Tree::dfs(1); scanf(\"%d\", &amp;Q); while (Q--) { scanf(\"%d\", &amp;x); printf(\"%d\\n\", GH_Tree::query(x)); } puts(\"\"); } return 0;}","link":"/BZOJ-2229/"},{"title":"「SDOI 2011」BZOJ 2243 染色","text":"给定一棵有 $N$ 个节点的树，每个节点有一个颜色。 现有$M$个操作，分为两类： 将节点对 $(u,v)$ 之间路径上的所有节点的颜色染成 $x$ 查询节点对 $(u,v)$ 之间颜色段的个数（相邻且相同颜色的节点对属于同一个颜色段） $N,M\\leq 10^5,x\\leq 10^9$ 分析思路很简单，树剖之后用线段树维护区间颜色段的个数。 线段树总共需要维护区间的颜色段个数，最左边颜色和最右边颜色，当然还有lazy标签。 如果区间 $[l,m]$ 的最右边的颜色和区间 $[m+1,r+1]$ 最左边的颜色相同，则 $[l,r]$ 区间中颜色段个数为两者的和减一。 查询的时候有一个细节。 $(u,v)$ 之间颜色段的个数即若干条链上颜色段的个数之和，但是要注意链顶和它的父亲颜色是否相同。 这两个节点也是相邻的，但是在链的查询中不会被涉及到。 复杂度 $O(N+M\\log^2{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 1e5 + 4;struct Graph { struct Edge { int v, nxt; } E[MAXN &lt;&lt; 1]; int N, R; int Depth[MAXN], Son[MAXN], Fa[MAXN], Sz[MAXN]; int Dfn[MAXN], cntD, Top[MAXN]; int W[MAXN], Wp[MAXN]; int H[MAXN], cntE; void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; } void dfs(int x) { Son[x] = 0, Sz[x] = 1; for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { Fa[v] = x; Depth[v] = Depth[x] + 1; dfs(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } } } void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; W[cntD] = Wp[x]; if(Son[x]) { dfs2(Son[x], top); } for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Son[x] &amp;&amp; v != Fa[x]) { dfs2(v, v); } } }#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, r int Num[MAXN &lt;&lt; 2], Mark[MAXN &lt;&lt; 2], Left[MAXN &lt;&lt; 2], Right[MAXN &lt;&lt; 2]; void pushUp(int rt) { Num[rt] = Num[rt &lt;&lt; 1] + Num[rt &lt;&lt; 1 | 1] - (Right[rt &lt;&lt; 1] == Left[rt &lt;&lt; 1 | 1]); Left[rt] = Left[rt &lt;&lt; 1]; Right[rt] = Right[rt &lt;&lt; 1 | 1]; } void pushDown(int rt, int L) { int &amp;mrk = Mark[rt]; if(!mrk) { return ; } Mark[rt &lt;&lt; 1] = Mark[rt &lt;&lt; 1 | 1] = mrk; Num[rt &lt;&lt; 1] = Num[rt &lt;&lt; 1 | 1] = 1; Left[rt &lt;&lt; 1] = Left[rt &lt;&lt; 1 | 1] = mrk; Right[rt &lt;&lt; 1] = Right[rt &lt;&lt; 1 | 1] = mrk; mrk = 0; } void build(int rt, int l, int r) { if(l == r) { Num[rt] = 1; Left[rt] = Right[rt] = W[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt); } void change(int rt, int l, int r, int a, int b, int x) { if(a &lt;= l &amp;&amp; r &lt;= b) { Num[rt] = 1; Left[rt] = Right[rt] = x; Mark[rt] = x; return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { change(LT, a, b, x); } if(m &lt; b) { change(RT, a, b, x); } pushUp(rt); } int queryNum(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Num[rt]; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; int res = 0, times = 0; if(a &lt;= m) { res += queryNum(LT, a, b); ++times; } if(m &lt; b) { res += queryNum(RT, a, b); ++times; } if(times == 2 &amp;&amp; Right[rt &lt;&lt; 1] == Left[rt &lt;&lt; 1 | 1]) { --res; } return res; } int query(int rt, int l, int r, int p) { if(l == r) { return Left[rt]; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { return query(LT, p); } else { return query(RT, p); } } void changePath(int u, int v, int x) { int tu = Top[u], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } change(1, 1, N, Dfn[tv], Dfn[v], x); v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } change(1, 1, N, Dfn[u], Dfn[v], x); } int queryPath(int u, int v) { int res = 0, tu = Top[u], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } res += queryNum(1, 1, N, Dfn[tv], Dfn[v]); if(query(1, 1, N, Dfn[tv]) == query(1, 1, N, Dfn[Fa[tv]])) { --res; } v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } res += queryNum(1, 1, N, Dfn[u], Dfn[v]); return res; } void prepare() { dfs(R); dfs2(R, R); build(1, 1, N); }} G;int main() { G.N = io::gt&lt;int&gt;(); G.R = 1; int M = io::gt&lt;int&gt;(); rep(i, 1, G.N + 1) { G.Wp[i] = io::gt&lt;int&gt;(); } rep(i, 1, G.N) { G.addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } G.prepare(); while(M--) { char c = io::gc(); while(!isalpha(c)) { c = io::gc(); } int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); if(c == 'C') { G.changePath(u, v, io::gt&lt;int&gt;()); } else { io::pt(G.queryPath(u, v)); } } io::flush(); return 0;}","link":"/BZOJ-2243/"},{"title":"「HNOI 2009」BZOJ 1486 最小圈","text":"在有向图 $G$ 中，定义环 $a$ 的权值 $w_a=\\sum{W[i]}/num$，其中 $W[i]$ 为 $a$ 上边的权值， $num$ 为 $a$ 上的节点数。求图中 $w$ 的最小值。 $n\\leq 1000,m\\leq 5000,|W[i]|\\leq 5000$ 分析设 $w_a=x$，则 $\\sum{W[i]}/num \\geq x$，即 $\\sum{W[i]}\\geq num\\cdot x$。 由于环上点数和边数相同，因此可以改写为 $\\sum(W[i]-x)\\geq 0$。 $x$ 显然可以二分，于是就变成了判断图中是否存在负环的问题，用SPFA可解。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;const int MAXN = 3000 + 5;const int MAXM = 10000 + 5;const double INF = 1e7;const double eps = 1e-9;int N, M;struct Edge { int v; double w; int nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}double Dis[MAXN];bool Vis[MAXN], flag;bool dfs_spfa(int x, double xx) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; double dis = Dis[x] + E[i].w - xx; if (Dis[v] &gt; dis) { Dis[v] = dis; if (Vis[v] || dfs_spfa(v, xx)) { return true; } } } return Vis[x] = 0;}bool check(double a) { flag = 0; for (int i = 1; i &lt;= N; ++i) { Dis[i] = INF; } memset(Vis, 0, sizeof Vis); for (int i = 1; i &lt;= N; ++i) { if (dfs_spfa(i, a)) { return true; } } return false;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); int u, v; double w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%lf\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } double l = -INF, r = INF, ans = 0; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { r = m; ans = m; } else { l = m; } } printf(\"%.8lf\\n\", ans); return 0;}","link":"/BZOJ-1486/"},{"title":"「中山市选 2009」BZOJ 2466 树","text":"树 $T$ 上的每个节点都一盏熄灭的灯，已知按下某个节点的开关会改变它与它相连的所有节点的灯的状态，求将所有灯变亮的最少操作次数。 $1\\leq n\\leq 100$ 分析发现每个操作都是独立的，也就是说至多每个开关按一次。 再根据按开关会改变所有与它相连的灯的状态，想到一定是自叶子到根进行操作，那么就树形DP。 DP中注意当前节点无论亮与否，它的子树一定是全亮的（因为操作是一直往根上走的）。 对于一个节点有四种状态：按开关且亮、按开关且灭、不按开关且亮、不按开关且灭。 可以发现第二种没有意义（不按都亮了那还按它干什么）。 考虑剩余三种的状态如何从儿子转移。 其中“按开关且亮”的状态最简单，因为按了它之后要保证它的子树的灯全是亮的，因此从“它的所有儿子都灭且没按”的状态转移而来。 “不按开关且灭”的状态从“当前亮+当前儿子按且亮”或“当前灭+当前儿子不按且亮”转移。 “不按开关且亮”的状态从“当前亮+当前儿子不按且亮”或“当前灭+当前儿子按且亮”转移。 复杂度 $O(n)$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"tree.in\", \"r\", stdin); freopen(\"tree.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int INF = 0x03ffffff;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int N;int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}int F[MAXN][2][2];void dfs(int x, int fa) { int a = 0, b = INF, c = 0; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa) { int aa = a, bb = b; dfs(v, x); a = std::min(aa + F[v][0][1], bb + F[v][1][1]); b = std::min(aa + F[v][1][1], bb + F[v][0][1]); c += F[v][0][0]; } } F[x][0][0] = a; F[x][0][1] = b; F[x][1][1] = c + 1;}int main() { //open(); int u, v; while (true) { scanf(\"%d\", &amp;N); if (N == 0) { break; } cntE = -1; memset(H, -1, sizeof H); rep(i, 1, N) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); } dfs(1, 0); printf(\"%d\\n\", std::min(F[1][0][1], F[1][1][1])); } return 0;}","link":"/BZOJ-2466/"},{"title":"「AHOI 2009」BZOJ 1798 维护序列","text":"维护序列 $A[1…N]$ ，共 $M$ 次操作，分为三种： $A[l,r]$ 所有数加 $x$ $A[l,r]$ 所有数乘 $x$ $A[l,r]$ 求和 答案对 $P$ 取模。 $N,M\\leq 100000,1\\leq P\\leq 1000000000$ 分析线段树模板，注意lazy标签先处理乘法。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;struct Segment { int sum, add, mul;} T[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rll P;template&lt;class T, class G&gt; void inc(T &amp;x, G y) { (x += y) %= P;}template&lt;class T, class G&gt; void inu(T &amp;x, G y) { (x *= y) %= P;}void pushUp(int rt) { inc(T[rt].sum = 0, T[rt &lt;&lt; 1].sum + T[rt &lt;&lt; 1 | 1].sum);}void pushDown(int rt, int L) { Segment &amp;ls = T[rt &lt;&lt; 1], &amp;rs = T[rt &lt;&lt; 1 | 1]; int &amp;add = T[rt].add, &amp;mul = T[rt].mul; if (mul != 1) { inu(ls.sum, mul); inu(rs.sum, mul); inu(ls.add, mul); inu(rs.add, mul); inu(ls.mul, mul); inu(rs.mul, mul); mul = 1; } if (add != 0) { inc(ls.sum, add * (L - (L &gt;&gt; 1))); inc(rs.sum, add * (L &gt;&gt; 1)); inc(ls.add, add); inc(rs.add, add); add = 0; }}void build(int rt, int l, int r) { T[rt].add = 0, T[rt].mul = 1; if (l == r) { inc(T[rt].sum = 0, io::gt&lt;ll&gt;()); return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void mul(int rt, int l, int r, int a, int b, ll x) { if (a &lt;= l &amp;&amp; r &lt;= b) { inu(T[rt].sum, x); inu(T[rt].add, x); inu(T[rt].mul, x); return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { mul(LT, a, b, x); } if (m &lt; b) { mul(RT, a, b, x); } pushUp(rt);}void add(int rt, int l, int r, int a, int b, ll x) { if (a &lt;= l &amp;&amp; r &lt;= b) { inc(T[rt].sum, x * (r - l + 1)); inc(T[rt].add, x); return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { add(LT, a, b, x); } if (m &lt; b) { add(RT, a, b, x); } pushUp(rt);}ll querySum(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt].sum; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; ll res = 0; if (a &lt;= m) { inc(res, querySum(LT, a, b)); } if (m &lt; b) { inc(res, querySum(RT, a, b)); } return res;}int main() { int N = io::gt&lt;int&gt;(); P = io::gt&lt;ll&gt;(); build(1, 1, N); int M = io::gt&lt;int&gt;(); while (M--) { int opt = io::gt&lt;int&gt;(); int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); if (opt == 1) { mul(1, 1, N, l, r, io::gt&lt;ll&gt;() % P); } else if (opt == 2) { add(1, 1, N, l, r, io::gt&lt;ll&gt;() % P); } else { io::pt(querySum(1, 1, N, l, r)); } } io::flush(); return 0;}","link":"/BZOJ-1798/"},{"title":"「WC 2008」BZOJ 2595 游览计划","text":"在 $n\\times m$ 的网格图上有 $k$ 个景点，图上选择任意一个点有费用 $a_{i,j}$。求选择若干个点使得这 $k​$ 个景点联通，最小化花费并输出方案。 $n,m,k\\leq 10$ 分析这是一道最小斯坦纳树（minimum Steiner tree）的模板题。 其实看到这么小的数据范围也不难想到状压DP。用 $F[i][j][S]$ 表示当前选择点 $(i,j)$，图的联通状态为 $S$ 的最小花费。 转移方程有两个，一是状态间转移： $F[i][j][S] = \\min\\limits_{T\\in S}{F[i][j][T]+F[i][j][S-T]-A[i][j]}$；二是在同一个状态内松弛： $F[i][j][S] = \\min{F[i’][j’][S]+A[i][j]}$，其中 $(i’,j’)$ 与 $(i,j)$ 联通且属于 $S$。 前者可以通过枚举子集的方法转移，复杂度$O(6^k\\cdot n\\cdot m)$，后者用spfa或其他最短路算法松弛，复杂度 $O(2^k\\cdot f)$，$f$ 为最短路复杂度。总复杂度 $O(6^k\\cdot nm+2^k\\cdot f)$ 。 在转移/松弛时记录前一个点的状态，最后从终点一遍dfs得到所有被选择的点。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 /* * @Author: Skqliao * @Date: 2019-01-27 10:29:05 * @LastEditTime: 2019-01-27 12:39:07 * @Source: WC2008 * @Problem: 2595: [Wc2008]游览计划 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2595 */#include &lt;bits/stdc++.h&gt;const int MAXN = 10 + 2;const int MAXS = 1 &lt;&lt; MAXN;const int INF = 0x3f3f3f3f;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;int A[MAXN][MAXN];int F[MAXN][MAXN][MAXS];struct Node { int x, y, s;} Pre[MAXN][MAXN][MAXS];std::queue&lt;Node&gt; Que;bool Vis[MAXN][MAXN];void spfa(int s) { while (!Que.empty()) { Node a = Que.front(); Vis[a.x][a.y] = 0; Que.pop(); for (int i = 0; i &lt; 4; ++i) { int x = a.x + Dicx[i]; int y = a.y + Dicy[i]; if (x &lt; 1 || y &lt; 1 || x &gt; N || y &gt; M) { continue; } if (F[a.x][a.y][s] + A[x][y] &lt; F[x][y][s]) { F[x][y][s] = F[a.x][a.y][s] + A[x][y]; Pre[x][y][s] = (Node){a.x, a.y, s}; if (!Vis[x][y]) { Que.push((Node) {x, y, 0}); Vis[x][y] = 1; } } } }}void dfs(int x, int y, int s) { Vis[x][y] = 1; Node &amp;a = Pre[x][y][s]; if (a.x == 0 &amp;&amp; a.y == 0) { return ; } dfs(a.x, a.y, a.s); if (x == a.x &amp;&amp; y == a.y) { dfs(a.x, a.y, s - a.s); }}int main() { int cnt = 0; scanf(\"%d%d\", &amp;N, &amp;M); memset(F, 0x3f, sizeof F); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); if (!A[i][j]) { F[i][j][1 &lt;&lt; cnt++] = 0; } } } int S = (1 &lt;&lt; cnt) - 1; for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { for (int x = s; x; x = (x - 1) &amp; s) { if (F[i][j][x] + F[i][j][s - x] - A[i][j] &lt; F[i][j][s]) { F[i][j][s] = F[i][j][x] + F[i][j][s - x] - A[i][j]; Pre[i][j][s] = (Node) {i, j, x}; } } if (F[i][j][s] &lt; INF) { Que.push((Node) {i, j, 0}); Vis[i][j] = 1; } } } spfa(s); } bool flag = 0; for (int i = 1; i &lt;= N &amp;&amp; !flag; ++i) { for (int j = 1; j &lt;= M; ++j) { if (A[i][j] == 0) { printf(\"%d\\n\", F[i][j][S]); dfs(i, j, S); flag = 1; break; } } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { if (!A[i][j]) { putchar('x'); } else if (Vis[i][j]) { putchar('o'); } else { putchar('_'); } } puts(\"\"); } return 0;}","link":"/BZOJ-2595/"},{"title":"BZOJ 2741【FOTILE模拟赛】L","text":"给定长为 $N$ 的序列 $A[1 \\cdots N]$，$M$ 个询问。查询 $[l,r]$ 的最大异或和子区间，强制在线。 $N\\leq 12000,M\\leq 6000$ 分析可持久化Trie+分块。 记 $s[i]$ 为第 $i$ 块的左端点，$f(i,j)$ 表示$[s[i],r-1]$中的某个点为左端点，右端点为 $r$ 的最大异或子区间。 记 $g(i,j)$ 为$[s[i],r]$ 中的最大异或子区间，则 $g(i,j)=max(g(i,j-1),f(i,j))$。 查询时跨越的完整块直接查 $g$ 数组，剩下的部分在可持久化Trie中查询，取最大值。 复杂度 $O(n\\sqrt{n}\\log{max(A_i)})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;const int MAXN = 12000 + 5;const int MAXM = 40;const int MAXK = 130;int N, M, A[MAXN];struct Trie { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], nT = 1;int insert(int pre, int x) { int rt = ++nT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++nT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int len, n, Belong[MAXN], G[MAXK][MAXN];int queryLR(int l, int r) { int ans = 0, t = r; for (int i = 1; i &lt;= n; ++i) { if ((i - 1) * len + 1 &gt;= l &amp;&amp; (i - 1) * len + 1 &lt;= r) { ans = G[i][r]; t = (i - 1) * len + 1; break; } } for (int i = l; i &lt;= t; ++i) { ans = std::max(ans, query(Rt[l - 1], Rt[r], A[i])); } return ans;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); len = sqrt(N), n = N / len + (N % len &gt; 0); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); A[i] ^= A[i - 1]; Rt[i] = insert(Rt[i - 1], A[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = (i - 1) * len + 1; j &lt;= N; ++j) { G[i][j] = std::max(G[i][j - 1], query(Rt[(i - 1) * len], Rt[j - 1], A[j])); if (i == 1) { G[i][j] = std::max(G[i][j], A[j]); } } } int ans = 0, l, r; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d\", &amp;l, &amp;r); ans %= N; l = (l + ans) % N + 1; r = (r + ans) % N + 1; if (l &gt; r) { std::swap(l, r); } printf(\"%d\\n\", ans = queryLR(l - 1, r)); } return 0;}","link":"/BZOJ-2741/"},{"title":"「HNOI 2012」BZOJ 2733 永无乡","text":"$N$ 个点分别有权值 $W_i$ ，其中有$M$ 条无向边使其分成若干个联通分量。 现有 $Q$ 次操作，分为两类： 查询点$x$ 所在的联通分量中，权值第 $k$ 小的节点编号 合并点 $x,y$ 所在的联通分量 $M\\leq N\\leq 100000,Q\\leq 300000$ 分析动态查询第 $k$ 大，考虑用Treap，Splay等数据结构来维护。 那么如何合并两棵平衡树？通过启发式合并。 说是启发式合并，不过就是暴力合并，把两棵树中较小的一棵的所有节点拆下来插入到较大的那棵中，复杂度 $O(N\\log{N})$。 总复杂度分析，每个点至多被合并 $N$ 次，但是复杂度显然不是 $O(N^2\\log{N})$，其实不大会算… 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;struct Treap { int key, fix, belong, sz; Treap *ch[2]; Treap() { key = INT_MAX, fix = rand(); belong = -1, sz = 1; ch[0] = ch[1] = NULL; } Treap(int x, int y){ key = x, fix = rand(); belong = y, sz = 1; ch[0] = ch[1] = NULL; } int cmp(int x) { return key &lt;= x; } void pushUp() { sz = 1; if(ch[0]) { sz += ch[0]-&gt;sz; } if(ch[1]) { sz += ch[1]-&gt;sz; } }} T[MAXN &lt;&lt; 2];int Belong[MAXN];int cntT;std::vector&lt;Treap*&gt; R;Treap* newTreap(std::pair&lt;int, int&gt; x) { T[++cntT] = Treap(x.first, x.second); return &amp;T[cntT];}void rotate(Treap* &amp;t, int d) { Treap *k = t-&gt;ch[d ^ 1]; t-&gt;ch[d ^ 1] = k-&gt;ch[d]; k-&gt;ch[d] = t; t-&gt;pushUp(); k-&gt;pushUp(); t = k;}void insert(Treap* &amp;t, std::pair&lt;int, int&gt; x) { if(!t) { t = newTreap(x); return ; } int d = t-&gt;cmp(x.first); ++t-&gt;sz; insert(t-&gt;ch[d], x); if(t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix) { rotate(t, d ^ 1); }}int queryKth(Treap* &amp;t, int k) { int num = t-&gt;ch[0] ? t-&gt;ch[0]-&gt;sz : 0; if (k == num + 1) { return t-&gt;belong; } else if(k &lt;= num) { return queryKth(t-&gt;ch[0], k); } else { return queryKth(t-&gt;ch[1], k - num - 1); }}void merge(Treap* &amp;t, Treap* &amp;k, int rt) { if(t-&gt;ch[0]) { merge(t-&gt;ch[0], k, rt); } if(t-&gt;ch[1]) { merge(t-&gt;ch[1], k, rt); } if(t-&gt;belong != -1) { Belong[t-&gt;belong] = rt; insert(k, std::make_pair(t-&gt;key, t-&gt;belong)); }}void mergeTree(int x, int y) { int bx = Belong[x], by = Belong[y]; if(bx != by) { if(R[bx]-&gt;sz &gt; R[by]-&gt;sz) { merge(R[by], R[bx], bx); } else { merge(R[bx], R[by], by); } }}int query(int x, int k) { if(R[Belong[x]]-&gt;sz &lt;= k) { return -1; } return queryKth(R[Belong[x]], k);}int A[MAXN];int main() { int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { A[i] = io::gt&lt;int&gt;(); R.push_back(new Treap); insert(R.back(), std::make_pair(A[i], i)); Belong[i] = SZ(R) - 1; } while(M--) { int x = io::gt&lt;int&gt;(), y = io::gt&lt;int&gt;(); mergeTree(x, y); } int Q = io::gt&lt;int&gt;(); while(Q--) { char opt = io::gc(); while(!isalpha(opt)) { opt = io::gc(); } if(opt == 'Q') { int x = io::gt&lt;int&gt;(), k = io::gt&lt;int&gt;(); io::pt(query(x, k)); } else { mergeTree(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } } io::flush(); return 0;}","link":"/BZOJ-2733/"},{"title":"「中山市选 2009」BZOJ 2465 小球","text":"$n$ 个球放进 $m$ 个瓶子里，每个球有分数$A_i$，每个瓶子有容积 $B_i$，且瓶中球的分数都不能超过 $C_i$，求可放入球的最大数量以及在该条件下的最大分数和。 $1\\leq n\\leq 200,0\\leq m\\leq 200,1 \\leq p\\leq 10^6, 0\\leq c\\leq 200, 1\\leq q\\leq 10^6$ 分析费用流第一看看就是个很裸的费用流，用最大流来保证取的球最多，最小费用来保证总分数最大（分数取反作费用）。 用 $(u,v,f,c)$ 表示一条由 $u$ 到 $v$ 流量限制为 $f$ 费用为 $c$ 的边，那么本题建图方法如下： $(S, i, 1, 0) ,i \\in[1, n]$ $(i,T,B_i,0),i\\in[n+1,n+m]$ $(i,j,1,-A_i),A_i\\leq C_j$ 复杂度 $O(NMF)$，$F$ 为最大流的值。 贪心其实此题更明显的做法应该是贪心。 将球按照分数排序，由于它们空间相同（都是 $1$），因此将分数大的球放到分数限制大的瓶子里一定会放置最多的球。 复杂度 $O(M\\log{M}+N\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt; #define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"ball.in\", \"r\", stdin); freopen(\"ball.out\", \"w\", stdout);} const int MAXN = 400 + 5;const int INF = INT_MAX;int A[MAXN], B[MAXN], C[MAXN]; struct Edge { int v, c, f, nxt;} E[MAXN * MAXN];int N, M, S, T;int cost, flow;int H[MAXN], cntE;int Lp[MAXN], Le[MAXN], Dis[MAXN];std::bitset&lt;MAXN&gt; Inq; void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE;} bool spfa() { static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if (!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;} void buildGraph() { S = N + M + 1, T = N + M + 2; memset(H, -1, sizeof H); cntE = -1; rep(i, 1, N + 1) { addEdge(S, i, 1, 0); } rep(i, 1, M + 1) { addEdge(i + N, T, B[i], 0); } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (::A[i] &lt;= ::C[j]) { addEdge(i, N + j, INF, -::A[i]); } } }} void mcmf() { buildGraph(); cost = flow = 0; while (spfa()) { int f = INF; for (int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } cost += f * Dis[T]; flow += f; for (int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } }} int main() { //open(); while (true) { scanf(\"%d%d\", &amp;N, &amp;M); if (N + M == 0) { break; } rep(i, 1, N + 1) { scanf(\"%d\", &amp;A[i]); } rep(i, 1, M + 1) { scanf(\"%d%d\", &amp;B[i], &amp;C[i]); } mcmf(); printf(\"%d %d\\n\", flow, -cost); } return 0;}","link":"/BZOJ-2465/"},{"title":"「SCOI 2014」BZOJ 3597 方伯伯运椰子","text":"在有向无环图 $G$ 中，每条边的流量与容量相等。现可以修改每条边的容量，使得新的边依然满足流量与容量相等，且总流量不变。已知扩展/缩小每条边容量的单位花费，以及流量通过该边的单位花费。记原总花费 $X$，现在总花费 $Y$（包括修改容量和流量的花费），修改了 $K$ 条边的容量，则收益为 $w=(X-Y)/K$，求$w$的最大值。 $N\\leq 5000$ 分析这道题的核心在于理解“总流量不变且每条边跑满”，可以用网络流的模型理解。 所谓扩容即增广，花费为扩容费用+流量费用；压缩即退流，花费为压缩费用-流量费用。 假设 $a\\geq(X-Y)/K$，则 $Y-X+a\\cdot K\\geq 0$。 而 $Y-X$ 就是增广和退流的费用之和，$K$ 可以分摊到每条边上，即让每条边的权值增加 $K$。 $a$ 显然是可以二分的，那么若新图出现负环，则说明 $a$ 的值不够大，直到得到解为止。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;const int MAXN = 5000 + 5;const double INF = 1e9;const double eps = 1e-4;int N, M;struct Edge { int v; double w; int nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}double Dis[MAXN];bool Vis[MAXN];bool dfs_spfa(int x, double xx) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; double dis = Dis[x] + E[i].w + xx; if (Dis[v] &gt; dis) { Dis[v] = dis; if (Vis[v] || dfs_spfa(v, xx)) { return true; } } } return Vis[x] = 0;}bool check(double a) { for (int i = 1; i &lt;= N; ++i) { Dis[i] = INF; } Dis[N - 1] = 0; memset(Vis, 0, sizeof Vis); for (int i = 1; i &lt;= N; ++i) { if (dfs_spfa(i, a)) { return true; } } return false;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); N += 2; int a, b, c, d, u, v; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d%d%d%d\", &amp;u, &amp;v, &amp;a, &amp;b, &amp;c, &amp;d); if (u == N - 1) { continue; } if (c) { addEdge(v, u, a - d); } addEdge(u, v, b + d); } double l = 0, r = INF, ans; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { ans = l = m; } else { r = m; } } printf(\"%.2lf\\n\", ans); return 0;}","link":"/BZOJ-3597/"},{"title":"「湖南省队训练 2013」BZOJ 3894 文理分科","text":"在 $n\\times m$ 的矩阵中，每个格子可以选择 $0$ 或 $1$，分别获得收益 $A_{i,j}$ 与 $B_{i,j}$。如果一个格子和与它四相邻的格子选择相同，则额外获得收益 $C_{i,j}$ 与 $D_{i,j}$（都选 $0$ 或都选 $1$）。求总收益的最大值。 $n,m\\leq 100,A_{i,j},B_{i,j},C_{i,j},D_{i,j}\\leq 500$ 分析还是二元关系的题目，相比于happiness要复杂一些。 照旧将最大值转化为所有收益-最小割。 建图方法如下： 对于每个点 $x$，割去 $(S,x)$ 表示不选文科，割去 $(x,T)$ 表示不选理科，容量为 $A_x$ 和 $B_x$。 新建点 $a_x,b_x$，表示 $x$ 以及四相邻的点均选择 $0$ 或 $1$。连接 $(S,a_x)$ 和 $(b_x,T)$，容量分别为 $C_x$ 和 $D_x$。 但是可能会出现不合法的情况，即相邻点选择理科，但是又割去 $(b_x,T)$。因此让 $a_x$ 向这五个点（ $x$ 与相邻的四个点）连接一条容量为无穷的边。这就使在这种情况下 $(b_x,T)$ 无法被割去（因为割会经过一条容量为无穷的边，这样的割显然不是最小割）。 同理，让这五个点向 $b_x$ 连接一条容量为无穷的边。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * @Author: Skqliao * @Date: 2019-02-11 22:29:59 * @LastEditTime: 2019-02-11 22:56:26 * @Source: 2013湖南省队集训 * @Problem: 3894: 文理分科 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=3894 */#include &lt;bits/stdc++.h&gt;namespace mxf {const int MAXN = 3 * 100 * 100 + 10;const int MAXM = MAXN * 5;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int S, T;int Cur[MAXN], Dis[MAXN];void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, 0, H[v]}; H[v] = cntE;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow;}} // namespace mxfusing mxf::addEdge;using mxf::S;using mxf::T;const int MAXN = 100 + 5;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;int ans;int Id[MAXN][MAXN];bool judge(int x, int y) { return x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= N &amp;&amp; y &lt;= M; }int main() { int x; scanf(\"%d%d\", &amp;N, &amp;M); mxf::init(N * M * 3); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { Id[i][j] = (i - 1) * M + j; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); ans += x; addEdge(S, Id[i][j], x); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); ans += x; addEdge(Id[i][j], T, x); } } int cur = N * M; for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); ans += x; addEdge(S, ++cur, x); addEdge(cur, Id[i][j], INT_MAX); for (int k = 0; k &lt; 4; ++k) { int x = i + Dicx[k]; int y = j + Dicy[k]; if (judge(x, y)) addEdge(cur, Id[x][y], INT_MAX); } } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); ans += x; addEdge(++cur, T, x); addEdge(Id[i][j], cur, INT_MAX); for (int k = 0; k &lt; 4; ++k) { int x = i + Dicx[k]; int y = j + Dicy[k]; if (judge(x, y)) addEdge(Id[x][y], cur, INT_MAX); } } } printf(\"%d\\n\", ans - mxf::dinic()); return 0;}","link":"/BZOJ-3894/"},{"title":"BZOJ 3261 最大异或和","text":"开始给定一个长为 $N$ 的序列 $A[1\\cdots N]$，有 $M$ 个操作。在 $A$ 的末尾插入 $x$；或者给定 $x,l,r$，查询 $max(x\\oplus A[p]\\oplus\\cdots\\oplus A[N])$，其中$p\\in[l,r]$，$N$为当前序列长度。 $N\\leq 300000,A[i]\\leq 10^7$ 分析维护前缀异或和，令$S[i]=A[1]\\oplus\\dots\\oplus A[i]$，问题转化为查询 $S[N]\\oplus S[p-1]\\oplus x$ 的最大值，其中 $S[N]$ 和 $x$ 都是已知的。 由于是区间问题，可以用可持久化Trie树维护。对于每个新插入的数在01Trie树新建一条链，并将链上所有点的状态+1。通过权值相减来判断区间内是否存在该点，剩下的就是常规01Tire树求异或最大值的操作。 需要注意的一个细节，由于存在插入操作，因此序列中的元素个数最大可能为 $N+M$，需要开两倍空间。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;const int MAXN = 600000 + 5;const int MAXM = 50;struct Node { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], cntT;int N, M;int insert(int pre, int x) { int rt = ++cntT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++cntT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); int cur = 0, x, l, r; char opt[10]; ++N; Rt[1] = insert(Rt[0], 0); for (int i = 2; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); cur ^= x; Rt[i] = insert(Rt[i - 1], cur); } for (int i = 1; i &lt;= M; ++i) { scanf(\"%s\", opt); if (opt[0] == 'A') { scanf(\"%d\", &amp;x); cur ^= x; ++N; Rt[N] = insert(Rt[N - 1], cur); } else { scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); printf(\"%d\\n\", query(Rt[l - 1], Rt[r], x ^ cur)); } } return 0;}","link":"/BZOJ-3261/"},{"title":"「HEOI 2013」BZOJ 3166 Alo","text":"给定长为 $N$ 的序列 $A[1 \\cdots N]$，定义 $F[i,j]$ 为$A[i \\cdots j]$ 的次大值与区间内另一个数异或的最大值。求 $A$ 所有子区间的 $F$ 最大值。 $1\\leq N\\leq 50000, A_i\\leq 10^9$ 分析将问题反过来看，其实就是找到每一个数对应的区间，使得它在区间中是次大值，且区间长度最大。 记$L[i],R[i]$ 为 $A[i]$ 左右第一个比它大的数， $LL[i],RR[i]$ 为 $A[i]$ 左右第二个大的数，那么区间为 $[LL[i]+1,R[i]-1]$ 和 $[L[i]+1,RR[i]-1]$。 可以通过在ST表上二分的方法求出 $LL[i],RR[i]$，复杂度 $O(N\\log{N})$。 最后用可持久化Trie求每个区间与 $A[i]$ 的最大异或值，答案为这些值取max，这一步操作的复杂度为 $O(N\\log{max(A_i)})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;const int MAXN = 50000 + 5;const int MAXM = 40;struct Trie { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], cntT;int insert(int pre, int x) { int rt = ++cntT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++cntT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int N, A[MAXN];int L[MAXN], R[MAXN];int Stk[MAXN], top;int LL[MAXN], RR[MAXN];int bSearch(int x) { int l = 1, r = top; int ans = 0; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (A[Stk[m]] &gt; A[x]) { ans = Stk[m]; l = m + 1; } else { r = m - 1; } } return ans;}int F[MAXN][MAXM];void buildST(int n) { for (int i = 1; i &lt;= n; ++i) { F[i][0] = A[i]; } int k = log2(n); for (int j = 1; j &lt;= k; ++j) { for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) { if (F[i][j - 1] &gt; F[i + (1 &lt;&lt; (j - 1))][j - 1]) { F[i][j] = F[i][j - 1]; } else { F[i][j] = F[i + (1 &lt;&lt; (j - 1))][j - 1]; } } }}int queryMax(int l, int r) { int k = log2(r - l + 1); return std::max(F[l][k], F[r - (1 &lt;&lt; k) + 1][k]);}int getL(int i) { int p = L[i], x = A[i]; int l = 1, r = p - 1, ans = 1; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (queryMax(m, p - 1) &gt; x) { ans = m; l = m + 1; } else { r = m - 1; } } return ans;}int getR(int i) { int p = R[i], x = A[i]; int l = p + 1, r = N + 1, ans = N + 1; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (queryMax(p + 1, m) &gt; x) { ans = m; r = m - 1; } else { l = m + 1; } } return ans;}int main() { scanf(\"%d\", &amp;N); Rt[1] = insert(Rt[0], 0); ++N; for (int i = 2; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); Rt[i] = insert(Rt[i - 1], A[i]); } A[1] = A[N + 1] = INT_MAX; Stk[top = 1] = 1; for (int i = 2; i &lt;= N; ++i) { while (A[Stk[top]] &lt;= A[i]) { --top; } L[i] = Stk[top]; Stk[++top] = i; } Stk[top = 1] = N + 1; for (int i = N; i &gt;= 2; --i) { while (A[Stk[top]] &lt;= A[i]) { --top; } R[i] = Stk[top]; Stk[++top] = i; } buildST(N + 1); for (int i = 2; i &lt;= N; ++i) { LL[i] = getL(i); RR[i] = getR(i); } int ans = 0; for (int i = 2; i &lt;= N; ++i) { if (L[i] == 1 &amp;&amp; R[i] == N + 1) { continue; } ans = std::max(ans, query(Rt[LL[i]], Rt[R[i] - 1], A[i])); ans = std::max(ans, query(Rt[L[i]], Rt[RR[i] - 1], A[i])); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-3166/"},{"title":"「SDOI 2009」BZOJ 1878 HH的项链","text":"在序列 $A[1 \\cdots N]$ 中，有 $M$ 个询问，查询 $[L_i,R_i]$ 中不同的数的个数。 $N\\leq 500000,M\\leq 200000$。 分析原题的数据 $N\\leq 50000$，莫队可以直接 $O(N\\sqrt{N+M})$ 水过。但是数据加强后 $N$ 增大到了原来10倍，带根号的复杂度不再满足要求，考虑一个log的方法。 这道题本质就是查询区间 $[l,r]$ 中不同的数的数目，重点在于处理相同的数。可以显然发现这是不符合区间减法的，因此单纯统计区间中数的出现次数是不行的。 如果同一时间只维护记录所有相同的数中的一个数，那么能保证不会重复统计；如果再保证查询的时候如果这个数存在于区间中，就一定能被查询到，那么就不会保证算少。 如果满足这两条，那么就使得原本查询区间中不同数的个数变成了查询区间中数的个数。 假如查询的区间都是 $[1,R_i]$ ，那么只需要统计同一个数中位置最靠左的那个数是否在 $[1, R_i]$中；如果是 $[L_i,R_i]$ ，同理统计的数就变成了出现位置尽可能接近 $L_i$ 且大于它的那个数是否在 $[L_i,R_i]$ 中。 那么维护方法就很显然了，记录每个数$A[i]$的下一个相同的数的位置 $Nxt[i]$，即满足 $A[i] = A[Nxt[i]]$ 。 随着区间的右移，删去 $A[i]$ 并插入 $A[Nxt[i]]$ ，再统计 $[L_i,R_i]$ 中数的个数。 这样的话查询的区间一定是要求有序的，因此需要离线操作，将所有区间按照左端点排序。 复杂度 $O(M\\log{M}+M\\log{N})$ 。 P.S 参考代码中是按照右端点排序的，操作同理，记录最靠右的数以及它靠前的相同的数的位置即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 500000 + 5;const int MAXM = 1000000 + 5;int N, M, A[MAXN];int Lst[MAXM], Pre[MAXN];int C[MAXN];int lowbit(int x) { return x &amp; -x;}void add(int p, int x) { for(; p &lt; MAXM; p += lowbit(p)) { C[p] += x; }}int query(int p) { int res = 0; for(; p &gt; 0; p -= lowbit(p)) { res += C[p]; } return res;}struct Query { int l, r, id; bool operator &lt; (const Query &amp;x) const { return r &gt; x.r; }} Q[MAXN];int Ans[MAXN];int main() { N = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { A[i] = io::gt&lt;int&gt;(); if(Lst[A[i]] != 0) { add(Lst[A[i]], -1); Pre[i] = Lst[A[i]]; } Lst[A[i]] = i; add(i, 1); } int M = io::gt&lt;int&gt;(); rep(i, 0, M) { Q[i].l = io::gt&lt;int&gt;(); Q[i].r = io::gt&lt;int&gt;(); Q[i].id = i; } std::sort(Q, Q + M); int pre = N; rep(i, 0, M) { while(pre &gt; Q[i].r) { add(pre, -1); if(Pre[pre]) { add(Pre[pre], 1); } pre--; } Ans[Q[i].id] = query(Q[i].r) - query(Q[i].l - 1); pre = Q[i].r; } rep(i, 0, M) { io::pt(Ans[i]); } io::flush(); return 0;}","link":"/BZOJ-1878/"},{"title":"「JLOI 2015」BZOJ 4006 管道连接","text":"无向图中有 $n$ 个 $m$ 条边，边有权值 $W_i$，有 $p$ 个点有编号 $A_i$。现要求选择一些边，使得（有编号且）编号相同的点联通，求最小权值和。 $n\\leq 1000,m\\leq 3000,p\\leq 10$ 分析如果要求所有有编号的点联通，那么这就是一个最小斯坦纳树的模板题。 现在只要求编号相同的点联通，我们可以分别考虑每个编号的点联通的费用，然后组合出最终的答案。 因此依然先求这 $p$ 个点的最小斯坦纳树。然后再用状压DP合并费用，注意合并时（$s=a+b$）， $a,b$ 必须分别完整包含若干个编号的节点，否则不合题意。 复杂度 $O(3^p\\cdot n)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* * @Author: Skqliao * @Date: 2019-01-27 13:24:25 * @LastEditTime: 2019-01-27 14:52:32 * @Source: JLOI 2015 * @Problem: 4006: [JLOI2015]管道连接 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4006 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000 + 2;const int MAXM = 30000 + 5;const int MAXS = 1 &lt;&lt; 12;const int INF = 0x3f3f3f3f;struct Edge { int u, v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int N, M, P;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {v, u, w, H[v]}; H[v] = cntE;}int F[MAXN][MAXS];std::queue&lt;int&gt; Que;bool Vis[MAXN];void spfa(int s) { while (!Que.empty()) { int x = Que.front(); Vis[x] = 0; Que.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (F[x][s] + E[i].w &lt; F[v][s]) { F[v][s] = F[x][s] + E[i].w; if (!Vis[v]) { Que.push(v); Vis[v] = 1; } } } }}int Dp[MAXS];int St[MAXN];std::vector&lt;int&gt; V[MAXN];bool check(int s) { for (int i = 1; i &lt;= 10; ++i) { if (!St[i]) { continue; } if ((St[i] &amp; s) != 0 &amp;&amp; (St[i] &amp; s) != St[i]) { return false; } } return true;}int main() { scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;P); int u, v, w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } memset(F, 0x3f, sizeof F); int p = 0; for (int i = 1; i &lt;= P; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); V[u].push_back(p); F[v][1 &lt;&lt; p++] = 0; } for (int i = 1; i &lt;= 10; ++i) { for (size_t j = 0; j &lt; V[i].size(); ++j) { St[i] |= 1 &lt;&lt; V[i][j]; } } int S = (1 &lt;&lt; p) - 1; memset(Dp, 0x3f, sizeof Dp); for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int x = s; x; x = (x - 1) &amp; s) { F[i][s] = std::min(F[i][s], F[i][x] + F[i][s - x]); } if (F[i][s] &lt; INF) { Que.push(i); } } spfa(s); for (int i = 1; i &lt;= N; ++i) { Dp[s] = std::min(Dp[s], F[i][s]); } } for (int s = 0; s &lt;= S; ++s) { if (check(s)) { for (int x = s; x; x = (x - 1) &amp; s) { if (check(x)) { Dp[s] = std::min(Dp[s], Dp[x] + Dp[s - x]); } } } } printf(\"%d\\n\", Dp[S]); return 0;}","link":"/BZOJ-4006/"},{"title":"「HAOI 2015」BZOJ 4034 树上操作","text":"在一棵有 $N$ 个节点的树上，每个点有初始权值 $W_i$ 。现有 $M$ 个操作，分别为： ADD(u,x) 节点 $u$ 权值增加 $v$ ADD2(u,x)节点 $u$ 的子树的所有节点权值增加 $v$ QUERY(u) 查询节点 $u$ 到根节点($1$)的权值和 $N,M\\leq 100000$，且所有输入数据的绝对值都不会超过 $10^6$ 。 分析树链剖分+线段树模板。 注意需要long long，否则只有30分。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace iostruct Graph { static const int MAXN = 100000 + 5; struct Edge { int v, nxt; } E[MAXN &lt;&lt; 1]; int N, R; int H[MAXN], cntE; int Depth[MAXN], Fa[MAXN], Son[MAXN], Sz[MAXN]; int Dfn[MAXN], Top[MAXN], cntD; int W[MAXN], Wp[MAXN]; void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; } void dfs(int x) { Son[x] = 0, Sz[x] = 1; for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { Fa[v] = x; Depth[v] = Depth[x] + 1; dfs(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } } } void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; W[cntD] = Wp[x]; if(Son[x]) { dfs2(Son[x], top); } for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Son[x] &amp;&amp; v != Fa[x]) { dfs2(v, v); } } }#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, r ll Sum[MAXN &lt;&lt; 2], Add[MAXN &lt;&lt; 2]; void pushUp(int rt) { Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1]; } void pushDown(int rt, int L) { ll &amp;add = Add[rt]; if(!add) { return ; } Sum[rt &lt;&lt; 1] += add * (L - (L &gt;&gt; 1)); Sum[rt &lt;&lt; 1 | 1] += add * (L &gt;&gt; 1); Add[rt &lt;&lt; 1] += add; Add[rt &lt;&lt; 1 | 1] += add; add = 0; } void build(int rt, int l, int r) { if(l == r) { Sum[rt] = W[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt); } void add(int rt, int l, int r, int a, int b, ll x) { if(a &lt;= l &amp;&amp; r &lt;= b) { Sum[rt] += x * (r - l + 1); Add[rt] += x; return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { add(LT, a, b, x); } if(m &lt; b) { add(RT, a, b, x); } pushUp(rt); } ll querySum(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Sum[rt]; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; ll res = 0; if(a &lt;= m) { res += querySum(LT, a, b); } if(m &lt; b) { res += querySum(RT, a, b); } return res; } void addNode(int u, int x) { add(1, 1, N, Dfn[u], Dfn[u], x); } void addTree(int rt, int x) { add(1, 1, N, Dfn[rt], Dfn[rt] + Sz[rt] - 1, x); } ll queryPath(int v) { ll res = 0; int u = R, tu = Top[R], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } res += querySum(1, 1, N, Dfn[tv], Dfn[v]); v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } res += querySum(1, 1, N, Dfn[u], Dfn[v]); return res; } void prepare() { dfs(R); dfs2(R, R); build(1, 1, N); }} G;int main() { G.N = io::gt&lt;int&gt;(); G.R = 1; int M = io::gt&lt;int&gt;(); rep(i, 1, G.N + 1) { G.Wp[i] = io::gt&lt;int&gt;(); } rep(i, 1, G.N) { G.addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } G.prepare(); rep(i, 0, M) { int opt = io::gt&lt;int&gt;(); if(opt == 1) { int u = io::gt&lt;int&gt;(), x = io::gt&lt;int&gt;(); G.addNode(u, x); } else if(opt == 2) { int u = io::gt&lt;int&gt;(), x = io::gt&lt;int&gt;(); G.addTree(u, x); } else { io::pt(G.queryPath(io::gt&lt;int&gt;())); } } io::flush(); return 0;}","link":"/BZOJ-4034/"},{"title":"BZOJ 4260 Codechef REBXOR","text":"对于长为 $N$ 的序列 $A[1\\cdots N]$，求两个不相交区间的异或和之和的最大值。 $2\\leq N\\leq 4\\times 10^5,A[i]\\leq 10^9$ 分析根据异或的性质， 令 $S[i]=A[1]\\oplus A[2]\\cdots \\oplus A[i]$，则$A[l]\\oplus\\cdots \\oplus A[r]=S[r]\\oplus S[l-1]$。 令 $L[i]$ 为 $A[1\\cdots i]$ 中的最大区间异或和， $R[i]$ 为 $A[i\\cdots N]$ 中的最大区间异或和，如此 $L[i],R[i+1]$ 一定不相交，答案为 $max(L[i]+R[i+1])$。 从前往后在01字典树中查询当前前缀异或和 $cur$ 能异或得到的最大值，并将 $cur$插入，则$L[i]=\\max(L[i-1],query(cur))$。 再从后往前插入后缀异或和，则 $R[i]=\\max(R[i+1],query(cur))$。 复杂度 $O(n\\log{n})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;const int MAXN = 4e5 + 5;const int MAXM = 40;struct Node { int sz, num; int ch[2];} T[MAXN * MAXM];int cntT;int N, A[MAXN];int L[MAXN], R[MAXN];void insert(int rt, int x) { for (int i = 32; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (!T[rt].ch[c]) { T[rt].ch[c] = ++cntT; T[cntT].ch[0] = T[cntT].ch[1] = 0; T[cntT].sz = 0; } ++T[rt].sz; rt = T[rt].ch[c]; } T[rt].num = x;}int query(int rt, int x) { for (int i = 32; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (!T[rt].ch[c ^ 1]) { rt = T[rt].ch[c]; } else { rt = T[rt].ch[c ^ 1]; } } return x ^ T[rt].num;}void init() { cntT = 1; T[1].ch[0] = T[1].ch[1] = 0; T[1].sz = T[1].num = 0;}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); } int lst = 0; insert(1, 0); for (int i = 1; i &lt;= N; ++i) { lst ^= A[i]; L[i] = std::max(L[i - 1], query(1, lst)); insert(1, lst); } init(); lst = 0; insert(1, 0); for (int i = N; i &gt;= 1; --i) { lst ^= A[i]; R[i] = std::max(R[i + 1], query(1, lst)); insert(1, lst); } int ans = 0; for (int i = 1; i &lt; N; ++i) { ans = std::max(ans, L[i] + R[i + 1]); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-4260/"},{"title":"「CQOI 2016」BZOJ 4519 不同的最小割","text":"题目大意在无向图 $G$ 中，对于任意点对 $(i,j)$ 有最小割 $cut(i,j)$，求有多少个数值不同的最小割。 $N\\leq 850,M\\leq 8500$ 分析最小割树模板题，求出最小割树后将所有边unique得到答案。 复杂度 $O(n\\times f)$，$f$ 为最大流复杂度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* * @Author: Skqliao * @Date: 2019-02-02 22:26:52 * @LastEditTime: 2019-02-02 22:54:36 * @Source: CQOI 2016 * @Problem: 4519: [Cqoi2016]不同的最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4519 */#include &lt;bits/stdc++.h&gt;const int MAXN = 850 + 5;const int MAXM = 8500 + 5;namespace GH_Tree {struct Edge { int v, f, cap, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Idx[MAXN], Tmp[MAXN];int S, T;int Dis[MAXN], Cur[MAXN];int Col[MAXN];void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; }}void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow;}void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); }}std::vector&lt;int&gt; V;void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); V.push_back(f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r);}int solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); std::sort(V.begin(), V.end()); V.erase(std::unique(V.begin(), V.end()), V.end()); return V.size();}} // namespace GH_Treeint N, M;int main() { scanf(\"%d%d\", &amp;N, &amp;M); printf(\"%d\\n\", GH_Tree::solve(N, M)); return 0;}","link":"/BZOJ-4519/"},{"title":"「TJOI/HEOI2016」BZOJ 4551 树","text":"在有根树 $T$ 中，有两种操作：给某点 $x$ 打标记、查询离某点 $x$ 最近被打标记的祖先，数据范围 $10^6$ 。 $1\\leq N, Q\\leq 100000$ 分析跟【dfs序+线段树】[USACO10FEB]「luogu P2982 Slowing down」 思路相同，反着考虑标记一个点对其他点的影响。 显然标记一个点后会影响以它为根的整棵子树。 那么用线段树维护每个点DFS序后，离它最近的被打标记的祖先。 比较原值和新值的大小关系进行更新操作，易得标号大的点更深（在同一棵子树中）。 复杂度 $O(Q\\log{N})$ 。 P.S 不得不说的是，此题数据水到感人，直接暴力树上走路比线段树快的多。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;struct Edge { int v, nxt;} E[MAXN];int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE;}int Dfn[MAXN], Nfd[MAXN], Sz[MAXN], cntD;void dfs(int x) { Dfn[x] = ++cntD; Nfd[cntD] = x; Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; dfs(v); Sz[x] += Sz[v]; }}int Max[MAXN &lt;&lt; 2], Mrk[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rvoid pushUp(int rt) { if(Max[rt &lt;&lt; 1] == Max[rt &lt;&lt; 1 | 1]) { Max[rt] = Max[rt &lt;&lt; 1]; } else { Max[rt] = -1; }}void pushDown(int rt) { int &amp;mrk = Mrk[rt]; if(mrk) { Mrk[rt &lt;&lt; 1] = std::max(Mrk[rt &lt;&lt; 1], mrk); Mrk[rt &lt;&lt; 1 | 1] = std::max(Mrk[rt &lt;&lt; 1 | 1], mrk); Max[rt &lt;&lt; 1] = std::max(Max[rt &lt;&lt; 1], Max[rt]); Max[rt &lt;&lt; 1 | 1] = std::max(Max[rt &lt;&lt; 1 | 1], Max[rt]); mrk = 0; }}void build(int rt, int l, int r) { if (l == r) { Max[rt] = 1; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void change(int rt, int l, int r, int a, int b, int x) { if(a &lt;= l &amp;&amp; r &lt;= b) { if(Max[rt] &lt;= x) { Max[rt] = x; Mrk[rt] = std::max(x, Max[rt]); } return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { change(LT, a, b, x); } if(m &lt; b) { change(RT, a, b, x); } pushUp(rt);}int query(int rt, int l, int r, int p) { if(l == r) { return Max[rt]; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { return query(LT, p); } else { return query(RT, p); }}int main() { int N = io::gt&lt;int&gt;(), Q = io::gt&lt;int&gt;(); rep(i, 1, N) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); addEdge(u, v); } dfs(1); build(1, 1, N); while(Q--) { char opt = io::gc(); while(!isalpha(opt)) { opt = io::gc(); } int x = io::gt&lt;int&gt;(); if(opt == 'C') { change(1, 1, N, Dfn[x], Dfn[x] + Sz[x] - 1, Dfn[x]); } else { io::pt(Nfd[query(1, 1, N, Dfn[x])]); } } io::flush(); return 0;}","link":"/BZOJ-4551/"},{"title":"「JSOI 2016」BZOJ 4753 最佳团体","text":"每个点有一个父亲，它能被选择当且仅当它父亲被选择，0号节点默认被选择。每个点有收益 $X[i]$，代价 $Y[i]$。选择恰好 $K$ 个点（不算0号），使得其对应的 $\\sum{X[i]}/\\sum{Y[i]}$ 最大。 $N\\leq 2500$ 分析通过分数规划，二分答案来避免除法。 选择关系是一棵树，被选择的点处于一个联通分量。树形背包，转移时父亲被强制选择。 复杂度 $O(NK\\log{X[i]})$ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;const int MAXN = 2500 + 5;const double eps = 1e-4;int N, K;int A[MAXN], B[MAXN], P[MAXN];std::vector&lt;int&gt; G[MAXN];double F[MAXN][MAXN], Tmp[MAXN];int Sz[MAXN];void dfs(int x, double m) { F[x][0] = 0; F[x][1] = B[x] - A[x] * m; Sz[x] = 1; for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; dfs(v, m); memset(Tmp, 0xc2, sizeof Tmp); Tmp[0] = 0; for (int j = 1; j &lt;= Sz[x]; ++j) { for (int k = 0; k &lt;= Sz[v] &amp;&amp; j + k &lt;= K; ++k) { Tmp[j + k] = std::max(Tmp[j + k], F[x][j] + F[v][k]); } } Sz[x] += Sz[v]; memcpy(F[x], Tmp, sizeof Tmp); }}bool check(double m) { memset(F, 0xc2, sizeof F); dfs(0, m); return F[0][K] &gt;= 0;}int main() { scanf(\"%d%d\", &amp;K, &amp;N); ++K; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d%d\", &amp;A[i], &amp;B[i], &amp;P[i]); G[P[i]].push_back(i); } double l = 0, r = 1e4, ans; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { l = ans = m; } else { r = m; } } printf(\"%.3lf\\n\", ans); return 0;}","link":"/BZOJ-4753/"},{"title":"「USACO2018 OPEN」BZOJ 5281 Talent Show","text":"$N$ 个点各有权值 $W_i$ 和 $T_i$，在其中选择任意多个点，在满足 $\\sum{W_i} \\geq A$ 的条件下求 $\\sum{T_i}/\\sum{W_i}$ 的最大值。 $1\\leq N\\leq 250,1\\leq W\\leq 1000,1\\leq W_i\\leq 10^6,1\\leq T_i\\leq 10^3$ 分析套路二分答案 $x$，然后背包求在 $\\sum{W_i}\\geq A$ 的情况下判定 $\\sum{T_i-W_i\\times x}\\geq 0$ 是否成立。 由于答案是 $\\times 1000$ 取整，为了避免浮点数运算，可以直接将 $T_i$ 放大 $1000$ 倍。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;const int MAXN = 250 + 5;const int MAXM = 1000 + 5;int N, M;int A[MAXN], B[MAXN];long long F[MAXM];bool check(int a) { memset(F, 0xc2, sizeof F); long long tmp = F[0]; F[0] = 0; for (int i = 1; i &lt;= N; ++i) { for (int j = M; j &gt;= 0; --j) { if (F[j] != tmp) { int v = std::min(M, j + A[i]); F[v] = std::max(F[v], F[j] - (long long)A[i] * a + B[i]); } } } return F[M] &gt;= 0;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;A[i], &amp;B[i]); B[i] *= 1000; } int l = 0, r = 2e8, ans = 0; while (l &lt;= r) { int m = (l + r) / 2; if (check(m)) { ans = m; l = m + 1; } else { r = m - 1; } } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-5281/"},{"title":"「BJOI 2018」BZOJ 5293 求和","text":"在一棵有 $n$ 个节点，根节点为 $1$ 的树上进行 $m$ 次询问。 每次查询 $(u,v)$ 之间的简单路径的“ $k$ 次深度和”。 $k$ 次深度和即 $\\sum_{i\\in(u,v)}Depth(i)^k$，$Depth(1)=0$。 询问的结果对 $998244353$ 取模。 $1\\leq n,m\\leq 300000,1\\leq k\\leq 50$ 分析首先注意到没有修改操作，只有查询。 其次注意到 $k$ 很小，$k$ 次方可以预处理。 最后注意到每次查询就是一个 $k$ 次的两段连续区间的求和。 记 $lca$ 为 $(u,v)$ 的最近公共祖先。 那么查询的结果即为 $\\sum_{i=Depth(lca)}^{Depth(u)}i^k+\\sum_{i=Depth(lca)+1}^{Depth(v)}i^k$ 预处理 $F_{i,j} = \\sum_{u=0}^{j}u^i$ 则查询的结果为 $F_{k,Depth(v)}-F_{k,Depth(lca)}+F_{k,Depth(u)}-F_{k,Depth(lca)}+Depth(lca)^k$ 对于 $m$ 组 $(u,v)$ 求LCA，树剖、倍增、Tarjan都可以。 如果选择树剖、倍增，复杂度 $O(n\\times k+m\\times \\log{n})$； 如果选择Tarjan，复杂度 $O(n\\times k+m)$。 实测Tarjan常数较大，运行时间相对更长（可能是写渣了）。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEinline char gc() { return getchar();}template &lt;class T&gt; inline T gt() { register T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') {std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst static int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { register char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-'); register bool f = c == '-'; register T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif}const int MAXN = 300000 + 5;const int MOD = 998244353;std::vector&lt;int&gt; G[MAXN];int maxDep;int Fa[MAXN], Sz[MAXN], Depth[MAXN];int Son[MAXN], Top[MAXN];void dfs1(int x) { Sz[x] = 1; if(x == 1) { Depth[x] = 0; } else { Depth[x] = Depth[Fa[x]] + 1; } maxDep = std::max(maxDep, Depth[x]); rep(i, 0, SZ(G[x])) { int &amp;v = G[x][i]; if(Fa[x] != v) { Fa[v] = x; dfs1(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]] || !Son[x]) { Son[x] = v; } } }}void dfs2(int x, int fa) { Top[x] = fa; if(Son[x]) { dfs2(Son[x], fa); } rep(i, 0, SZ(G[x])) { int &amp;v = G[x][i]; if(v != Fa[x] &amp;&amp; v != Son[x]) { dfs2(v, v); } }}int query(int u, int v) { while(Top[u] ^ Top[v]) { if(Depth[Top[u]] &gt; Depth[Top[v]]) { u = Fa[Top[u]]; } else { v = Fa[Top[v]]; } } return Depth[u] &lt; Depth[v] ? u : v;}std::vector&lt;int&gt; Sum[MAXN];ll poww(ll x, ll t) { ll ans = 1; for(; t; t &gt;&gt;= 1, x = x * x % MOD) { if(t &amp; 1) { ans = ans * x % MOD; } } return ans;}void pre() { rep(i, 1, 51) { Sum[i].push_back(0); rep(j, 1, maxDep + 1) { ll cur = (poww(j, i) + Sum[i].back()) % MOD; Sum[i].push_back(cur); } }}int main() { rep(i, 1, io::gt&lt;int&gt;()) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); G[u].push_back(v); G[v].push_back(u); } dfs1(1); dfs2(1, 1); pre(); rep(i, 0, io::gt&lt;int&gt;()) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(), k = io::gt&lt;int&gt;(); int lca = query(u, v); int &amp;depx = Depth[u], &amp;depy = Depth[v]; int &amp;depl = Depth[lca]; int ans = ((Sum[k][depy] - Sum[k][depl] + Sum[k][depx] - Sum[k][depl] + poww(depl, k)) % MOD + MOD) % MOD; io::pt(ans); } io::fflush(); return 0;}","link":"/BZOJ-5293/"},{"title":"「CQOI 2018」BZOJ 5301 异或序列","text":"在序列 $A[1…N]$ 中查询 $M$ 次，每次查询 $A[L_i,R_i]$ 中异或和为 $K$ 的子序列的个数。 $1\\leq N,M\\leq 10^5,0\\leq K, A_i\\leq 105,1\\leq L_i\\leq R_i\\leq N$ 分析记 $A[l…r] = A[l]\\bigoplus A[l+1]\\bigoplus…A[r]$ ，若 $A[1…L-1] = x，A[1….R] = y$ 那么 $A[L…R] = x\\bigoplus y$。 也就是说如果满足 $x\\bigoplus y=k$，那么 $A[L,R]$ 就是一个合法子序列。 考虑增加一个数 $A[x]$ 产生的影响。 记 $Cnt[x]$ 为满足 $A[1…r] = x$ 的 $r$ 的个数，那么区间个数会因此增加 $Cnt[x\\bigoplus K]$ 个，增加的区间分别为 $A[\\min(x,r)+1,\\max(x,r)]$。 删除一个数同理，都是 $O(1)$ 的。 想到莫队算法。 复杂度 $O(M\\log{M} + N\\sqrt{N+M})$ 。 P.S 注意细节，$[l,r]$ 是通过 $[1,r]\\bigoplus[1,l-1]$ 异或得到的，而不是 $[1,l]$ ；想清楚增加/删除一个数时，是先改统计数，还是先改答案。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 1e5 + 5;int Pos[MAXN];struct Query { int l, r, id; bool operator &lt; (const Query &amp;x) const { return Pos[l] == Pos[x.l] ? Pos[x.l] &amp; 1 ? r &gt; x.r : r &lt; x.r : Pos[l] &lt; Pos[x.l]; }} Q[MAXN];int N, M, K;int A[MAXN], Num[MAXN &lt;&lt; 1];int l = 1, r;ll Ans[MAXN], ans;void del(int x) { --Num[A[x]]; ans -= Num[A[x] ^ K];}void add(int x) { ans += Num[A[x] ^ K]; Num[A[x]]++;}int main() { N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(), K = io::gt&lt;int&gt;(); int sz = sqrt(N); rep(i, 1, N + 1) { Pos[i] = i / sz; A[i] = io::gt&lt;int&gt;(); A[i] ^= A[i - 1]; } rep(i, 1, M + 1) { Q[i].l = io::gt&lt;int&gt;(), Q[i].r = io::gt&lt;int&gt;(); Q[i].id = i; } std::sort(Q + 1, Q + M + 1); Num[0] = 1; rep(i, 1, M + 1) { while (l &lt; Q[i].l) { del(l++ - 1); } while (l &gt; Q[i].l) { add(--l - 1); } while (r &lt; Q[i].r) { add(++r); } while (r &gt; Q[i].r) { del(r--); } Ans[Q[i].id] = ans; } rep(i, 1, M + 1) { io::pt(Ans[i]); } io::flush(); return 0;}","link":"/BZOJ-5301/"},{"title":"最小割树学习笔记（Gomory-Hu Tree）","text":"总论在无向图中，最小割树等价于所有点对间的最小割。 对于任意点对 $(s,t)$，它们之间的最小割为最小割树上 $(s,t)$ 路径间的最小边权值。 过程可以通过求 $n-1$ 次最大流构建出具有 $n$ 个点的无向图 $G$ 的最小割树。 具体步骤如下： 任意选择两点 $s,t$ 求两点间最大流 $f$ 得到最小割隔开的两个集合 最小割树上连接 $(s,t)$，边权为 $f$ 将图恢复成最初形态（还原边权） 递归到这两个新集合中，重复操作1，直到集合中只有 $1$ 个点为止 由于每次集合总数增加 $1$，因此一共做 $n-1$ 次以上流程。 Q &amp; AQ1：如何求最小割隔开的两个集合？ A1：由于最小割上的边一定将流量限制流满了，因此从 $s$ 开始，通过未流满流量限制的边遍历到的且在当前集合中的点为与 $s$ 联通的点集合，剩下的点与 $t$ 联通的点集合。 Q2：用什么算法求最大流啊？会被卡吗？ A2：根据相关法律法规，ISAP和Dinic受到保护，应该不会被卡，EK死就死了。当然你愿意写HLPP也不拦着。 用途可以得到任意点对间的最小割，通常用于预处理。 例题 luogu P4897 【模板】最小割树（Gomory-Hu Tree） 【最小割树】[CQOI 2016] BZOJ 4519 不同的最小割 【最小割树】[ZJOI 2011] BZOJ 2229 最小割","link":"/Gomory-Hu-Tree/"},{"title":"「SHOI 2009」BZOJ 2028 会场预约","text":"初始集合为空，有两种操作： 插入一个区间，并删去集合中与它相交的区间，输出删除的区间个数 查询集合中区间个数 $N\\leq 200000,1\\leq Start End\\leq 100000$ 分析首先根据题意，可以得到集合中任意时刻不存在相交的区间。 假设集合中区间是有序的，那么插入一个区间 $[L,R ]$ 后所需要删除的区间一定是连续的。 两个区间 $[l,r]$ 和 $[L,R]$ ($l\\leq L$)如果相交，会有两种情况： $l \\leq L\\leq R\\leq r$ $L\\leq l\\leq r\\leq R$ 总结一下，如果满足 $l\\leq R$ 且 $L\\leq r$ ，那么这两个区间就是相交的。 那么找到第一个满足 $L\\leq r$ 的区间 $[l,r]$ 后，如果再满足 $l\\leq R$ ，就删除 $[l,r]$ ，重复该步骤直到集合为空或者 $R &lt; l$ 。 集合有序，二分寻找 $[l,r]$，删除节点，统计集合大小，STL库提供std::set 可以轻松实现上述功能。 值得注意的是，std::lower_bound(s.begin(),s.end(),x) 和 s.lower_bound(x) 的效率是不同的。由于std::set 的元素存储是随机的，因此直接二分寻找必须考虑寻找元素的复杂度，而它的提供的内置函数可以避免这个问题。 复杂度 $O(N\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace iostruct Node { int l, r; bool operator &lt; (const Node &amp;a) const { return r &lt; a.r; }};std::set&lt;Node&gt; Set;int main() { int N = io::gt&lt;int&gt;(); while (N--) { char opt = io::gc(); while (!isalpha(opt)) { opt = io::gc(); } if (opt == 'A') { int ans = 0; int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); std::set&lt;Node&gt;::iterator p = Set.lower_bound((Node) {0, l}); while (p != Set.end() &amp;&amp; r &gt;= p-&gt;l) { Set.erase(p++); ++ans; } Set.insert((Node) {l, r}); io::pt(ans); } else { io::pt(SZ(Set)); } } io::flush(); return 0;}","link":"/BZOJ-2028/"},{"title":"「SDOI 2017」BZOJ 4819 新生舞会","text":"双方各有 $N$ 个人进行两两配对，$i$ 和 $j$ 配对会获得 $x=A[i][j]$ 的收益和 $y=B[i][j]$ 的代价。最小化 $\\sum{x}/\\sum{y}$。 $N\\leq 100,x,y\\leq 10^4$ 分析若 $\\sum{x}/\\sum{y}\\geq a$，则 $\\sum{x}-a\\cdot\\sum{y} \\geq 0$，再转化变成 $\\sum{x-a\\cdot y}\\geq 0$。 $a$ 显然是可以二分的，然后建图跑最小费用最大流，边权为 $a\\cdot B[i][j]-A[i][j]$，判定合法即总费用是否小于0。 有更快的Dinkelbach算法，考虑用迭代的方式求 $a$。初始化 $a=0$，得到一组合法解后，更新 $a$ 为当前情况下的 $\\sum{x}/\\sum{y}$，直到求得答案。此方法实测比二分快了10倍。 费用流的过程本质就是一个二分图最大权匹配，因此跑KM也是可行的，复杂度上界 $O(\\log{(10^6\\cdot x)}\\cdot n^3)$，实则远远跑不满。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;const int MAXN = 200 + 5;const int MAXM = MAXN * MAXN;const double eps = 1e-7;const double INF = 1e7;int N, A[MAXN][MAXN], B[MAXN][MAXN];struct Edge { int v; double w; int f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w, int f) { E[++cntE] = (Edge) {v, w, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -w, 0, H[v]}; H[v] = cntE;}int S, T;void buildGraph(double x) { memset(H, 0, sizeof H); cntE = 1; S = 0; T = N * 2 + 1; for (int i = 1; i &lt;= N; ++i) { addEdge(S, i, 0, 1); addEdge(i + N, T, 0, 1); for (int j = 1; j &lt;= N; ++j) { addEdge(i, j + N, x * B[i][j] - A[i][j], 1); } }}int Pe[MAXN], Pv[MAXN];double Dis[MAXN];bool Vis[MAXN];struct cmp { inline bool operator () (const int &amp;x, const int &amp;y) const { return Dis[x] &gt; Dis[y]; }};std::priority_queue&lt;int, std::vector&lt;int&gt;, cmp&gt; pq;int spfa(int s, int t) { for (int i = s; i &lt;= t; ++i) { Dis[i] = INF; } memset(Vis, 0, sizeof Vis); Dis[s] = 0, pq.push(s); while (!pq.empty()) { int x = pq.top(); Vis[x] = 0, pq.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &gt; 0 &amp;&amp; Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Pe[v] = i, Pv[v] = x; if (!Vis[v]) { Vis[v] = 1; pq.push(v); } } } } return Dis[t] &lt; INF;}double cost;int flow;double ai, bi;void mcmf(int s, int t) { cost = flow = 0; while (spfa(s, t)) { int f = INF; for (int i = t; i != s; i = Pv[i]) { f = std::min(f, E[Pe[i]].f); } cost += f * Dis[t]; flow += f; for (int i = t; i != s; i = Pv[i]) { E[Pe[i]].f -= f, E[Pe[i] ^ 1].f += f; } } ai = bi = 0; for (int x = 1; x &lt;= N; ++x) { for (int i = H[x]; i; i = E[i].nxt) { if (E[i].f == 0 &amp;&amp; E[i].v &gt; N) { ai += A[x][E[i].v - N]; bi += B[x][E[i].v - N]; break; } } }}bool check(double lim) { buildGraph(lim); mcmf(S, T); return flow == N &amp;&amp; cost &lt; -eps;}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { scanf(\"%d\", &amp;A[i][j]); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { scanf(\"%d\", &amp;B[i][j]); } } double ans = 0; while (check(ans)) { ans = ai / bi; } printf(\"%.6lf\\n\", ans); return 0;}","link":"/BZOJ-4819/"},{"title":"JZOJ 5060 公路建设","text":"有 $n$ 个点， $m$ 条边， $q$ 个询问。每次给定一个区间 $[l_i,r_i]$，求这些边构成的图在保证联通块个数最小的情况下所需最小花费。 $n\\leq 100,m\\leq 100000,q\\leq 15000$ 分析将题意翻译一下就是求区间最小生成树的权值。 假设已知 $[l,m]$ 和 $[m+1,r]$ 的最小生成树，那么 $[l,r]$ 的mst显然是由这两棵mst中的边构成的。 具体地说，在线段树中，通过Kruskal保存子区间mst上的所有边，然后用归并排序合并两个子区间的边，并再做kruskal求出父亲节点的mst上的所有边。查询时按照同样方法合并答案。 复杂度 $O(n\\alpha(n)(m\\log{m}+q\\log{m}))$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 16:40:30 * @LastEditTime: 2019-01-26 17:12:13 * @Source: GDOI2017第二轮模拟day1 * @Problem: JZOJ 5060 公路建设 * @Url: https://jzoj.net/senior/#main/show/5060 */#include &lt;bits/stdc++.h&gt;void open() { freopen(\"highway.in\", \"r\", stdin); freopen(\"highway.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int MAXM = 100000 + 5;int N, M, Q;struct Node { int u, v, w; bool operator &lt; (const Node &amp;x) const { return w &lt; x.w; }} A[MAXM], T[MAXM &lt;&lt; 2][MAXN], Tmp[MAXN &lt;&lt; 1];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Len[MAXM &lt;&lt; 2];int Anc[MAXN];int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) { x = findAnc(x), y = findAnc(y); if (x != y) { Anc[y] = x; return true; } return false;}void pushUp(int x, int l, int r) { int len = std::merge(T[l], T[l] + Len[l], T[r], T[r] + Len[r], Tmp) - Tmp; for (int i = 1; i &lt;= N; ++i) { Anc[i] = i; } Len[x] = 0; for (int i = 0; i &lt; len; ++i) { if (merge(Tmp[i].u, Tmp[i].v)) { T[x][Len[x]++] = Tmp[i]; } }}void build(int rt, int l, int r) { if (l == r) { Len[rt] = 1; T[rt][0] = A[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt, rt &lt;&lt; 1, rt &lt;&lt; 1 | 1);}void query(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { pushUp(0, rt, 0); return ; } int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { query(LT, a, b); } if (m &lt; b) { query(RT, a, b); }}int main() { open(); scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;Q); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;A[i].u, &amp;A[i].v, &amp;A[i].w); } build(1, 1, M); int l, r; while (Q--) { long long sum = 0; scanf(\"%d%d\", &amp;l, &amp;r); Len[0] = 0; query(1, 1, M, l, r); for (int i = 0; i &lt; Len[0]; ++i) { sum += T[0][i].w; } printf(\"%lld\\n\", sum); } return 0;}","link":"/JZOJ-5060/"},{"title":"斯坦纳树学习笔记（Steiner Tree）","text":"总论斯坦纳树可以理解为一棵使得指定点集合联通的树，而最小斯坦纳树在联通的基础上要求边权和最小。（是不是有点类似于最小生成树？） 通常通过状压DP+最短路松弛的方式来解决此类问题。 过程具体过程不妨从一个简单问题出发。 无向图 $G$ 上有 $n$ 个点，选择若干个点使得它们包含点集合 $S={a_1,a_2,\\cdots,a_m}$，且 $S$ 联通。选择点 $i$ 的代价为 $A_i$，求最小代价。 设 $F[i][S]$ 表示集合 $S$ 的点被选择且当前选择节点 $i$ 的最小花费，则 $F[i][S]$ 有两种方式转移，一是枚举子集合并，二是集合内部松弛。 第一种： $F[i][S]=\\min{F[i][T]+F[i][S-T]-A[i]}$，其中 $T$ 是 $S$ 的一个子集。 可以通过 for (int x = S; x; x = (x - 1) &amp; S) 的方式枚举 $S$ 的所有子集 $x$，复杂度 $O(3^m)$。 由于外层还要枚举当前集合状态 $S$ 和当前点 $i$，因此总复杂度为 $n\\cdot 6^m$。 第二种：$F[i][S]=\\min{F[j][S]+A[i]}$，其中点 $i,j$ 联通。 在状压DP后，可以将所有更新过的点push进队列跑SPFA或其他最短路算法完成松弛。 总复杂度 $O(n\\cdot 6^m+2^m\\cdot f)$，$f$ 为最短路复杂度。 用途最小斯坦树可以得到给定点集合所有子集的最小花费，可能会作为预处理使用。 例题 【最小斯坦纳树】[WC 2008] BZOJ 2595 游览计划 【最小斯坦纳树+状压DP】[JLOI 2015] BZOJ 4006 管道连接","link":"/Steiner-Tree/"},{"title":"codeforces 413E Maze 2D","text":"给你一个 $2\\times N$ 的矩阵，你可以上下左右移动，其中’.’可以走，’X’不能走。$M$ 个询问，问任意两点间距离。 $1\\leq N,M\\leq 2\\times 10^5$ 分析对于所有 $2\\times 2$ 的子矩阵，维护左上到右上、右下，左下到右上、右下所需要的步数。 建立线段树，发现两个中间重叠的子矩阵可以合并信息，得到最左边一列到最右边一列所需的最小步数。 每次将结果（一个子矩阵）对应那两个查询格子的相对位置，步数超出 $2\\times N$ 意味着无解。 复杂度 $O(M\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 2e5 + 5;const int INF = 0x3f3f3f3f;char S[2][MAXN];int N, Q;struct Segment { int A[2][2];} T[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rSegment merge(Segment x, Segment y) { Segment tmp; tmp.A[0][0] = std::min(INF, std::min(x.A[0][0] + y.A[0][0], x.A[0][1] + y.A[1][0])); tmp.A[1][0] = std::min(INF, std::min(x.A[1][1] + y.A[1][0], x.A[1][0] + y.A[0][0])); tmp.A[0][1] = std::min(INF, std::min(x.A[0][0] + y.A[0][1], x.A[0][1] + y.A[1][1])); tmp.A[1][1] = std::min(INF, std::min(x.A[1][0] + y.A[0][1], x.A[1][1] + y.A[1][1])); return tmp;}void build(int rt, int l, int r) { if (l == r) { Segment &amp;x = T[rt]; memset(x.A, 0x3f, sizeof x.A); if (S[0][l] == '.' &amp;&amp; S[1][l] == 'X') { x.A[0][0] = 1; } else if (S[0][l] == 'X' &amp;&amp; S[1][l] == '.') { x.A[1][1] = 1; } else if (S[0][l] == '.' &amp;&amp; S[1][l] == '.') { x.A[0][0] = x.A[1][1] = 1; x.A[0][1] = x.A[1][0] = 2; } return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); T[rt] = merge(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}Segment querySum(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt]; } int m = (l + r) &gt;&gt; 1; if (b &lt;= m) { return querySum(LT, a, b); } else if (m &lt; a) { return querySum(RT, a, b); } else { return merge(querySum(LT, a, b), querySum(RT, a, b)); }}int query(int x, int y) { int a = x, b = y, fa = 0, fb = 0; if (x &gt; N) { fa = 1; a = x - N; } if (y &gt; N) { fb = 1; b = y - N; } if(a &gt; b) { std::swap(a, b); std::swap(fa, fb); } return querySum(1, 1, N, a, b).A[fa][fb] - 1;}int main() { int x, y; scanf(\"%d%d%s%s\", &amp;N, &amp;Q, S[0] + 1, S[1] + 1); build(1, 1, N); while (Q--) { scanf(\"%d%d\", &amp;x, &amp;y); int res = query(x, y); printf(\"%d\\n\", res &lt;= 2 * N ? res : -1); } return 0;}","link":"/codeforces-413E/"},{"title":"codeforces 280D k-Maximum Subsequence Sum","text":"序列 $A[1…N]$ 中进行 $M$ 次操作，分为两种： 将 $A[p]$ 修改为 $x$ 查询 $A[l,r]$ 中不相交至多 $K$ 个不相交子段的和的最大值。 $N,M\\leq 10^5, K\\leq 20$ 分析对于第二个询问，有个很熟悉的网络流模型，最小费用最大流。 但是对于每个询问都重新建图跑网络流显然是会超时的，需要优化。 网络流的流程就是每次增广最大的费用，然后将这些边取反变成反向边，继续增广，直到费用为负或者没有流量为止。 那么考虑手动模拟它，即每次找到区间中和最大的字段，统计贡献后将其取反，继续直到最大和为负数，或者完成 $k$ 次为止。 这种区间打标记，区间求最值的操作，让人联想到线段树。 用线段树维护区间中子段的最大/最小和（因为取反后两者就交换了），以及左右最大子段（用来合并）的值和对应子段的左右端点，以及取反标记。 查询时记录所有被取反的区间，结束时再将其恢复。 复杂度 $O(M\\times K\\times log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define All(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 1e5 + 5;struct Line { int l, r, s; Line(int l = 0, int r = 0, int s = 0): l(l), r(r), s(s) {} Line operator + (const Line &amp;x) { return (Line) {l, x.r, s + x.s}; } bool operator &lt; (const Line &amp;x) const { return s &lt; x.s; }};struct Node { Line lMax, lMin, rMax, rMin, vMax, vMin, v; int rev; Node (int l = 0, int r = 0, int s = 0) { lMax = lMin = rMax = rMin = vMax = vMin = v = Line(l, r, s); rev = 0; } void pushUp(Node ls, Node rs) { if (ls.lMax.l == 0) { *this = rs; return; } lMax = std::max(ls.lMax, ls.v + rs.lMax); lMin = std::min(ls.lMin, ls.v + rs.lMin); rMax = std::max(ls.rMax + rs.v, rs.rMax); rMin = std::min(ls.rMin + rs.v, rs.rMin); vMax = std::max(ls.rMax, rs.lMax); vMax = std::max(vMax, std::max(ls.vMax, rs.vMax)); vMax = std::max(vMax, ls.rMax + rs.lMax); vMax = std::max(vMax, std::max(lMax, rMax)); vMin = std::min(ls.rMin, rs.lMin); vMin = std::min(vMin, std::min(ls.vMin, rs.vMin)); vMin = std::min(vMin, ls.rMin + rs.lMin); vMin = std::min(vMin, std::min(lMin, rMin)); v = ls.v + rs.v; }} T[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rvoid rev(Node&amp; x) { x.rev ^= 1; std::swap(x.lMin, x.lMax); std::swap(x.rMin, x.rMax); std::swap(x.vMin, x.vMax); x.lMin.s *= -1, x.lMax.s *= -1; x.rMin.s *= -1, x.rMax.s *= -1; x.vMin.s *= -1, x.vMax.s *= -1; x.v.s *= -1;}void pushDown(int rt) { if(T[rt].rev) { rev(T[rt &lt;&lt; 1]); rev(T[rt &lt;&lt; 1 | 1]); T[rt].rev = 0; }}void build(int rt, int l, int r) { if (l == r) { T[rt] = Node(l, r, io::gt&lt;int&gt;()); return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); T[rt].pushUp(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}void modify(int rt, int l, int r, int p, int x) { if(l == r) { T[rt] = Node(l, r, x); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { modify(LT, p, x); } else { modify(RT, p, x); } T[rt].pushUp(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}void reverse(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { rev(T[rt]); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { reverse(LT, a, b); } if(m &lt; b) { reverse(RT, a, b); } T[rt].pushUp(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}Node queryMax(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return T[rt]; } pushDown(rt); int m = (l + r) &gt;&gt; 1; Node res; if(a &lt;= m) { res.pushUp(res, queryMax(LT, a, b)); } if(m &lt; b) { res.pushUp(res, queryMax(RT, a, b)); } return res;}int main() { int N = io::gt&lt;int&gt;(); build(1, 1, N); int M = io::gt&lt;int&gt;(); std::vector&lt;Line&gt; V; while(M--) { int opt = io::gt&lt;int&gt;(); if(opt == 0) { int p = io::gt&lt;int&gt;(), x = io::gt&lt;int&gt;(); modify(1, 1, N, p, x); } else { int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(), k = io::gt&lt;int&gt;(); int sum = 0; V.clear(); rep(i, 0, k) { Line x = queryMax(1, 1, N, l, r).vMax; if(x.s &lt; 0) { break; } sum += x.s; V.push_back(x); reverse(1, 1, N, x.l, x.r); } io::pt(sum); rep(i, 0, SZ(V)) { reverse(1, 1, N, V[i].l, V[i].r); } } } io::flush(); return 0;}","link":"/codeforces-280D/"},{"title":"codeforces 145E Lucky Queries","text":"长度为 $N$ 的 $01$ 序列$A$有$M$次操作，每次将 $A[l,r]$ 中的每个数异或 $1$，或查询$A$ 的最长不下降子序列的长度。 $1 \\leq N\\leq 10^6, 1\\leq M\\leq 3\\times 10^5$ 分析由于序列中只有 $0$ 和 $1$ ，因此最长不下降子序列只有两种情况：都是$0$或$1$，或者前面都是 $0$ 后面都是 $1$ 。 用线段树维护区间中完全由 $0$ 与 $1$ 组成，以及最长不上升与不下降子序列的长度， 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).sizo())typedef long long ll;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0;}template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0;}const int MAXN = 1e6 + 5;int N, M;char Str[MAXN];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rstruct Node { int zero, one, up, down, mrk; Node () { zero = one = up = down = mrk = 0; } Node (int a, int b, int c, int d) : zero(a), one(b), up(c), down(d), mrk(0) {} Node operator + (const Node &amp;x) { Node y; y.zero = zero + x.zero; y.one = one + x.one; y.up = std::max(up + x.one, zero + x.up); y.down = std::max(down + x.zero, one + x.down); y.mrk = 0; return y; } void swap() { mrk ^= 1; std::swap(zero, one); std::swap(up, down); }} T[MAXN &lt;&lt; 2];void pushUp(int rt) { T[rt] = T[rt &lt;&lt; 1] + T[rt &lt;&lt; 1 | 1];}void pushDown(int rt) { if (T[rt].mrk) { T[rt &lt;&lt; 1].swap(); T[rt &lt;&lt; 1 | 1].swap(); T[rt].mrk = 0; }}void build(int rt, int l, int r) { if (l == r) { if (Str[l] == '4') { T[rt] = (Node) { 1, 0, 1, 1 }; } else { T[rt] = (Node) { 0, 1, 1, 1 }; } return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void change(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { T[rt].swap(); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { change(LT, a, b); } if (m &lt; b) { change(RT, a, b); } pushUp(rt);}Node queryMax(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt]; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &gt; m) { return queryMax(RT, a, b); } else if (b &lt;= m) { return queryMax(LT, a, b); } else { return queryMax(LT, a, b) + queryMax(RT, a, b); }}int main() { int N, M, l, r; scanf(\"%d%d%s\", &amp;N, &amp;M, Str + 1); build(1, 1, N); while (M--) { scanf(\"%s\", Str); if (Str[0] == 'c') { Node res = queryMax(1, 1, N, 1, N); printf(\"%d\\n\", res.up); } else { scanf(\"%d%d\", &amp;l, &amp;r); change(1, 1, N, l, r); } } return 0;}","link":"/codeforces-145E/"},{"title":"「HNOI 2002」BZOJ 1588 营业额统计","text":"给定长为 $N$ 的序列 $A$，最小化 $total = A_1+\\sum\\limits_{i=2}^{N}{|A_i-A_j|}(j &lt; i)$ 。 $N\\leq 32767, A_i\\leq 1000000$ 分析用一棵可以查询前驱后继的Treap/Splay等数据结构维护。 每次查询 $A_i$ 的前驱后继，取与 $A_i$ 的差较小的值计入 $total$，然后将 $A_i$ 插入。 复杂度 $O(N\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 32767 + 5;const int INF = 1e9;struct TreapTree { struct Treap { int key, fix; int cnt, sz; Treap *ch[2]; void pushUp() { sz = cnt; if (ch[0]) { sz += ch[0]-&gt;sz; } if (ch[1]) { sz += ch[1]-&gt;sz; } } int cmp(int x) { return key == x ? -1 : key &lt; x; } } Pool[MAXN], *R; int cntP; Treap* newTreap(int x) { Pool[++cntP] = (Treap) {x, rand(), 1, 1, NULL, NULL}; return &amp;Pool[cntP]; } void rotate(Treap* &amp;t, int d) { Treap *k = t-&gt;ch[d ^ 1]; t-&gt;ch[d ^ 1] = k-&gt;ch[d]; k-&gt;ch[d] = t; t-&gt;pushUp(); k-&gt;pushUp(); t = k; } void insert(Treap* &amp;t, int x) { if (!t) { t = newTreap(x); return ; } int d = t-&gt;cmp(x); ++t-&gt;sz; if (d == -1) { ++t-&gt;cnt; } else { insert(t-&gt;ch[d], x); if (t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix) { rotate(t, d ^ 1); } } } int res; void queryPre(Treap* &amp;t, int x) { if (!t) { return ; } if (t-&gt;key &lt;= x) { res = t-&gt;key; queryPre(t-&gt;ch[1], x); } else { queryPre(t-&gt;ch[0], x); } } void querySub(Treap* &amp;t, int x) { if (!t) { return ; } if (t-&gt;key &gt;= x) { res = t-&gt;key; querySub(t-&gt;ch[0], x); } else { querySub(t-&gt;ch[1], x); } }} T;int main() { int N = io::gt&lt;int&gt;(); int res = io::gt&lt;int&gt;(); T.insert(T.R, res); rep(i, 2, N + 1) { int x = io::gt&lt;int&gt;(); T.res = -1; T.queryPre(T.R, x); int pre = T.res != -1 ? T.res : -INF; T.res = -1; T.querySub(T.R, x); int sub = T.res != -1 ? T.res : INF; res += std::min(x - pre, sub - x); T.insert(T.R, x); } printf(\"%d\\n\", res); return 0;}","link":"/BZOJ-1588/"},{"title":"「HAOI 2015」BZOJ 4033 树上染色","text":"有一棵点数为 $N$ 的树，树边有边权。给你一个在 $0$ ~ $N$ 之内的正整数 $K$ ，你要在这棵树中选择 $K$ 个点，将其染成黑色，并将其他的 $N-K$ 个点染成白色 。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的受益。问受益最大值是多少。 $0\\leq K\\leq N\\leq 2000$ 分析感觉就是一道联赛难度的树形DP，思路很simple。 枚举当前节点的某个儿子作为根的子树中染成黑色的节点数目，如此该子树内、外各自的黑白节点个数就已知了，可以计算当前这条边（当前节点和该儿子相连的边）对答案的贡献，进行类似01背包的操作。 计算复杂度的话，复杂度上界为 $\\sum\\limits_{x=1}^{N}{\\sum\\limits_{u,v\\in Son[x]}{Sz[u]\\times Sz[v]}}$ 。$Sz[u]\\times Sz[v]$ 可以将其视作从以 $x$ 为根的子树中任意选择两个点，使得它们的LCA是 $x$ 的方案数。由于每个节点对只有一个最近公共祖先，因此它就是在树上选取节点对的方案数，即 $N^2$ 。 复杂度 $O(N^2)$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 2000 + 5;struct Edge { int v, w, nxt;} E[MAXN &lt;&lt; 1];int N, K;int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, w, H[v]}; H[v] = cntE;}ll F[MAXN][MAXN];int Sz[MAXN];void dfs(int x, int fa) { Sz[x] = 1; memset(F[x], -1, sizeof F[x]); F[x][0] = F[x][1] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v == fa) { continue; } dfs(v, x); Sz[x] += Sz[v]; } for (int e = H[x]; e; e = E[e].nxt) { int &amp;v = E[e].v, &amp;w = E[e].w; if (v == fa) { continue; } rof(i, std::min(Sz[x], K) + 1, 0) { rep(j, 0, std::min(Sz[v], i) + 1) { if (F[x][i - j] != -1) { ll val = 1ll * w * (j * (K - j) + (Sz[v] - j) * (N - Sz[v] - K + j)); F[x][i] = std::max(F[x][i], F[x][i - j] + F[v][j] + val); } } } }}int main() { int u, v, w; scanf(\"%d%d\", &amp;N, &amp;K); rep(i, 1, N) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } dfs(1, 0); printf(\"%lld\\n\", F[1][K]); return 0;}","link":"/BZOJ-4033/"},{"title":"「SCOI 2012」BZOJ 2753 滑雪与时间胶囊","text":"有 $N$ 个点，每个点存在权值 $H_i$ 。有 $M$ 条边 $(u, v, w)$ ，如果 $H_u &lt; H_v$ ，那么这条边就是 $u\\rightarrow v$ ，反之是 $v \\rightarrow u$ 的。如果 $H_u = H_v$ ，那么这是一条无向边。 求以 $1$ 为根节点的生成树的最大节点个数，以及在节点数最大的情况下的最小权值和。 $1\\leq N\\leq 10^5,1\\leq M\\leq 10^ 6,1\\leq H_i\\leq 10^9$ 分析最小树形图如果不看数据范围，这是一个裸的最小树形图（无向边拆成两条有向边）。 先用bfs跑一遍可以得到节点 $1$ 可以到达的所有点，即第一问。复杂度 $O(N)$。 然后重新构图，使用朱刘算法在新图上求最小树形图的权值和。复杂度 $O(N\\times M)$ 。 这个上界很松，而且发现时间瓶颈很大程度在读入 3e6 的数据上。 随机数据应该是远远跑不满的，而且也没有听说专门卡它的构造数据方法。 最后提交发现该代码在BZOJ和luogu的评测机上均能通过。 BZOJ上此题时限50s，实测39.3s，并不算卡过去的。 最小生成树实际上刚看到这个数据范围，给我的第一感觉是：“就算上界很松也肯定跑不过啊……”。 但是求有向图的最小树形图，朱刘算法已经是很高效的了。 虽然存在 R.E.Tarjan 在1986年提出的 $O(E+V\\log{V})$ 的改进算法，但是国内基本没有相关资料。 看来出题人考不存在的（没见过=不存在）改进算法的几率不大。 相比于最小树形图，求无向图的最小生成树就有很好写，而且复杂度更低的算法。 例如 Prim's algorithm （复杂度 $O(V\\times \\log{V}$ ）和 Kruskal's algorithm （复杂度 $O(E\\times \\log{E})$）。 再思考为什么有向图求最小树形图的时候不能用它们，是因为最后可能会出现边指向根节点的情况，这样就不是一棵生成树了。 对于这道题而言，发现反向边只会在 $H_u=H_v$ 的时候出现。 假如可以处理掉它，那么模型就从最小树形图转化成最小生成树，复杂度也就足够优秀了。 根据这道题节点间的特殊性质，对于一棵生成树的任意节点所有可能的父亲节点，权值一定都大于等于它。 那么对于有向边 $(u, v, w)$ ，优先处理 $H_v$ 大的边， $H_v$ 相同时优先选择 $w$ 小的边，就能保证不会出现反向边。 如果生成树 $T1$ 中某节点 $y$ 通过边 $(x,y,w)$ 合并到另一个生成树 $T2$ 的节点 $x$ 上，那么就会出现反向边（即边 $(y,x,w)$）。 但是这是不会发生的，因为如果出现两棵生成树，那么图就不存在生成树了（ 已经经过了所有以 $T2$ 根节点为终点的边，既然没有与 $T1$ 合并，就说明无法合并了。而这是与第一问得到的都联通情况相违背） 因此通过 Kruskal's algorithm 求最小生成树是正确的，求得权值和即为第二问答案。 参考代码最小树形图 - Chu-Liu/Edmonds’ algorithm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 1e5 + 5;const int MAXM = 1e6 + 5;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif} // namespace iostruct Graph { struct Edge { int u, v, w; }; int N; std::vector&lt;Edge&gt; E; void init(int n) { N = n; E.clear(); } void addEdge(int u, int v, int w) { E.push_back((Edge) {u, v, w}); } ll MST_Directed(int rt) { static int Pre[MAXN], Cir[MAXN], Id[MAXN]; static ll Inw[MAXN]; ll ans = 0; while(true) { memset(Inw, 127 / 3, sizeof(ll) * N); memset(Pre, -1, sizeof(int) * N); memset(Cir, -1, sizeof(int) * N); memset(Id, -1, sizeof(int) * N); ll INF = Inw[0]; rep(i, 0, SZ(E)) { if(Inw[E[i].v] &gt; E[i].w &amp;&amp; E[i].v != E[i].u) { Inw[E[i].v] = E[i].w; Pre[E[i].v] = E[i].u; } } Pre[rt] = rt, Inw[rt] = 0; rep(i, 0, N) { if(Inw[i] == INF) { return -1; } ans += Inw[i]; } int circle = 0; rep(i, 0, N) { if(Cir[i] != -1) { continue; } int t = i; while(Cir[t] == -1) { Cir[t] = i; t = Pre[t]; } if(t != rt &amp;&amp; Cir[t] == i) { Id[t] = circle++; for(int j = Pre[t]; j != t; j = Pre[j]) { Id[j] = circle - 1; } } } if(!circle) { return ans; } rep(i, 0, N) { if(Id[i] == -1) { Id[i] = circle++; } } rep(i, 0, SZ(E)) { E[i].w -= Inw[E[i].v]; E[i].u = Id[E[i].u]; E[i].v = Id[E[i].v]; } N = circle; rt = Id[rt]; } }}G;int H[MAXN], Id[MAXN];struct Graph2 { struct Edge { int v, nxt; }E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; void init(int n) { memset(H, -1, sizeof(int) * n); cntE = -1; } void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; } int bfs(int x) { static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; static std::bitset&lt;MAXN&gt; Vis; int n = 1; Id[x] = n++; Vis[x] = 1; Que.push(x); while(!Que.empty()) { int x = Que.front(); Que.pop(); for(int i = H[x]; ~i; i = E[i].nxt) { if(!Vis[E[i].v]) { Que.push(E[i].v); Vis[E[i].v] = 1; Id[E[i].v] = n++; } } } return n; }}G2;int U[MAXM], V[MAXM], W[MAXM];int main() { int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { H[i] = io::gt&lt;int&gt;(); } G2.init(N + 1); rep(i, 0, M) { U[i] = io::gt&lt;int&gt;(); V[i] = io::gt&lt;int&gt;(); W[i] = io::gt&lt;int&gt;(); if(H[U[i]] &gt;= H[V[i]]) { G2.addEdge(U[i], V[i]); } if(H[U[i]] &lt;= H[V[i]]) { G2.addEdge(V[i], U[i]); } } int n = G2.bfs(1); rep(i, 0, M) { if(Id[U[i]] &amp;&amp; Id[V[i]]) { if(H[U[i]] &gt;= H[V[i]]) { G.addEdge(Id[U[i]], Id[V[i]], W[i]); } if(H[V[i]] &gt;= H[U[i]]) { G.addEdge(Id[V[i]], Id[U[i]], W[i]); } } } G.addEdge(0, Id[1], 0); G.N = n; ll ans = G.MST_Directed(0); printf(\"%d %lld\\n\", n - 1, ans); return 0;} 最小生成树 - Kruskal’s algorithm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif} // namespace ioconst int MAXN = 1e5 + 5;const int MAXM = 1e6 + 5;int H[MAXN];struct Graph { struct Edge { int u, v, w, nxt, can; bool operator &lt; (const Edge &amp;x) const { return ::H[v] != ::H[x.v] ? ::H[v] &gt; ::H[x.v] : w &lt; x.w; } }E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; int Fa[MAXN], Rank[MAXN]; void init(int n) { memset(H, -1, sizeof(int) * n); cntE = -1; rep(i, 0, n) { Fa[i] = i; Rank[i] = 1; } } void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u], 0}; H[u] = cntE; } int bfs(int x) { static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; static std::bitset&lt;MAXN&gt; Vis; int n = 1; Vis[x] = 1; Que.push(x); while(!Que.empty()) { int x = Que.front(); Que.pop(); for(int i = H[x]; ~i; i = E[i].nxt) { E[i].can = 1; if(!Vis[E[i].v]) { Que.push(E[i].v); Vis[E[i].v] = 1; n++; } } } return n; } int findFa(int x) { return x == Fa[x] ? x : Fa[x] = findFa(Fa[x]); } bool merge(int u, int v) { u = findFa(u), v = findFa(v); if(u == v) { return false; } if(Rank[u] &lt; Rank[v]) { Fa[u] = v; } else { Fa[v] = u; if(Rank[u] == Rank[v]) { Rank[u]++; } } return true; } ll kruskal(int n) { ll ans = 0; int k = 1; static std::vector&lt;Edge&gt; V; rep(i, 0, cntE + 1) { if(E[i].can) { V.push_back(E[i]); } } std::sort(ALL(V)); rep(i, 0, SZ(V)) { if(k == n) { return ans; } if(merge(V[i].u, V[i].v)) { ans += V[i].w; ++k; } } }}G;int main() { int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { H[i] = io::gt&lt;int&gt;(); } G.init(N + 1); rep(i, 0, M) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(), w = io::gt&lt;int&gt;(); if(H[u] &gt;= H[v]) { G.addEdge(u, v, w); } if(H[u] &lt;= H[v]) { G.addEdge(v, u, w); } } int n = G.bfs(1); ll sum = G.kruskal(n); printf(\"%d %lld\\n\", n, sum); return 0;} 参考资料【最小树形图】——bzoj2753——朱刘算法达不到复杂度要求时的，改模板kruskal算法","link":"/BZOJ-2753/"},{"title":"「JLOI 2014」BZOJ 3631 松鼠的新家","text":"一棵树有 $N$ 个节点，需要按照 $A[1…N]$ 的顺序依次访问，每次走最短路径。 求每个节点各经过多少次。 $2\\leq N\\leq 300000$ 分析树上差分从 $u$ 到 $v$ 的路径即 $u\\rightarrow lca(u,v)\\rightarrow v$ 。 由于只需要输出一次，考虑树上差分。 $O(1)$ 修改， $O(N)$ 查询的复杂度在这里正合适。 用Tarjan或者其他lca算法得到 $lca(A[i],A[i+1])$ ，然后对两段路径进行差分。 最后将除了根节点的每个节点经过次数-1，因为它们在差分的过程中既被当成前一条路径终点，又被当作后一条路径的起点，重复计算两次。 复杂度 $O(N)$ 。 树状数组树链剖分+区间修改/单点查询树状数组。 复杂度 $O(N\\log^2{N})$ 。 参考代码树上差分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; void pt(T x, char c = '\\n') { static int S[20], *vp; vp = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++vp = x % 10, x /= 10; } while (x); while (vp != S) { *cur++ = *vp-- + '0'; } *cur++ = c; if (cur &gt;= end) { fflush(); }}#endif} // namespace ioconst int MAXN = 300000 + 5;int Faa[MAXN], Lca[MAXN];int H[MAXN], cnt;int N, R;int Fa[MAXN], Add[MAXN];struct Edge { int v, nxt;} Q[MAXN &lt;&lt; 1], E[MAXN &lt;&lt; 1];int H2[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; return ;}void addQuery(int u, int v) { Q[cnt] = (Edge) {v, H2[u]}; H2[u] = cnt++; Q[cnt] = (Edge) {u, H2[v]}; H2[v] = cnt++; return ;}int findFa(int x) { return Faa[x] == x ? x : Faa[x] = findFa(Faa[x]);}void dfs(int x) { Faa[x] = x; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; dfs(v); Faa[v] = x; } } for (int i = H2[x]; ~i; i = Q[i].nxt) { int &amp;v = Q[i].v; if (Fa[v]) { Lca[i &gt;&gt; 1] = findFa(v); } }}void dfs2(int x) { for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { dfs2(v); Add[x] += Add[v]; } }}int A[MAXN];int main() { N = io::gt&lt;int&gt;(); memset(H2, -1, sizeof H2); rep(i, 1, N + 1) { A[i] = io::gt&lt;int&gt;(); } R = A[1]; rep(i, 2, N + 1) { addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); addQuery(A[i - 1], A[i]); } dfs(R); rep(i, 2, N + 1) { ++Add[A[i - 1]]; ++Add[A[i]]; --Add[Lca[i - 2]]; --Add[Fa[Lca[i - 2]]]; } dfs2(R); ++Add[R]; rep(i, 1, N + 1) { io::pt(Add[i] - 1); } io::fflush(); return 0;} 树状数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { fflush(); }}#endif} // namespace ioconst int MAXN = 300000 + 5;int A[MAXN];struct Graph { struct Edge { int v, nxt; } E[MAXN &lt;&lt; 1]; int N, R; int H[MAXN], cntE; int Depth[MAXN], Sz[MAXN], Son[MAXN], Fa[MAXN]; int Dfn[MAXN], cntD, Top[MAXN]; int C[MAXN]; void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; } void dfs(int x) { Sz[x] = 1, Son[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; Depth[v] = Depth[x] + 1; dfs(v); Sz[x] += Sz[v]; if (Sz[Son[x]] &lt; Sz[v]) { Son[x] = v; } } } } void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; if (Son[x]) { dfs2(Son[x], top); } for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x] &amp;&amp; v != Son[x]) { dfs2(v, v); } } } int lowbit(int x) { return x &amp; -x; } void update(int A[], int p, int x) { for (; p &lt;= N; p += lowbit(p)) { A[p] += x; } } void add(int l, int r, int x) { update(C, l, x); update(C, r + 1, -x); } int sum(int A[], int p) { int res = 0; for (; p &gt; 0; p -= lowbit(p)) { res += A[p]; } return res; } int query(int x) { return sum(C, x); } void prepare() { dfs(R); dfs2(R, R); } void addPath(int u, int v, int x = 1) { int tu = Top[u], tv = Top[v]; while (tu != tv) { if (Depth[tu] &gt; Depth[tv]) { std::swap(u, v); std::swap(tu, tv); } add(Dfn[tv], Dfn[v], x); v = Fa[tv]; tv = Top[v]; } if (Depth[u] &gt; Depth[v]) { std::swap(u, v); } add(Dfn[u], Dfn[v], x); }} G;int main() { G.N = io::gt&lt;int&gt;(); rep(i, 1, G.N + 1) { A[i] = io::gt&lt;int&gt;(); } G.R = A[1]; rep(i, 1, G.N) { G.addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } G.prepare(); rep(i, 2, G.N + 1) { G.addPath(A[i], A[i - 1]); } G.add(G.Dfn[A[1]], G.Dfn[A[1]], 1); rep(i, 1, G.N + 1) { io::pt(G.query(G.Dfn[i]) - 1); } io::fflush(); return 0;}","link":"/BZOJ-3631/"},{"title":"「BJWC 2018」BZOJ 5148 kakuro","text":"kakuro是一个神奇的数独游戏，大致规则如下： $N\\times M​$ 的网格图中，由一些格子为空格需要填数，一些格子填线索，一些格子什么都不填 线索有两个方向，分别为右和下，线索的值表示该方向连续空格所填数之和 对于任意一个空格，其左边与上边的一定存在一个格子为线 游戏规则： 空格中填入正整数。 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。 Apia 给了Rimbaud 一个Kakuro 谜题。心不灵手不巧的Rimbaud 根本不会做Kakuro，所以只在空格里面填上了一些随机的数字，称这个为一个局面，即包含了谜题一开始给出的线索和后面填入的数字。 现在Rimbaud 希望能修改这个局面使得她的答案是一个合法解。这个局面中有些数字(包括一开始的给出线索和后面填入的数字) 是可以修改的。每个数字都有个特定的代价，将这个数字加 $1$ 或者减 $1$ 都得付出这个数字对应的代价。注意对于一组合法解，必须满足游戏规则，也就是空格中填的数字必须是正整数并且满足和的条件，但是不要求不重复。 Rimbaud 希望用最少的代价让这个局面变得合法，如果不可能那么输出-1 。 $3 \\leq n,m \\leq 30$，保证初始局面中的每个数字不超过 $10^6$ ，保证每个数字的代价不超过 $10^6$ 。 分析致谢感谢AloNE的讲解。 正题一个思路就是先做出一个合法解，然后再去修改权值以减少总花费。 那么最简单的合法解，就是每个空格都填 $1$ ，线索填对应格子的个数。 如此保证了每个空格都是正整数，这是一个最小解。 记当前花费为 $Ans$ 。 记某个格子现在的值为 $A(x,y)$ ，原来的值为 $O(x,y)$ ，修改 $1$ 的价格为 $C(x,y)$ 。 那么每个空格和线索只能往大修改，那么有两种情况。 $A(x,y) \\leq O(x,y)$ ，那么当 $A(x,y)$ 最初变大直到 $O(x,y)$ 时，相当于对最开始的修改进行反悔，也就是说花费 $-C(x,y)$；当然对于超出 $O(x,y)$ 的部分继续花费 $C(x,y)$ 。 $A(x,y) \\geq O(x,y)$ ，那么修改继续增加花费 $C(x,y)$ 。 转化成网络流问题，将这些关系抽象成如下的边： 发现对于修改一个空格会对其左边和上边的两个线索产生影响，约束方法很简单，就是流量从其上面的线索流入，从其左边的线索流出，那么保证所有增加的流量都是合法的；也就是说空格本质就是一条连接横向和竖向线索的边； 根据上面的建模方法，$S$ 连接所有竖向线索，费用为 $C(x,y)$ ，流量不限； 所有横向线索连接 $T$ ，费用为 $C(x,y)$ ，流量不限； 对于所有空格，如果 $A(x,y) \\leq O(x,y)$ ，连接费用为 $-C(x,y)$ 流量为 $O(x,y) - A(x,y)$ ，意为对最初的修改进行反悔；（对应的两个线索之间连边） 对于所有空格，连接费用为 $C(x,y)$ ，流量不限的边，因为每个格子都可以无限增大。 跑最小费用可行流，当前费用 $Cost \\geq 0$ 时结束。 得到最小费用 $C$ ，那么最终结果 $Ans + C$ 。 那么如何判断无解的情况？ 无解也就是说修改了不能修改的边。 那么将不能修改的边的费用置为 $INF$ ，跑完最小费用可行流之后检查残余与网络是否存在费用为 $INF$ 的反向边流量不为 $0$ 或者费用为 $-INF$ 的边流量不为 $0$ 。 如果出现这种情况，说明了必须修改不能修改的格子权值以满足流量平衡，输出 -1 即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 30 + 5;const int INF = 1e9 + 7;namespace mcf {const int MAXN = ::MAXN * ::MAXN * 4;const int MAXM = MAXN;struct Edge { int v, c, f, nxt;} E[MAXM &lt;&lt; 1];int S, T;ll C, F, Dis[MAXN];int H[MAXN], cntE;int Lp[MAXN], Le[MAXN];void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE;}bool spfa() { static std::bitset&lt;MAXN&gt; Inq; static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if (!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] &lt; 0;}void mcf() { while (spfa()) { int f = INF; for (int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } C += f * Dis[T]; F += f; for (int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } }}void init() { memset(H, -1, sizeof H); cntE = -1; C = F = 0;}bool check() { for (int i = 0; i &lt;= cntE; i += 2) { if (E[i].c == INF &amp;&amp; E[i ^ 1].f &gt; 0) { return false; } if (E[i].c == -INF &amp;&amp; E[i].f &gt; 0) { return false; } } return true;}}int N, M;int Type[MAXN][MAXN];int Column[MAXN][MAXN], Line[MAXN][MAXN], Ori[MAXN][MAXN];int ChangeC[MAXN][MAXN], ChangeL[MAXN][MAXN], ChangeO[MAXN][MAXN];int IdC[MAXN][MAXN], IdL[MAXN][MAXN];int Left[MAXN][MAXN], Up[MAXN][MAXN];int AfterC[MAXN][MAXN], AfterL[MAXN][MAXN], AfterO[MAXN][MAXN];int main() { mcf::init(); int cnt = 0; N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { rep(j, 1, M + 1) { Type[i][j] = io::gt&lt;int&gt;(); } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { Column[i][j] = io::gt&lt;int&gt;(); IdC[i][j] = ++cnt; } if (Type[i][j] == 2 || Type[i][j] == 3) { Line[i][j] = io::gt&lt;int&gt;(); IdL[i][j] = ++cnt; } if (Type[i][j] == 4) { Ori[i][j] = io::gt&lt;int&gt;(); } } } mcf::S = 0, mcf::T = cnt + 1; rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { ChangeC[i][j] = io::gt&lt;int&gt;(); if (ChangeC[i][j] == -1) { ChangeC[i][j] = INF; } } if (Type[i][j] == 2 || Type[i][j] == 3) { ChangeL[i][j] = io::gt&lt;int&gt;(); if (ChangeL[i][j] == -1) { ChangeL[i][j] = INF; } } if (Type[i][j] == 4) { ChangeO[i][j] = io::gt&lt;int&gt;(); if (ChangeO[i][j] == -1) { ChangeO[i][j] = INF; } } } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { int k = i + 1; while (k &lt;= N &amp;&amp; Type[k][j] == 4) { Up[k++][j] = IdC[i][j]; } AfterC[i][j] = k - i - 1; mcf::C += 1ll * ChangeC[i][j] * std::abs(AfterC[i][j] - Column[i][j]); } if (Type[i][j] == 2 || Type[i][j] == 3) { int k = j + 1; while (k &lt;= M &amp;&amp; Type[i][k] == 4) { Left[i][k++] = IdL[i][j]; } AfterL[i][j] = k - j - 1; mcf::C += 1ll * ChangeL[i][j] * std::abs(AfterL[i][j] - Line[i][j]); } if (Type[i][j] == 4) { AfterO[i][j] = 1; mcf::C += 1ll * ChangeO[i][j] * std::abs(AfterO[i][j] - Ori[i][j]); } } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { if (AfterC[i][j] &lt; Column[i][j]) { mcf::addEdge(mcf::S, IdC[i][j], Column[i][j] - AfterC[i][j], -ChangeC[i][j]); } mcf::addEdge(mcf::S, IdC[i][j], INF, ChangeC[i][j]); } if (Type[i][j] == 2 || Type[i][j] == 3) { if (AfterL[i][j] &lt; Line[i][j]) { mcf::addEdge(IdL[i][j], mcf::T, Line[i][j] - AfterL[i][j], -ChangeL[i][j]); } mcf::addEdge(IdL[i][j], mcf::T, INF, ChangeL[i][j]); } if (Type[i][j] == 4) { if (AfterO[i][j] &lt; Ori[i][j]) { mcf::addEdge(Up[i][j], Left[i][j], Ori[i][j] - AfterO[i][j], -ChangeO[i][j]); } mcf::addEdge(Up[i][j], Left[i][j], INF, ChangeO[i][j]); } } } mcf::mcf(); if (!mcf::check()) { printf(\"-1\\n\"); } else { printf(\"%lld\\n\", mcf::C); } return 0;}","link":"/BZOJ-5148/"},{"title":"「SCOI 2011」BZOJ 2330 糖果","text":"有 $N$ 个数 $A[1 \\cdots N](A[i] &gt; 0)$，要求满足 $M$ 个条件。条件形如： $A[i] \\leq A[j]$，$A[i] &lt; A[j]$， $A[i] = A[j]$ 。如果可以满足所有条件，求 $\\sum{A_i}$ 的最小值，否则输出 -1。 $N,M\\leq 100000$ 分析将条件依次转化为 $A[j] - A[i] \\geq 0$，$A[j] - A[i]\\geq 1$，$A[j]-A[i]\\geq 0 \\&amp; A[i]-A[j]\\geq 0$。 根据 $u - v\\geq w$ 建有向边 $(v, u, w)$ 的方式建图，求最长路。 如果单纯通过spfa进队 $N$ 次来判断无解可能会导致超时，发现无解本质为出现正环。因此可以采用Tarjan求联通分量，判断各分量内是否存在非零边的方法做到 $O(N+M)$ 判断无解。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;const int MAXN = 100000 + 5;int N, K;struct Edge { int u, v, w, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;long long Dis[MAXN];bool Inq[MAXN];long long spfa() { for (int i = 1; i &lt;= N; ++i) { Dis[i] = 1; Que.push(i); } while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &lt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } long long res = 0; for (int i = 1; i &lt;= N; ++i) { res += Dis[i]; } return res;}int Dfn[MAXN], Low[MAXN], cntD;int Stk[MAXN], top;int Belong[MAXN], cntB;void dfs(int x) { Dfn[x] = Low[x] = ++cntD; Stk[++top] = x; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (!Dfn[v]) { dfs(v); Low[x] = std::min(Low[x], Low[v]); } else if (!Belong[v]) { Low[x] = std::min(Low[x], Dfn[v]); } } if (Dfn[x] == Low[x]) { Belong[x] = ++cntB; do { Belong[Stk[top]] = cntB; } while (Stk[top--] != x); }}int main() { int opt, x, y; scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 1; i &lt;= K; ++i) { scanf(\"%d%d%d\", &amp;opt, &amp;x, &amp;y); if (opt == 1) { addEdge(x, y, 0); addEdge(y, x, 0); } else if (opt == 2) { addEdge(x, y, 1); } else if (opt == 3) { addEdge(y, x, 0); } else if (opt == 4) { addEdge(y, x, 1); } else if (opt == 5) { addEdge(x, y, 0); } if (opt % 2 == 0 &amp;&amp; x == y) { puts(\"-1\"); return 0; } } for (int i = 1; i &lt;= N; ++i) { if (!Dfn[i]) { dfs(i); } } bool flag = 0; for (int i = 1; i &lt;= cntE; ++i) { if (E[i].w &amp;&amp; Belong[E[i].u] == Belong[E[i].v]) { flag = 1; break; } } if (flag) { puts(\"-1\"); } else { printf(\"%lld\\n\", spfa()); } return 0;}","link":"/BZOJ-2330/"}],"tags":[{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"Pruefer","slug":"Pruefer","link":"/tags/Pruefer/"},{"name":"矩阵树定理","slug":"矩阵树定理","link":"/tags/矩阵树定理/"},{"name":"高精度","slug":"高精度","link":"/tags/高精度/"},{"name":"最短路","slug":"最短路","link":"/tags/最短路/"},{"name":"对偶图","slug":"对偶图","link":"/tags/对偶图/"},{"name":"轻重链剖分","slug":"轻重链剖分","link":"/tags/轻重链剖分/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"哈希","slug":"哈希","link":"/tags/哈希/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"约数个数定理","slug":"约数个数定理","link":"/tags/约数个数定理/"},{"name":"字典树","slug":"字典树","link":"/tags/字典树/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"ST表","slug":"ST表","link":"/tags/ST表/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"最大密度子图","slug":"最大密度子图","link":"/tags/最大密度子图/"},{"name":"分数规划","slug":"分数规划","link":"/tags/分数规划/"},{"name":"最小割","slug":"最小割","link":"/tags/最小割/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","link":"/tags/最大权闭合子图/"},{"name":"平衡树","slug":"平衡树","link":"/tags/平衡树/"},{"name":"差分约束","slug":"差分约束","link":"/tags/差分约束/"},{"name":"二元关系","slug":"二元关系","link":"/tags/二元关系/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"基环树","slug":"基环树","link":"/tags/基环树/"},{"name":"树形DP","slug":"树形DP","link":"/tags/树形DP/"},{"name":"最小割树","slug":"最小割树","link":"/tags/最小割树/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"斯坦纳树","slug":"斯坦纳树","link":"/tags/斯坦纳树/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"可持久化Trie","slug":"可持久化Trie","link":"/tags/可持久化Trie/"},{"name":"启发式合并","slug":"启发式合并","link":"/tags/启发式合并/"},{"name":"费用流","slug":"费用流","link":"/tags/费用流/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"状压DP","slug":"状压DP","link":"/tags/状压DP/"},{"name":"前后缀","slug":"前后缀","link":"/tags/前后缀/"},{"name":"背包","slug":"背包","link":"/tags/背包/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"莫队","slug":"莫队","link":"/tags/莫队/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"树上差分","slug":"树上差分","link":"/tags/树上差分/"}],"categories":[{"name":"51nod","slug":"51nod","link":"/categories/51nod/"},{"name":"BZOJ","slug":"BZOJ","link":"/categories/BZOJ/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/学习笔记/"},{"name":"JZOJ","slug":"JZOJ","link":"/categories/JZOJ/"},{"name":"codeforces","slug":"codeforces","link":"/categories/codeforces/"}]}