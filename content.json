{"pages":[{"title":"关于我","text":"高二Oier，来自北京。 曾获NOIP2016普及组三等奖，NOIP2017/2018提高组一等奖，WC2019铜牌。","link":"/about/index.html"},{"title":"归档","text":"[cleanarchivesreloaded monthorder=”new” postorder=”old”]","link":"/archives/index.html"},{"title":"关于我","text":"高二菜鸡Oier，来自北京。 曾获NOIP2016普及组三等奖，NOIP2017提高组一等奖，NOIP2018提高组一等奖。 由于太菜，BJOI2018凉透滚粗。 由于弱智，NOIP2018爆炸哭泣。 目前正在学习省选算法和数据结构中…… 衣带渐宽终不悔。为伊消得人憔悴。 —— 柳永《蝶恋花·伫倚危楼风细细》","link":"/about-me/index.html"},{"title":"BZOJ刷题记录","text":"Last Updated in 2018/11/29. 题号 标签 来源 1000 —— —— 1012 线段树 JSOI2008 1036 线段树 ZHOI2008 1053 搜索剪枝，单调性 HAOI2007 1058 平衡树 ZJOI2007 1067 RMQ，二分 SCOI2007 1086 树分块 SCOI2005 1150 平衡树，贪心 CTSC2007 1202 差分约束 HNOI2005 1208 平衡树 HNOI2004 1212 Trie树，DP HNOI2004 1224 搜索剪枝，前缀和 HNOI2002 1304 树形DP CQOI2009 1367 左偏树，贪心 Baltic2004 1369 树形DP Baltic2003 1455 左偏树，并查集 —— 1503 平衡树 NOI2004 1507 块状链表 NOI2003 1558 差分，线段树 JSOI2009 1588 平衡树 HNOI2002 1601 最小生成树 Usaco2008 Oct 1691 贪心，平衡树 Usaco2007 Dec 1776 最小生成树 Usaco2010 Hol 1798 线段树 AHOI2009 1826 堆，贪心 JSOI2010 1855 单调队列，DP SCOI2010 1858 线段树 SCOI2010 1878 离线，树状数组 SDOI2009 2038 莫队算法 国家集训队2009 2086 单调栈 POI2010 2096 单调队列 POI2010 2097 二分，贪心 Usaco2010 Dec 2243 树链剖分，线段树 SDOI2011 2330 差分约束 SCOI2011 2375 并查集 —— 2276 单调队列 POI2011 2425 组合树，数位DP HAOI2010 2456 —— —— 2464 最短路 中山市选2009 2465 费用流/贪心 中山市选2009 2466 树形DP 中山市选2009 2521 费用流 SHOI2010 2654 二分，最小生成树 —— 2733 平衡树，启发式合并 HNOI2012 2753 最小树形图 SCOI2012 3031 欧拉函数，素数分解 NOIP模拟题 3032 贪心 NOIP模拟题 3033 欧拉回路 NOIP模拟题 3211 线段树 SPOJ 3212 线段树 —— 3224 平衡树 —— 3436 差分约束 NOIP模拟题 3626 树链剖分，线段树，差分 LNOI2004 3631 树上差分 JLOI2014 3673 可持久化并查集 —— 3674 可持久化并查集 —— 3712 虚树，LCA PA2014 3714 最小生成树 PA2014 3910 并查集，LCA —— 4033 树形DP HAOI2015 4034 树链剖分，线段树 HAOI2015 4196 树链剖分，线段树 NOI2015 4349 最小树形图 —— 4530 树链剖分，线段树，并查集 BJOI2014 4551 DFS序，线段树 TJOI2016，HEOI2016 4890 树的直径，树形DP TJOI2017 5148 费用流 BJWC2018 5293 LCA，前缀和 BJOI2018 5301 莫队算法 CQOI2018 共69题。","link":"/bzoj-record/index.html"},{"title":"SGU做题记录","text":"共 $8$ 题，更新于 2018/09/09。 题号 题目名 题意 题解 算法/数据结构 完成日期 100 A+B 求A+B A+B —— 2018/09/06 101 Domino 牌正反面各有一个数字，排成一列使得相对的两个数相同，求可行方案 牌为边，正反面分别为点，构造无向图，求欧拉路径 欧拉路径 2018/09/06 102 Coprimes 求满足 $gcd(i,n)=1,1\\leq i \\leq n$ 的 $i$ 的个数 枚举 $i$ 直接算 $gcd(i,n)$ 最大公约数 2018/09/06 103 Traffic Lights 无向图上有边权，每个点的蓝紫颜色周期变化，当且仅当两点颜色相同时可以通过该边，可以在路口等待，求起点到终点的最短时间并输出路径 枚举每次等待的最短时间再进行转移的最短路 最短路 2018/09/07 104 Little shop of flowers 第 $i$ 朵花放在第 $j$ 个瓶子获得 $A_{i,j}$ 权值，若 $i &lt; j$ 则花 $i$ 必须放在花 $j$ 的左边，每个瓶子至多放一朵，求最大权值与对应方案 背包DP，记录上一次转移的位置用于输出方案 简单DP 2018/09/07 105 Div 3 $f(i)$ 表示通过 $1\\cdots i$ 顺序拼接而成的数，求 $f(1),\\cdots f(n)$ 中 $3$ 的倍数的个数 $f(3k),f(3k+2)$ 一定都满足条件，答案为 $\\lfloor n/3\\rfloor*2+[n\\%3==2]$ 简单数学 2018/09/07 106 The equation 给定 $a,b,c$ 求 $ax+by=c$ 满足 $x1\\leq x\\leq x2,y1\\leq y\\leq x2$ 的解个数 特判 $a,b,c$ 各种为 $0$ 的情况，剩下做拓展欧几里得求通解，分别求 $x,y$ 在区间内的解个数，取最小值 拓展欧几里得 2018/09/07 107 987654321 problem 求 $i\\in[10^n,10^{n+1}-1]$ 中满足 $i^2$ 末尾为 $987654321$ 的 $i$ 个数 若 $i$ 满足条件，则在 $1i,\\cdots9i$ 都满足条件。打表得到 $9$ 位数中有 $8$ 个解，$n \\leq 8$ 有 $0$ 个解，$n\\geq 10$ 有 $8\\times 9\\times 10^{n-10}$ 个解。 打表找规律 2018/09/07","link":"/sgu-record/index.html"},{"title":"record","text":"OJ 每周刷题记录02.11 - 02.17 BZOJ 3894 文理分科：二元关系 BZOJ 1497 最大获利：最大权闭合子图 BZOJ 1312 Neerc2006 Hard Life：最大密度子图 BZOJ 1001 狼抓兔子：平面图最大流转对偶图最短路 BZOJ 1003 物流运输：最短路+DP BZOJ 1002 轮状病毒：矩阵树定理，高精度 02.18 - 02.24 BZOJ 1054 移动玩具：哈希+搜索 BZOJ 1862 GameZ游戏排名系统：平衡树 BZOJ 3170 松鼠聚会：前缀和 BZOJ 1671 骑士：BFS BZOJ 1816 扑克牌：二分答案 BZOJ 1639 月度开支：DP BZOJ 1010 玩具装箱：斜率优化 BZOJ 1911 特别行动队：斜率优化 BZOJ 1095 Hide 捉迷藏：动态点分治","link":"/record/index.html"},{"title":"luogu做题记录","text":"Last Updated in 2018/09/02. -","link":"/luogu-record/index.html"}],"posts":[{"title":"01Trie 学习笔记","text":"原理01Trie用于解决求异或最大值的问题，其本质就是按位贪心。 别于一般的字典树，01Trie的每个节点只有两个儿子，$0$ 和 $1$。插入 $x$时，将其转化成二进制，从最高位开始插入，根据当前二进制位的值跳到节点对应的儿子上，于此同时将经过的所有节点权值+1，表示有一个数可以按照该方式分解。 查询当前$x$与Trie树异或的最大值时，根据贪心的思想，尽可能跳到与 $x$ 当前二进制位的值不同的儿子上，如此从根节点到叶子节点经过的所有点组合出的值就是与 $x$ 异或可以达到最大值的数，复杂度 $O(\\log{x})$。 空间复杂度 $O(n\\log{max(A_i)})$，时间复杂度 $O(\\log{max(A_i)})$。 合并两棵Trie树的方法与线段树合并类似，可持久化Trie树的方法与可持久化线段树类似。 例题01Trie BZOJ 4260 Codechef REBXOR 题目大意：对于长为 $N$ 的序列 $A[1\\cdots N]$，求两个不相交区间的异或和之和的最大值。 题解：前后缀和+01Trie。从前往后插入前缀异或和，得到 $[1,i]$ 的最大值，从后往前同理做一遍得到 $[i,N]$ 的最大值，答案为 $max([1,i]+[i+1,N])$。 Codeforces 706D Vasiliy’s Multiset HDU 4825 Xor Sum HDU 5536 Chip Factory POJ 3764 The xor-longest Path 可持久化01Trie BZOJ 3261 最大异或和 题目大意：开始给定一个长为 $N$ 的序列 $A[1\\cdots N]$，有 $M$ 个操作。在 $A$ 的末尾插入 $x$；或者给定 $x,l,r$，查询 $max(x\\oplus A[p]\\oplus\\cdots\\oplus A[N])$，其中$p\\in[l,r]$，$N$为当前序列长度 。 题解：可持久化01Trie树模板题，后缀转为前缀查询。 HDU 4757 Tree 题目大意：树上每个点有权值 $A[1\\cdots N]$，$M$ 个询问。给定 $(u,v,w)$，查询 $u,v$ 路径上的点与 $w$ 异或的最大值。 题解：可持久化01Trie+LCA。dfs时儿子继承父亲做可持久化，查询时求两点到LCA区间的异或最大值。 BZOJ 2741【FOTILE模拟赛】L 题目大意：给定长为 $N$ 的序列 $A[1\\cdots N]$，$M$ 个询问。查询 $[l,r]$ 的最大异或和子区间，强制在线。 题解：可持久化Trie+分块。记 $s[i]$ 为第 $i$ 块的左端点，$f(i,j)$ 表示$[s[i],r-1]$中的某个点为左端点，右端点为 $r$ 的最大异或子区间。记 $g(i,j)$ 为$[s[i],r]$ 中的最大异或子区间。查询时跨越的完整块直接查 $g$ 数组，剩下的部分在可持久化Trie中查询，取最大值。 启发式合并01Trie BNDSOJ 985 2018-12-2模拟测验（二） 题目大意：有 $N$ 个点， $M$ 个操作。每次连接两个点，或查询联通的两个点的异或值的最大值。 题解：并查集+启发式合并01Trie。并查集维护连通性，合并两联通块时启发式合并两个Trie树，同时记录最大值。","link":"/01-Trie/"},{"title":"「ICPC-Beijing 2006」BZOJ 1001 狼抓兔子","text":"在网格图中，任意点 $(x,y)$ 都有 $(x,y)\\rightarrow (x+1,y)$ / $(x,y)\\rightarrow (x,y+1)$ / $(x,y)\\rightarrow (x+1,y+1)$ 这三种边。起点 $S$ 位于 $(1,1)$，终点 $T$ 位于 $(n,m)$。求 $S-T$ 最小割。 $n,m\\leq 1000$ 分析如果根据最大流最小割定理，通过求 $S-T$ 最大流得到最小割的话，是行不通的，因为该图有最多 $1000^2$ 个点。 但是本题特殊的一点在于这是一个平面图，可以将其转化为对偶图，通过求对偶图上的最短路得到原图的最小割。 平面图转对偶图的流程如下： 用一条不与其他任何边相交的新边连接 $S,T$ ，构成一个新面 将平面图的每个面对应为对偶图的点，第一步构造的新面和无边界的面作为新图的起点 $s$ 和终点 $t$ 如果原图中边 $e$ 同时属于两个面 $s1,s2$，则在新图中 $s1$ 和 $s2$ 之间连一条权值与 $e$ 相同的无向边 删去 $s,t$ 之间的边 则 $s-t$ 最短路对应 $S-T$ 最大流。 复杂度 $O(nm\\lg{nm})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* * @Author: Skqliao * @Date: 2019-02-13 12:36:43 * @LastEditTime: 2019-02-13 18:20:57 * @Source: BJOI 2006 * @Problem: 1001: [BeiJing2006]狼抓兔子 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1001 */#include &lt;bits/stdc++.h&gt;const int MAXN = 2 * 1000 * 1000 + 5;const int MAXM = MAXN * 3;struct Edge {int v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) {E[++cntE] = (Edge) {v, w, H[u]};H[u] = cntE;E[++cntE] = (Edge) {u, w, H[v]};H[v] = cntE;}int N, M;int S, T;typedef std::pair&lt;int, int&gt; pii;int Dis[MAXN];int dijkstra() {static std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt; &gt; Pq;memset(Dis, 0x3f, sizeof Dis);Dis[S] = 0;Pq.push(std::make_pair(Dis[S], S));while (!Pq.empty()) { while (!Pq.empty() &amp;&amp; Dis[Pq.top().second] &lt; Pq.top().first) Pq.pop(); if (Pq.empty()) break; int x = Pq.top().second; Pq.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Pq.push(std::make_pair(Dis[v], v)); } }}return Dis[T];}int main() {int x;scanf(\"%d%d\", &amp;N, &amp;M);if (N == 1 || M == 1) { int ans = INT_MAX; while (~scanf(\"%d\", &amp;x)) ans = std::min(ans, x); printf(\"%d\\n\", ans);} else { N--, M--; S = 0, T = N * M * 2 + 1; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d\", &amp;x); addEdge(i, T, x); } for (int i = 2; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); addEdge((2 * i - 3) * M + j, (2 * i - 2) * M + j, x); } } for (int i = 1; i &lt;= M; ++i) { scanf(\"%d\", &amp;x); addEdge((2 * N - 1) * M + i, S, x); } for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); addEdge((2 * i - 1) * M + 1, S, x); for (int j = 1; j &lt;= M - 1; ++j) { scanf(\"%d\", &amp;x); addEdge((2 * i - 2) * M + j, (2 * i - 2) * M + j + M + 1, x); } scanf(\"%d\", &amp;x); addEdge((2 * i - 1) * M, T, x); } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); addEdge((2 * i - 2) * M + j, (2 * i - 2) * M + j + M, x); } } printf(\"%d\\n\", dijkstra());}return 0;}","link":"/BZOJ-1001/"},{"title":"51nod 1601 完全图的最小生成树计数","text":"有 $n$ 个点，每个点有点权 $a_i$，点 $u,v$ 之间的边边权为 $a_u \\oplus a_v$。求该完全图的最小生成树的权值与方案数。 $n\\leq 10 ^ 5, 0\\leq a_i &lt; 2 ^ {30}$ 分析从边权为点xor得到，想到可以对点权建立Trie树。 每次合并两子树mst的权值，并加入两子树中节点可以xor得到的最小值作为连接这两棵子树的最小边，自下而上得到整棵Trie的mst的值。 根据Cayley公式，如果存在有 $a(a &gt; 2)$个相同权值的点时，生成树的方案数为 $a^ {a - 2}$。每次合并两子树时对方案数做乘法原理即可得到最终的方案数。 复杂度 $O(n\\log{a_i})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 22:59:31 * @LastEditTime: 2019-01-26 23:41:49 * @Source: 51nod * @Problem: 1601 完全图的最小生成树计数 * @Url: https://www.51nod.com/Challenge/Problem.html#!#problemId=1601 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1e5 + 5;const int MOD = 1e9 + 7;int N;int Ch[MAXN &lt;&lt; 5][2], Num[MAXN &lt;&lt; 5], cnt = 1;long long sum, num = 1;void insert(int val) { int x = 1; for (int i = 29; i &gt;= 0; --i) { int d = (val &gt;&gt; i) &amp; 1; if (!Ch[x][d]) { Ch[x][d] = ++cnt; } x = Ch[x][d]; } ++Num[x];}long long poww(long long x, long long t) { long long ans = 1; for (; t; t &gt;&gt;= 1) { if (t &amp; 1) { ans = ans * x % MOD; } x = x * x % MOD; } return ans;}long long min, tmp;void getMin(int x, int y, int d, int v = 0) { if (d &lt; 0) { if (v &lt; min) { min = v; tmp = (long long)Num[x] * Num[y] % MOD; } else if (v == min) { tmp = (tmp + (long long)Num[x] * Num[y]) % MOD; } return; } if (Ch[x][0] &amp;&amp; Ch[y][0]) { getMin(Ch[x][0], Ch[y][0], d - 1, v); if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } } else if (Ch[x][1] &amp;&amp; Ch[y][1]) { getMin(Ch[x][1], Ch[y][1], d - 1, v); } else { if (Ch[x][0]) { getMin(Ch[x][0], Ch[y][1], d - 1, v + (1 &lt;&lt; d)); } if (Ch[x][1]) { getMin(Ch[x][1], Ch[y][0], d - 1, v + (1 &lt;&lt; d)); } }}void cal(int x, int d) { if (d &lt; 0) { if (Num[x] &gt; 1) { num = num * poww(Num[x], Num[x] - 2); } return; } if (!Ch[x][0]) { cal(Ch[x][1], d - 1); } else if (!Ch[x][1]) { cal(Ch[x][0], d - 1); } else { cal(Ch[x][0], d - 1); cal(Ch[x][1], d - 1); min = 1 &lt;&lt; 30; tmp = 0; getMin(Ch[x][0], Ch[x][1], d - 1, 0); sum = sum + (1 &lt;&lt; d) + min; num = (num * tmp) % MOD; }}int main() { scanf(\"%d\", &amp;N); int x; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); insert(x); } cal(1, 29); printf(\"%lld\\n%lld\\n\", sum, num); return 0;}","link":"/51nod-1601/"},{"title":"「ZJOI 2006」BZOJ 1003 物流运输","text":"一共有 $n$ 天，每天要在无向图 $G$ 中从 $1$ 走到 $m$。有 $k$ 个限制条件，即不能在第 $[l,r]$ 天中经过点 $i$。每天的花费为路径总长度，每次更换线路（相比于前一天）会额外增加 $k$ 的花费，求最小花费。 $n\\leq 100,m\\leq 20$ 分析点数极少，因此我们可以通过 $n^2$ 次最短路，预处理出来第 $[l,r]$ 天的每天的最小花费 $C[l][r]$（保证该花费对应的路径在第 $[l,r]$ 天都是合法的）。 然后DP， $F[i]$ 表示前 $i$ 天最小的总花费。枚举上一次更换的时间 $j$，则 $F[i]=\\min{F[j-1]+(j-i+1)\\cdot C[j][i]+K\\cdot[j\\not = 1]}(1\\leq j\\leq i)$。 复杂度 $O(n^2m\\log{m})$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * @Author: Skqliao * @Date: 2019-02-16 18:54:21 * @LastEditTime: 2019-02-16 20:02:16 * @Source: ZJOI 2006 * @Problem: 1003: [ZJOI2006]物流运输 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1003 */#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;int N, M, K, P, D;int W[MAXN][MAXN];struct Edge {int v, w, nxt;} E[MAXN * MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) {E[++cntE] = (Edge) {v, w, H[u]};H[u] = cntE;E[++cntE] = (Edge) {u, w, H[v]};H[v] = cntE;}typedef std::pair&lt;int, int&gt; pii;int dijkstra(int l, int r) {static std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt; &gt; Pq;static int Dis[MAXN];static bool Vis[MAXN];memset(Vis, 0, sizeof Vis);memset(Dis, 0x3f, sizeof Dis);Dis[1] = 0;Pq.push(std::make_pair(0, 1));for (int i = l; i &lt;= r; ++i) { for (int j = 1; j &lt;= M; ++j) { if (W[i][j]) Vis[j] = 1; }}while (!Pq.empty()) { while (!Pq.empty() &amp;&amp; Pq.top().first &gt; Dis[Pq.top().second]) Pq.pop(); if (Pq.empty()) break; int x = Pq.top().second; Pq.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Vis[v] || Dis[v] &lt; Dis[x] + E[i].w) continue; Dis[v] = Dis[x] + E[i].w; Pq.push(std::make_pair(Dis[v], v)); }}return Dis[M];}int F[MAXN], G[MAXN][MAXN];int main() {int u, v, w;scanf(\"%d%d%d%d\", &amp;N, &amp;M, &amp;K, &amp;P);for (int i = 1; i &lt;= P; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w);}scanf(\"%d\", &amp;D);for (int i = 1; i &lt;= D; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); for (int j = v; j &lt;= w; ++j) W[j][u] = 1;}for (int i = 1; i &lt;= N; ++i) { for (int j = i; j &lt;= N; ++j) { G[i][j] = dijkstra(i, j); }}for (int i = 1; i &lt;= N; ++i) { F[i] = INT_MAX; if (G[1][i] != 0x3f3f3f3f) F[i] = i * G[1][i]; for (int j = 2; j &lt;= i; ++j) { if (G[j][i] != 0x3f3f3f3f) F[i] = std::min(F[i], F[j - 1] + G[j][i] * (i - j + 1) + K); }}printf(\"%d\\n\", F[N]);return 0;}","link":"/BZOJ-1003/"},{"title":"「FJOI 2007」BZOJ 1002 轮状病毒","text":"求 $N$ 轮状病毒的不同状态数。 $N\\leq 100$ 分析发现中间的点度数为 $N$，其他点度数为 $3$，用矩阵树定理解即可。 也可以暴力打表找规律，记 $f(i)$ 为 $i$ 轮状病毒的状态数，递推式为 $f(i)=3\\cdot f(i-1)-f(i-2)+2$。 python打表或者写高精度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* * @Author: Skqliao * @Date: 2019-02-16 20:21:57 * @LastEditTime: 2019-02-16 21:10:05 * @Source: FJOI 2007 * @Problem: 1002: [FJOI2007]轮状病毒 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1002 */#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;int N;struct Int {static const int MAXN = 10000 + 5;int len, S[MAXN];Int operator=(int x) { memset(S, 0, sizeof S); len = 0; while (x) { S[len++] = x % 10; x /= 10; } return *this;}Int operator+(const Int &amp;x) { Int c; c.len = std::max(len, x.len); memset(c.S, 0, sizeof c.S); for (int i = 0; i &lt; c.len; ++i) { c.S[i] += S[i] + x.S[i]; c.S[i + 1] += c.S[i] / 10; c.S[i] %= 10; } if (c.S[c.len]) ++c.len; return c;}Int operator-(const Int &amp;x) { Int c; c.len = len; memset(c.S, 0, sizeof c.S); for (int i = 0; i &lt; c.len; ++i) { c.S[i] = S[i] - x.S[i]; while (c.S[i] &lt; 0) { c.S[i] += 10; S[i + 1]--; } } while (!c.S[c.len - 1]) --c.len; return c;}Int operator*(const Int &amp;x) { Int c; c.len = len + x.len - 1; memset(c.S, 0, sizeof c.S); for (int i = 0; i &lt; len; ++i) { for (int j = 0; j &lt; x.len; ++j) { c.S[i + j] += S[i] * x.S[j]; } } for (int i = 0; i &lt; c.len; ++i) { c.S[i + 1] += c.S[i] / 10; c.S[i] %= 10; } if (c.S[c.len]) ++c.len; return c;}void print() { for (int i = len - 1; i &gt;= 0; --i) { printf(\"%d\", S[i]); }}} F[MAXN], x, y;int main() {scanf(\"%d\", &amp;N);x = 2;y = 3;F[1] = 1;F[2] = 5;for (int i = 3; i &lt;= N; ++i) { F[i] = y * F[i - 1] - F[i - 2] + x;}F[N].print();return 0;}","link":"/BZOJ-1002/"},{"title":"「JSOI 2008」BZOJ 1012 最大数","text":"维护一个数列，具有 $M$ 个以下两种操作： 查询并输出当前数列中末尾L个数中的最大的数 将 $n$ 加上最近一次查询操作的答案，对 $D$ 取模后，插入到数列的末尾 $M \\leq 200000$ 分析对 $[1…M]$ 建线段树，记录当前序列末尾的下标。 那么问题就变成了线段树区间查询最大值，单点修改（开始默认每个元素都是 $0$）。 值得注意的一点是，对 $D​$ 取模并不意味着一定要变成正数。例如 $D=5​$，上次结果为 $1​$，$n=-10​$ ，那么实际插入的数就是 $-4​$ ，而不是 $1​$ ，这一点题目并没有明确。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() {return getchar();}template &lt;class T&gt; inline T gt() {static T x;std::cin &gt;&gt; x;return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') {std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() {static char In[MAXSIZE], *at = In, *en = In;if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin);}return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() {char c;while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {}bool f = c == '-';T x = f ? 0 : c - '0';for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0';}return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() {fwrite(Out, 1, cur - Out, stdout);cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') {static int S[20], *top;top = S;if (x &lt; 0) { *cur++ = '-', x = -x;}do { *++top = x % 10, x /= 10;} while (x);while (top != S) { *cur++ = *top-- + '0';}*cur++ = c;if (cur &gt;= end) { flush();}}#endif} // namespace ioconst int MAXN = 200000 + 5;#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint N = 1, M, P;int Max[MAXN &lt;&lt; 2];void pushUp(int rt) {Max[rt] = std::max(Max[rt &lt;&lt; 1], Max[rt &lt;&lt; 1 | 1]);}void modify(int rt, int l, int r, int p, int x) {if (l == r) { Max[rt] = x; return ;}int m = (l + r) &gt;&gt; 1;if (p &lt;= m) { modify(LT, p, x);} else { modify(RT, p, x);}pushUp(rt);}int queryMax(int rt, int l, int r, int a, int b) {if (a &lt;= l &amp;&amp; r &lt;= b) { return Max[rt];}int m = (l + r) &gt;&gt; 1;int res = 0;if (a &lt;= m) { res = std::max(res, queryMax(LT, a, b));}if (m &lt; b) { res = std::max(res, queryMax(RT, a, b));}return res;}int main() {int res = 0;M = io::gt&lt;int&gt;(), P = io::gt&lt;int&gt;();while (M--) { char opt = io::gc(); while (!isalpha(opt)) { opt = io::gc(); } int x = io::gt&lt;int&gt;(); if (opt == 'Q') { io::pt(res = queryMax(1, 1, MAXN, N - x, N - 1)); } else { modify(1, 1, MAXN, N++, (x + res) % P); }}io::flush();return 0;}","link":"/BZOJ-1012/"},{"title":"「HNOI 2008」BZOJ 1010 玩具装箱toy","text":"用若干个区间覆盖 $n$ 个数 $A[1 \\cdots n]$，区间 $[l,r]$ 的花费为 $(\\sum\\limits_{i=l}^{r}{A[i]}+r-l-L)^2$。求总花费的最小值。 $n\\leq 50000,A_i,L &gt; 0$ 分析记 $F[i]$ 为覆盖前 $i$ 个数的最小花费，$S[i]=\\sum\\limits_{j=1}^{i}{A[j]}$ 。即可得到一个simple的DP转移方程，$F[i]=\\min\\limits_{1\\leq j &lt; i}(F[j]+(S[i]-S[j]+i-j-1-L)^2)$。 但是复杂度太高，为 $O(n^2)$，需要优化。 考虑两个决策点 $j,k(j &lt; k)$，什么时候 $j$ 会更优。 即满足 $F[j]+(S[i]-S[j]+i-j-1-L)^2-F[k]+(S[i]-S[k]+i-k-1-L)^2 &gt; 0$。 设 $S’[i]=S[i]+i-1$，整理可得：$F[j]-F[k]-2(S’[i]-L-1)(S’[j]-S’[k])+S’^2[j]-S’^2[k]&gt;0$。 移项得 $\\frac{F[i]-F[k]+(S’[j]+S’[k]+2L+2)(S’[j]-S’[k])}{2(s’[j]-s’[k])}&gt;S’[i]$。 发现左式与 $i$ 无关，且 $S’[i]$ 单调不减。这是一个斜率优化的题。 设左式为 $j,k$ 间的斜率，维护单调队列，满足相邻两点间的斜率单调递增，且大于 $S’[i]$。每次取队首决策点更新当前 $F[i]$，并将 $i$ 插入队尾。 复杂度 $O(n))$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041/* * @Author: Skqliao * @Source: HNOI 2008 * @Problem: 1010: [HNOI2008]玩具装箱toy * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1010 * @Date: 2019-02-23 09:47:42 * @LastEditTime: 2019-02-23 11:03:34 */#include &lt;bits/stdc++.h&gt;const int MAXN = 50000 + 5;int N, L;long long A[MAXN], F[MAXN], S[MAXN];int Que[MAXN], qh, qt;double cal(int j, int k) {return (F[j] - F[k] + (S[j] + S[k] + 2 * L + 2) * (S[j] - S[k])) / 2 / (S[j] - S[k]);}int main() {scanf(\"%d%d\", &amp;N, &amp;L);for (int i = 1; i &lt;= N; ++i) { scanf(\"%lld\", &amp;A[i]);}Que[qt++] = 0;S[0] = -1;for (int i = 1; i &lt;= N; ++i) { S[i] = S[i - 1] + A[i] + 1; while (qt - qh &gt; 1 &amp;&amp; cal(Que[qh], Que[qh + 1]) &lt;= S[i]) { ++qh; } F[i] = F[Que[qh]] + (S[i] - S[Que[qh]] - L - 1) * (S[i] - S[Que[qh]] - L - 1); while (qt - qh &gt; 1 &amp;&amp; cal(Que[qt - 2], Que[qt - 1]) &gt;= cal(Que[qt - 1], i)) { --qt; } Que[qt++] = i;}printf(\"%lld\\n\", F[N]);return 0;}","link":"/BZOJ-1010/"},{"title":"「ZJOI 2008」BZOJ 1036 树的统计","text":"一棵有 $N$ 个节点的树，每个节点有初始权值 $W_i$ 。共有 $M$ 次操作，分别为： 查询节点 $(u,v)$ 间所有节点的权值和 查询节点 $(u,v)$ 间所有节点的最大权值 修改 $W_u$ 为 $x$ $1\\leq N\\leq30000,0\\leq M\\leq 200000$，中途操作中保证每个节点的权值 $w$ 在$-30000$到$30000$之间。 分析又是一道树链剖分模板题… 树剖后，线段树维护区间最大值和区间和。 复杂度 $O(N+M\\log^2{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;#define ONLINE_JUDGEnamespace io {#ifndef ONLINE_JUDGEchar gc() {return getchar();}template &lt;class T&gt; inline T gt() {static T x;std::cin &gt;&gt; x;return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') {std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() {static char In[MAXSIZE], *at = In, *en = In;if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin);}return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() {char c;while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {}bool f = c == '-';T x = f ? 0 : c - '0';for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0';}return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() {fwrite(Out, 1, cur - Out, stdout);cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') {static int S[20], *top;top = S;if (x &lt; 0) { *cur++ = '-', x = -x;}do { *++top = x % 10, x /= 10;} while (x);while (top != S) { *cur++ = *top-- + '0';}*cur++ = c;if(cur &gt;= end) { flush();}}#endif} // namespace iostruct Graph {static const int MAXN = 30000 + 5;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int N, R;int H[MAXN], cntE;int Depth[MAXN], Fa[MAXN], Son[MAXN], Sz[MAXN];int Dfn[MAXN], Top[MAXN], cntD;int W[MAXN], Wp[MAXN];void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}void dfs(int x) { Son[x] = 0, Sz[x] = 1; for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { Fa[v] = x; Depth[v] = Depth[x] + 1; dfs(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } }}void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; W[cntD] = Wp[x]; if(Son[x]) { dfs2(Son[x], top); } for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Son[x] &amp;&amp; v != Fa[x]) { dfs2(v, v); } }}#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Sum[MAXN &lt;&lt; 2], Max[MAXN &lt;&lt; 2];void pushUp(int rt) { Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1]; Max[rt] = std::max(Max[rt &lt;&lt; 1], Max[rt &lt;&lt; 1 | 1]);}void build(int rt, int l, int r) { if(l == r) { Max[rt] = Sum[rt] = W[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void modify(int rt, int l, int r, int p, int x) { if(l == r) { Sum[rt] = Max[rt] = x; return ; } int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { modify(LT, p, x); } else { modify(RT, p, x); } pushUp(rt);}int querySum(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Sum[rt]; } int m = (l + r) &gt;&gt; 1; int res = 0; if(a &lt;= m) { res += querySum(LT, a, b); } if(m &lt; b) { res += querySum(RT, a, b); } return res;}int queryMax(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Max[rt]; } int m = (l + r) &gt;&gt; 1; int res = -INT_MAX; if(a &lt;= m) { res = std::max(res, queryMax(LT, a, b)); } if(m &lt; b) { res = std::max(res, queryMax(RT, a, b)); } return res;}void change(int u, int x) { modify(1, 1, N, Dfn[u], x);}int queryPathS(int u, int v) { int res = 0; int tu = Top[u], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } res += querySum(1, 1, N, Dfn[tv], Dfn[v]); v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } res += querySum(1, 1, N, Dfn[u], Dfn[v]); return res;}int queryPathM(int u, int v) { int res = -INT_MAX; int tu = Top[u], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } res = std::max(res, queryMax(1, 1, N, Dfn[tv], Dfn[v])); v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } res = std::max(res, queryMax(1, 1, N, Dfn[u], Dfn[v])); return res;}void prepare() { dfs(R); dfs2(R, R); build(1, 1, N);}} G;int main() {G.N = io::gt&lt;int&gt;();G.R = 1;rep(i, 1, G.N) { G.addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;());}rep(i, 1, G.N + 1) { G.Wp[i] = io::gt&lt;int&gt;();}G.prepare();int M = io::gt&lt;int&gt;();rep(i, 0, M) { char ch = io::gc(); while(!isalpha(ch)) { ch = io::gc(); } if(ch == 'Q') { ch = io::gc(); int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); if(ch == 'S') { io::pt(G.queryPathS(u, v)); } else { io::pt(G.queryPathM(u, v)); } } else { int u = io::gt&lt;int&gt;(), x = io::gt&lt;int&gt;(); G.change(u, x); }}io::flush();return 0;}","link":"/BZOJ-1036/"},{"title":"「ZJOI 2008」BZOJ 1040 骑士","text":"每个点有权值 $W_i$，选择点 $i$ 后不能选择点 $A_i$。选择任意多个点，使得权值和最大。 $N\\leq 1000000$ 分析根据题意，不能同时选择点 $i$ 和 $A_i$。 该图有 $N$ 个点 $N$ 条边，因此是个基环树森林。 对于每棵基环树，断掉环上任意一条边 $(u,v)$。以 $u,v$ 分别为根跑树形DP，父亲儿子不能被同时选择，且根节点不能被选。则这棵基环树的贡献为两次DP的较大值。 复杂度 $O(n)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* * @Author: Skqliao * @Source: BZOJ 2008 * @Problem: 1040: [ZJOI2008]骑士 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1040 * @Date: 2019-02-21 15:39:58 * @LastEditTime: 2019-02-21 16:12:59 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000000 + 5;int N;int W[MAXN];struct Edge {int v, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE = -1;void addEdge(int u, int v) {E[++cntE] = (Edge) {v, H[u]};H[u] = cntE;E[++cntE] = (Edge) {u, H[v]};H[v] = cntE;}int Vis[MAXN], cnt;int fir, sec, cut;void dfs(int x, int fa) {Vis[x] = cnt;for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa) { if (!Vis[v]) { dfs(v, x); } else { fir = x; sec = v; cut = i; } }}}long long F[MAXN][2];long long dp(int x, int fa) {F[x][1] = W[x];F[x][0] = 0;for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (i == cut || i == (cut ^ 1) || v == fa) continue; dp(v, x); F[x][0] += std::max(F[v][0], F[v][1]); F[x][1] += F[v][0];}return F[x][0];}int main() {memset(H, -1, sizeof H);scanf(\"%d\", &amp;N);int x;for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;W[i], &amp;x); addEdge(x, i);}long long ans = 0;for (int i = 1; i &lt;= N; ++i) { if (Vis[i]) continue; ++cnt; dfs(i, 0); ans += std::max(dp(fir, 0), dp(sec, 0));}printf(\"%lld\\n\", ans);return 0;}","link":"/BZOJ-1040/"},{"title":"「HAOI 2007」BZOJ1053 反素数","text":"求 $[1,N]​$ 中最大的反素数。 记 $g(x)$ 为 $x$ 的约束个数，反素数即满足 $y \\in [1,x-1], g(x) &gt; g(y)$ 。 $1\\leq N\\leq 2000000000$ 分析根据约数个数定理。设 $x = \\prod{A_{i}^{P_i}}$，则 $x$ 的约数个数为 $\\prod{(P_i+1)}$ 。 假设 $A_i$ 单调递增，那么 $P_i$ 一定单调递减。 反证法：若 $x$ 分解后，存在 $A_i &lt; A_j, P_i \\leq P_j$ ，那么互换 $P_i, P_j$ 一定更优。 根据 $N$ 的数据范围，发现前 $11$ 个素数的乘积就已经超过 $2e9$ ，因此最多枚举 $10$ 个素数 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;int Pri[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59};ll ans, N;int res;void dfs(int x, ll cur, int num, int last) {if(cur * Pri[x] &gt; N) { if(num &gt; res || num == res &amp;&amp; ans &gt; cur) { res = num; ans = cur; } return ;}ll mul = Pri[x];rep(i, 1, last + 1) { if(cur * mul &gt; N) { break; } dfs(x + 1, cur * mul, num * (i + 1), i); mul *= Pri[x];}}int main() {scanf(\"%lld\", &amp;N);dfs(0, 1, 1, 64);printf(\"%lld\\n\", ans);return 0;}","link":"/BZOJ-1053/"},{"title":"「HAOI 2008」BZOJ 1054 移动玩具","text":"给定两个 $4\\times 4$ 的01矩阵，每次可以交换一对相邻的 $0,1$，求前一个矩阵转移到后一个矩阵的最少步数。 分析BFS+Hash。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * @Author: Skqliao * @Source: HAOI 2008 * @Problem: 1054: [HAOI2008]移动玩具 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1054 * @Date: 2019-02-18 22:53:30 * @LastEditTime: 2019-02-21 15:15:00 */#include &lt;bits/stdc++.h&gt;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};struct Node {std::string code;int step;};std::string s, t, x;std::multiset&lt;std::string&gt; Vis;std::queue&lt;Node&gt; Que;int bfs() {Que.push((Node) {s, 0});while (!Que.empty()) { Node a = Que.front(); Que.pop(); for (int p = 0; p &lt; 16; ++p) { if (a.code[p] == '0') continue; int i = p / 4, j = p % 4; for (int k = 0; k &lt; 4; ++k) { int x = i + Dicx[k], y = j + Dicy[k]; if (x &lt; 0 || y &lt; 0 || x &gt; 3 || y &gt; 3) continue; if (a.code[x * 4 + y] == '1') continue; std::string b = a.code; b[p] = '0'; b[x * 4 + y] = '1'; if (Vis.count(b)) continue; Vis.insert(b); if (t == b) return a.step + 1; Que.push((Node) {b, a.step + 1}); } }}}int main() {for (int i = 0; i &lt; 4; ++i) { std::cin &gt;&gt; x; s += x;}for (int i = 0; i &lt; 4; ++i) { std::cin &gt;&gt; x; t += x;}if (s == t) std::cout &lt;&lt; 0;else std::cout &lt;&lt; bfs();return 0;}","link":"/BZOJ-1054/"},{"title":"「HAOI 2007」BZOJ 1047 理想的正方形","text":"在 $N\\times M$ 的矩阵中，求 $K\\times K$ 的子矩阵中两最值之差的最小值。 $N,M\\leq 1000,K\\leq 100$ 分析二维ST表，用 $Max(x,y,k),Min(x,y,z)$ 分别表示左上角为 $(x,y)$，边长为 $2^k$ 的子矩阵中的最大值与最小值。 然后枚举子矩阵左上角，求当前矩阵两最值最差，取最小值。 复杂度 $O(NM\\log{N}+NM)$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * @Author: Skqliao * @Source: HAOI 2007 * @Problem: 1047: [HAOI2007]理想的正方形 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1047 * @Date: 2019-02-28 19:29:48 * @LastEditTime: 2019-02-28 19:48:10 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000 + 5;const int LOG = 10;int N, M, K;int Mx[MAXN][MAXN][LOG], Mn[MAXN][MAXN][LOG];int Log[MAXN], Bin[LOG];int queryMax(int x, int y, int n) {int k = Log[n];return std::max(std::max(Mx[x][y][k], Mx[x + n - Bin[k]][y][k]), std::max(Mx[x][y + n - Bin[k]][k], Mx[x + n - Bin[k]][y + n - Bin[k]][k]));}int queryMin(int x, int y, int n) {int k = Log[n];return std::min(std::min(Mn[x][y][k], Mn[x + n - Bin[k]][y][k]), std::min(Mn[x][y + n - Bin[k]][k], Mn[x + n - Bin[k]][y + n - Bin[k]][k]));}int main() {scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;K);for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;Mx[i][j][0]); Mn[i][j][0] = Mx[i][j][0]; }}for (int i = 2; i &lt;= std::max(N, M); ++i) { Log[i] = Log[i &gt;&gt; 1] + 1;}Bin[0] = 1;for (int i = 1; i &lt;= Log[std::max(N, M)]; ++i) { Bin[i] = Bin[i - 1] &lt;&lt; 1;}for (int k = 1; k &lt;= Log[std::max(N, M)]; ++k) { for (int i = 1; i + Bin[k] - 1 &lt;= N; ++i) { for (int j = 1; j + Bin[k] - 1 &lt;= M; ++j) { Mx[i][j][k] = std::max(std::max(Mx[i][j][k - 1], Mx[i + Bin[k - 1]][j][k - 1]), std::max(Mx[i][j + Bin[k - 1]][k - 1], Mx[i + Bin[k - 1]][j + Bin[k - 1]][k - 1])); Mn[i][j][k] = std::min(std::min(Mn[i][j][k - 1], Mn[i + Bin[k - 1]][j][k - 1]), std::min(Mn[i][j + Bin[k - 1]][k - 1], Mn[i + Bin[k - 1]][j + Bin[k - 1]][k - 1])); } }}int ans = INT_MAX;for (int i = 1; i &lt;= N - K + 1; ++i) { for (int j = 1; j &lt;= M - K + 1; ++j) { ans = std::min(ans, queryMax(i, j, K) - queryMin(i, j, K)); }}printf(\"%d\\n\", ans);return 0;}","link":"/BZOJ-1047/"},{"title":"「SCOI 2007」BZOJ 1067 降雨量","text":"已知 $N$ 个年份 $Y_i$ 的降雨量 $R_i$。 现有 $M$ 个询问。给定年份 $X,Y$ ，判断“X年是自Y年以来降雨量最多的”的正确性。 该语句正确的当且仅当 $R_X\\leq R_Y$ 且对于所有 $Y&lt;Z&lt;X$，满足 $R_Z&lt;R_X$ 。 如果判断语句正确，输出true；如果可能正确，输出maybe；如果一定错误输出false。 $1\\leq N\\leq 50000, 1\\leq M\\leq 10000, -10^9\\leq Y_i\\leq 10^9 , 1\\leq R_i\\leq 10^9$ 分析比较细节的题，听取WA声一片后改起来很烦… 思路其实很简单，就是找到 $X,Y$ 年对应的降水量和 $(X,Y)$ 年间降水量的最大值进行一番比较。 下面分析各种情况对应的结果是什么。 如果 $[X,Y]$ 中所有年份的降水量信息已知。那么当 $R_Y\\leq R_X$ 且 $MAX(X+1,Y-1) &lt; R_Y$ 时，该语句是true，反之则是false。（其中 $MAX(L,R)$ 为 $[L,R]$ 年间已知降水量的最大值） 如果 $X,Y$ 降水量已知。那么当 $R_Y\\leq R_X $ 且 $MAX(X+1,Y-1) &lt; R_Y$ 时，该语句是maybe，反之则是false。 如果 $X,Y$ 已知其一 $Z$ 年的降水量。那么当 $MAX(X+1,Y-1) &lt; R_Z$ 时，该语句是maybe，反之则是false。 如果 $X,Y$ 的降水量皆未知，则该语句是maybe。 由于没有修改操作，因此用Sparse Table来查询区间最大值。 至于如何判断 $X,Y$ 是否降水量已知，可以直接在 $Y[1…N]$ 中二分寻找，复杂度 $O(\\log{N})$； 判断是否 $[X,Y]$ 中所有年份降水量已知，直接检查 $Y-X=P_Y-P_X$ 。（其中 $P_i$ 为 $i$ 在 $Y[1…N]$ 中的下标） 需要特别注意的一点，便是当 $P_Y=P_X+1$ 时， $[X+1,Y-1]\\in \\empty$ 。查询该区间时应该直接返回一个极小值或者单独判断。不然只有稳稳50分…. 复杂度 $O((N+M)\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() {return getchar();}template &lt;class T&gt; inline T gt() {static T x;std::cin &gt;&gt; x;return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') {std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() {static char In[MAXSIZE], *at = In, *en = In;if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin);}return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() {char c;while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {}bool f = c == '-';T x = f ? 0 : c - '0';for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0';}return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() {fwrite(Out, 1, cur - Out, stdout);cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') {static int S[20], *top;top = S;if (x &lt; 0) { *cur++ = '-', x = -x;}do { *++top = x % 10, x /= 10;} while (x);while (top != S) { *cur++ = *top-- + '0';}*cur++ = c;if (cur &gt;= end) { flush();}}#endif} // namespace ioconst int MAXN = 50000 + 5;int A[MAXN], B[MAXN];int F[MAXN][20], Log[MAXN], Pow[20];void buildST(int n) {rep(i, 1, n + 1) { F[i][0] = B[i];}rep(i, 2, n + 1) { Log[i] = Log[i &gt;&gt; 1] + 1;}int k = log2(n);Pow[0] = 1;rep(i, 1, k + 1) { Pow[i] = Pow[i - 1] &lt;&lt; 1;}rep(j, 1, k + 1) { rof(i, n + 1, 1) { if (i + Pow[j - 1] &lt;= n) { F[i][j] = std::max(F[i][j - 1], F[i + Pow[j - 1]][j - 1]); } }}return ;}int queryMax(int l, int r) {if(l &gt; r) { return -1;}int k = Log[r - l + 1];return std::max(F[l][k], F[r - Pow[k] + 1][k]);}int main() {int N = io::gt&lt;int&gt;();rep(i, 1, N + 1) { A[i] = io::gt&lt;int&gt;(); B[i] = io::gt&lt;int&gt;();}buildST(N);int M = io::gt&lt;int&gt;();while (M--) { int x = io::gt&lt;int&gt;(), y = io::gt&lt;int&gt;(); int p1 = std::lower_bound(A + 1, A + N + 1, x) - A; int p2 = std::lower_bound(A + 1, A + N + 1, y) - A; if (A[p1] == x &amp;&amp; A[p2] == y &amp;&amp; p2 - p1 == y - x) { int mx = queryMax(p1 + 1, p2 - 1); if (B[p2] &lt;= B[p1] &amp;&amp; B[p2] &gt; mx) { puts(\"true\"); } else { puts(\"false\"); } } else { if (A[p1] != x &amp;&amp; A[p2] != y) { puts(\"maybe\"); } else if (A[p1] == x &amp;&amp; A[p2] != y) { int mx = queryMax(p1 + 1, p2 - 1); if (mx &lt; B[p1]) { puts(\"maybe\"); } else { puts(\"false\"); } } else if (A[p1] != x &amp;&amp; A[p2] == y) { int mx = queryMax(p1, p2 - 1); if (mx &lt; B[p2]) { puts(\"maybe\"); } else { puts(\"false\"); } } else { int mx = queryMax(p1 + 1, p2 - 1); if (mx &lt; B[p2] &amp;&amp; B[p2] &lt;= B[p1]) { puts(\"maybe\"); } else { puts(\"false\"); } } }}return 0;}","link":"/BZOJ-1067/"},{"title":"「ZJOI 2007」BZOJ 1095 捉迷藏","text":"无权树上有黑点和白点共 $N$ 个，开始均为白点。有 $M$个操作，分为两种：取反点 $x$的颜色或查询树上白点对的最大距离。 $N\\leq 100000, M\\leq 500000$ 分析做的第一道动态点分治的题。。 首先考虑假如没有修改操作，那么求最远白点对只需要点分治，每次在重心合并子树中的最长和次长链，得到最大值。 有了修改，我们考虑动态点分治。 由于树的形态不变，因此各个子树的重心不变。那么我们可以将重心记录下来，形成一棵点分树，点分树上的父亲节点即为上一层重心，儿子节点为各子树重心。根据重心的性质，树高是$O(log{n})$ 的。 发现修改一个点的颜色会对它上级的每一层重心造成影响。 用一个优先队列 $S1[i]$维护子树中每个白点到上一层重心的距离，$S2[i]$维护所有子树中距离的最大值，即所有 $S1$的堆顶。再用一个堆来维护全局答案，即不同的两个 $S2$堆顶之和。 那么修改一个点会导致 $S1$ 发生变化，从而导致上层的 $S2$发生变化，从而导致答案发生变化。 插入删除两点间的距离可以先用ST表预处理出欧拉序对应的深度的区间最小值，做到$O(n\\log{n})$ 预处理，$O(1)$ 查询。 由于我们不知道修改的这个点是否是堆顶，因此插入 /删除前先在上层 $S2$ 中弹出当前 $S1$ 的堆顶，完成对 $S1$的操作后，再重新向 $S2$ 插入最大值。维护答案同理。 在堆中删除元素有一个常见的trick，即用两个堆分别维护所有和已删除的元素，一同弹出堆顶直到堆顶不同为止。 总复杂度 $O((n + m)\\log ^ 2{n})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263/* * @Author: Skqliao * @Source: ZJOI 2007 * @Problem: 1095: [ZJOI2007]Hide 捉迷藏 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1095 * @Date: 2019-02-24 10:24:53 * @LastEditTime: 2019-02-24 15:46:29 */#include &lt;bits/stdc++.h&gt;char In[1 &lt;&lt; 24], *at = In, *en = In;char gc() { if (at == en) { en = (at = In) + fread(In, 1, 1 &lt;&lt; 24, stdin); } return at == en ? EOF : *at++;}int ga() { char c = gc(); while (!isalpha(c)) c = gc(); return c;}int gt() { int x = 0; char c = gc(); while (!isdigit(c)) c = gc(); while (isdigit(c)) { x = x * 10 + c - '0'; c = gc(); } return x;}const int MAXN = 100000 + 5;const int LOG = 18;struct Prioirty_Queue { std::priority_queue&lt;int&gt; In, Out; void insert(int x) { In.push(x); } void erase(int x) { Out.push(x); } void update() { while (!Out.empty() &amp;&amp; In.top() == Out.top()) { In.pop(); Out.pop(); } } void pop() { update(); In.pop(); } int top() { update(); return In.top(); } int secondtop() { int x = top(); pop(); int y = top(); insert(x); return y; } int size() { return In.size() - Out.size(); }} S1[MAXN], S2[MAXN], ans;void Insert(Prioirty_Queue &amp;s) { if (s.size() &gt;= 2) { ans.insert(s.top() + s.secondtop()); }}void Erase(Prioirty_Queue &amp;s) { if (s.size() &gt;= 2) { ans.erase(s.top() + s.secondtop()); }}int N, M;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}int Sz[MAXN], MxSz[MAXN];bool Vis[MAXN];int rt, sigma;int Depth[MAXN];void getRoot(int x, int fa) { MxSz[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa &amp;&amp; !Vis[v]) { getRoot(v, x); MxSz[x] = std::max(MxSz[x], Sz[v]); } } MxSz[x] = std::max(MxSz[x], sigma - Sz[x]); if (MxSz[x] &lt; MxSz[rt]) rt = x;}int Fa[MAXN];void cal(int x, int fa, int dep, Prioirty_Queue &amp;s) { s.insert(dep); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa &amp;&amp; !Vis[v]) { cal(v, x, dep + 1, s); } }}int getSize(int x, int fa) { Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa &amp;&amp; !Vis[v]) { Sz[x] += getSize(v, x); } } return Sz[x];}int Dep[MAXN &lt;&lt; 1][LOG], cntD, Pos[MAXN];int build(int x) { rt = 0; sigma = getSize(x, 0); getRoot(x, 0); int p = rt; Vis[p] = 1; S2[p].insert(0); for (int i = H[p]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (!Vis[v]) { Prioirty_Queue tmp; cal(v, 0, 1, tmp); int p2 = build(v); Fa[p2] = p; S1[p2] = tmp; S2[p].insert(S1[p2].top()); } } Insert(S2[p]); return p;}void dfs(int x, int fa) { Depth[x] = Depth[fa] + 1; Dep[Pos[x] = ++cntD][0] = Depth[x]; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa) { dfs(v, x); Dep[++cntD][0] = Depth[x]; } }}int Log[MAXN &lt;&lt; 1], Bin[LOG];int queryLcaDepth(int x, int y) { x = Pos[x], y = Pos[y]; if (x &gt; y) std::swap(x, y); int d = Log[y - x + 1]; return std::min(Dep[x][d], Dep[y - Bin[d] + 1][d]);}int queryDis(int x, int y) { return Depth[x] + Depth[y] - 2 * queryLcaDepth(x, y); }void turnOn(int x) { Erase(S2[x]); S2[x].insert(0); Insert(S2[x]); for (int i = x; Fa[i]; i = Fa[i]) { Erase(S2[Fa[i]]); if (S1[i].size()) { S2[Fa[i]].erase(S1[i].top()); } S1[i].insert(queryDis(Fa[i], x)); if (S1[i].size()) { S2[Fa[i]].insert(S1[i].top()); } Insert(S2[Fa[i]]); }}void turnOff(int x) { Erase(S2[x]); S2[x].erase(0); Insert(S2[x]); for (int i = x; Fa[i]; i = Fa[i]) { Erase(S2[Fa[i]]); if (S1[i].size()) { S2[Fa[i]].erase(S1[i].top()); } S1[i].erase(queryDis(Fa[i], x)); if (S1[i].size()) { S2[Fa[i]].insert(S1[i].top()); } Insert(S2[Fa[i]]); }}bool Status[MAXN];int main() { N = gt(); for (int i = 1; i &lt; N; ++i) { addEdge(gt(), gt()); } MxSz[0] = N; build(1); dfs(1, 0); Log[0] = -1; for (int i = 1; i &lt;= cntD; ++i) { Log[i] = Log[i &gt;&gt; 1] + 1; } Bin[0] = 1; for (int i = 1; i &lt;= Log[cntD]; ++i) { Bin[i] = Bin[i - 1] &lt;&lt; 1; } for (int j = 1; j &lt;= Log[cntD]; ++j) { for (int i = 1; i + Bin[j - 1] - 1 &lt;= cntD; ++i) { Dep[i][j] = std::min(Dep[i][j - 1], Dep[i + Bin[j - 1]][j - 1]); } } std::fill(Status + 1, Status + N + 1, 1); int cnt = N; M = gt(); for (int i = 1; i &lt;= M; ++i) { if (ga() == 'G') { if (cnt &lt; 2) { printf(\"%d\\n\", cnt - 1); } else { printf(\"%d\\n\", ans.top()); } } else { int u = gt(); if (Status[u]) { --cnt; turnOff(u); } else { ++cnt; turnOn(u); } Status[u] ^= 1; } } return 0;}","link":"/BZOJ-1095/"},{"title":"「ZJOI 2007」BZOJ 1096 仓库建设","text":"从左到右有若干个点，点 $1$ 和点 $i$ 的距离为 $D_i$，点 $i$ 有 $A_i$ 个货物，在点 $i$ 建仓库的费用为 $C_i$。现要在若干个点建造仓库，使得每个点的货物向右能移动到某个仓库中，每个货物运动 $1$ 距离的花费为 $1$。求建造与移动的总花费的最小值。 $N\\leq 1000000$ 分析转移方程显然为 $F_i=\\min\\limits_{1\\leq j &lt; i}{(F_j+\\sum\\limits_{k=j+1}^{i}{(D_i-D_k)\\cdot A_k})} +C_i$。 设 $Y_i=\\sum\\limits_{j=1}^{i}{A_j\\cdot D_j}$，$S_i=\\sum\\limits_{j=1}^{i}{A_j}$。若点 $k$ 优于点 $j(j &lt; k)$，则满足 $\\frac{F_k-F_j+Y_k-Y_j}{S_k-S_j} &gt; D_i$ 维护斜率单调递增的决策点队列，且队首斜率大于 $D_i$。 复杂度 $O(n)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839/* * @Author: Skqliao * @Source: ZJOI 2007 * @Problem: 1096: [ZJOI2007]仓库建设 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1096 * @Date: 2019-02-25 19:14:22 * @LastEditTime: 2019-02-25 20:02:31 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000000 + 5;int N;long long D[MAXN], A[MAXN], C[MAXN];long long S[MAXN], Y[MAXN], F[MAXN];int Que[MAXN], qh, qt;double slope(int j, int k) {return (double)(F[k] - F[j] + Y[k] - Y[j]) / (S[k] - S[j]);}int main() {scanf(\"%d\", &amp;N);for (int i = 1; i &lt;= N; ++i) { scanf(\"%lld%lld%lld\", &amp;D[i], &amp;A[i], &amp;C[i]); S[i] = S[i - 1] + A[i]; Y[i] = Y[i - 1] + A[i] * D[i];}Que[qt] = 0;for (int i = 1; i &lt;= N; ++i) { while (qt &gt; qh &amp;&amp; slope(Que[qh], Que[qh + 1]) &lt;= D[i]) ++qh; int j = Que[qh]; F[i] = F[j] + (S[i] - S[j]) * D[i] - Y[i] + Y[j] + C[i]; while (qt &gt; qh &amp;&amp; slope(Que[qt - 1], Que[qt]) &gt;= slope(Que[qt], i)) --qt; Que[++qt] = i;}printf(\"%lld\\n\", F[N]);return 0;}","link":"/BZOJ-1096/"},{"title":"「CTSC 2008」BZOJ 1143 祭祀river","text":"求有向无环图的最长反链，反链中任意两点不联通。 $N\\leq 100,M\\leq 1000$ 分析传递闭包后做二分图最大匹配，答案为点数-最大匹配数。 复杂度 $O(NM)$ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * @Author: Skqliao * @Source: CTSC 2008 * @Problem: 1143: [CTSC2008]祭祀river * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1143 * @Date: 2019-03-05 21:15:32 * @LastEditTime: 2019-03-05 21:29:55 */#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;int N, M;std::bitset&lt;MAXN&gt; B[MAXN];bool Vis[MAXN];int Match[MAXN];int dfs(int x) {if (Vis[x]) return 0;Vis[x] = 1;for (int i = 1; i &lt;= N; ++i) { if (B[x][i] &amp;&amp; (!Match[i] || dfs(Match[i]))) { Match[i] = x; return 1; }}return 0;}int main() {int u, v;scanf(\"%d%d\", &amp;N, &amp;M);for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); B[u][v] = 1;}for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { if (B[i][j]) B[i] |= B[j]; }}int ans = 0;for (int i = 1; i &lt;= N; ++i) { memset(Vis, 0, sizeof Vis); ans += dfs(i);}printf(\"%d\\n\", N - ans);return 0;}","link":"/BZOJ-1143/"},{"title":"「CTSC 2007」BZOJ 1150 数据备份","text":"直线上有 $N$ 个点，距离原点距离分别为 $A_i$ 。有 $M$ 条线用来连接。每条线连接两个点，且每个点只能被连接一次，线的长度为两点间的距离。求这些线长度和的最小值。 $2\\leq N\\leq 100000, A_i \\leq 1000000000$ 分析很显然的是，线连接的一定是相邻的两个点，因此原本的 $N$ 个点被差分成 $N-1$ 条线段，记 $len(i,i+1)$ 表示点 $i$ 和 $i+1$ 点之间的距离。 考虑贪心，每次取距离最小的两个点连接。但是这么做是显然错误的，例如 1 3 50 100 且 $M=2$ 。 因为选完 $(i-1,i)$ 之后，会导致 $(i-2,i-1)$ 和 $(i,i+1)$ 不能再选，这就是直接贪心错误的问题所在。 因此它需要一个可以「反悔」的机制。 如果选择完 $(i-1,i)$ 后反悔，那么意味着它会去应该选择 $(i-2,i-1)$ 或 $(i,i+1)$ 。 那么取出 $len(i-1,i)$ 后，只需加入 $len(i-2,i-1)+len(i,i+1)-len(i-1,i)$ ，这意味着它可以将已经选择的 $(i-1,i)$ 反悔成 $(i-2,i-1)$ 和 $(i,i+1)$ （反悔加上当前这次所以是一共选择 $2$ 条线段）。 当然反悔 $(i-1,i)$ 不代表 $(i-2,i-1)$ 和 $(i,i+1)$ 都要选，可能只选择其中一个。不过对于它们同样可以继续反悔从而找到更优的策略，因此这个贪心是成立的。 记录每个点（线段抽象成点看待）的前驱后继，每次选择一条线段相当于删除这个点，与此同时更新前驱后继。 可以通过堆来实现，但是需要记录的东西会多一些。所以我选择直接使用 std::set ，它可以直接删除非堆顶的元素。当然实测它也要慢一些。 需要注意一下边界取值以及溢出。 复杂度 $O(M\\log{N})$ 。 类似的题：夹克老爷的逢三抽一 ，是对此题模型展开后的描述。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 1e5 + 5;int N, M;ll A[MAXN];int Lst[MAXN], Nxt[MAXN];std::set&lt;std::pair&lt;ll, int&gt; &gt; Set;void insert(int x) {Set.insert(std::make_pair(A[x], x));}void erase(int x) {Set.erase(std::make_pair(A[x], x));}void del(int p) {Nxt[Lst[p]] = Nxt[p];Lst[Nxt[p]] = Lst[p];erase(p);}int main() {ll res = 0;scanf(\"%d%d\", &amp;N, &amp;M);rep(i, 1, N + 1) { scanf(\"%lld\", &amp;A[i]); if (i &gt; 1) { A[i - 1] = A[i] - A[i - 1]; insert(i - 1); } Lst[i] = i - 1; Nxt[i] = i + 1;}A[0] = 1000000000LL + 5;rep(i, 0, M) { int p = Set.begin()-&gt;second; ll l = A[Lst[p]], x = A[p], r = A[Nxt[p]]; res += x; del(Lst[p]), del(Nxt[p]); erase(p); A[p] = l + r - x; insert(p);}printf(\"%lld\\n\", res);return 0;}","link":"/BZOJ-1150/"},{"title":"「HNOI 2005」BZOJ 1202 狡猾的商人","text":"给定 $M$ 组关于 $l, r, x$ 的等式，意为 $\\sum\\limits_{i=l}^{r}{A_i}=x$，判断是否可以构造出 $A[1\\cdots N]$ 满足这些等式。 $N\\leq 100,M\\leq 1000$ 分析将等式写成前缀和的形式，用 $Sum[i]$ 表示 $\\sum\\limits_{j=1}^{i}{A_j}$ ，等式化为 $Sum[r] - Sum[l-1] = x$。 可以将等式变形成两个不等式， $Sum[r] - Sum[l-1] \\geq x$ 和 $Sum[l - 1] - Sum[r] \\geq -x$ 。 那么原问题就转化为差分约束系统求解模型。连接边 $(l - 1, r, x)$ 和 $(r, l - 1, -x)$ ，SPFA判断是否存在负环，复杂度 $O(NM)$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;const int MAXN = 100 + 5;const int MAXM = 1000 + 5;int N, M;struct Edge {int v, w, nxt;} E[MAXM * 3];int H[MAXN], cntE;void addEdge(int u, int v, int w) {E[++cntE] = (Edge) {v, w, H[u]};H[u] = cntE;}std::queue&lt;int&gt; Que;int Dis[MAXN], Cnt[MAXN], Inq[MAXN];bool Vis[MAXN];int n;bool spfa() {while (!Que.empty()) { Que.pop();}memset(Dis, 0x3f, sizeof Dis);memset(Inq, 0, sizeof Inq);memset(Cnt, 0, sizeof Cnt);Que.push(N + 1);Dis[N + 1] = 0;while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Cnt[v] = Cnt[x] + 1; if (Cnt[v] &gt; n) { return false; } if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } }}return true;}void init() {cntE = 0;memset(H, 0, sizeof H);n = 0;memset(Vis, 0, sizeof Vis);}int main() {int T, u, v, w;scanf(\"%d\", &amp;T);while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); init(); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); if (!Vis[u - 1]) { Vis[u - 1] = 1; ++n; } if (!Vis[v]) { Vis[v] = 1; ++n; } addEdge(u - 1, v, -w); addEdge(v, u - 1, w); } for (int i = 1; i &lt;= N; ++i) { addEdge(N + 1, i, 0); } if (spfa()) { puts(\"true\"); } else { puts(\"false\"); }}return 0;}","link":"/BZOJ-1202/"},{"title":"「HNOI 2004」BZOJ 1212 L语言","text":"有 $N$ 个字符串作为字典，一个字符串能被该字典理解当且仅当它可以被拆成若干个字串，每个字串都是字典中的单词。 现每次查询某个字符串 $S_i$ 能被该字典理解的最长前缀大小，查询 $M$ 次。 $1\\leq N,M\\leq 20$，单词长度不超过 $10$ ，$S_i$ 的长度不超过 $1M$。 分析看到多个字符串做字典查询，想到Trie树。 Trie树能够进行字符串的最长前缀匹配，很明显与这道题关系密切。 记 $F_i = 1$ 当 $S[0…i]$ 能被若干个单词拼接而成，如果 $S[i+1…k]$ 也能被若干个单词拼接，那么 $F_k=1$ 。 因此在进行匹配过程中，如果中间恰好为某个单词的结束，那么置对应位置的 $F$ 值为 $1$ 。 进行以 $S[i]$ 为首的字符串匹配的条件为 $F_{i-1}=1$ （ $S[0]$ 除外）。 那么答案满足即为满足 $F_i=1$ 的最大值。 复杂度不好分析，为 $O(\\sum{len})$ 级别。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 1000 + 5;const int MAXM = 1024 * 1024 + 5;struct Node {static const int MAX_SIZE = 26;bool flag;int Nxt[MAX_SIZE];}Pool[MAXN];int cntP = -1, root;int newNode() {Node &amp;x = Pool[++cntP];x.flag = 0;memset(x.Nxt, -1, sizeof x.Nxt);return cntP;}void insert(int rt, char *S) {while(*S) { int id = *S++ - 'a'; if(!~Pool[rt].Nxt[id]) { Pool[rt].Nxt[id] = newNode(); } rt = Pool[rt].Nxt[id];}Pool[rt].flag = true;}void match(int rt, char *S, int st, int F[]) {char *s = S + st;while(*s) { int id = *s++ - 'a'; if(!~Pool[rt].Nxt[id]) { return ; } rt = Pool[rt].Nxt[id]; if(Pool[rt].flag) { F[s - S] = 1; }}}int solve(char *S) {static int F[MAXM];memset(F, 0, sizeof F);match(root, S, 0, F);F[0] = 1;rep(i, 1, strlen(S)) { if(F[i]) { match(root, S, i, F); }}rof(i, strlen(S) + 1, 0) { if(F[i]) { return i; }}}int main() {int n, m;root = newNode();char Str[MAXM];scanf(\"%d%d\", &amp;n, &amp;m);rep(i, 0, n) { scanf(\"%s\", Str); insert(root, Str);}rep(i, 0, m) { scanf(\"%s\", Str); printf(\"%d\\n\", solve(Str));}return 0;}","link":"/BZOJ-1212/"},{"title":"「HNOI 2004」BZOJ 1208 宠物收养所","text":"有两个正整数集合 $A,B$ ，起初都是它们都是空集。 现按顺序插入 $N$ 个数 $A[1…N]$，每个数属于 $A$ 或 $B$ 。 如果插入的数 $x$ 属于集合 $A$ ，当集合 $B$ 不为空时，删去 $B$ 中 与 $x$ 差绝对值最小的数 $y$ 。如果存在 $b = x+a,c=x-a$ ，则优先删去 $c$ 。该操作的代价为两数差的绝对值。当集合 $B$ 为空时，将 $x$ 直接插入集合 $A$ 中，没有代价。 如果插入的数属于集合 $B$ ，操作同理。 求插入完 $N$ 个数后的代价，答案对 $1000000$ 取模。 $N\\leq 80000,0&lt; A_i&lt; 2^{31}$ 分析根据题意可得，在任何时候集合 $A,B$ 至少有一个为空，因此只需要维护一个集合。 通过Treap等数据结构维护当前有数的集合。每次插入 $x$ 后，查询集合中 $x$ 的前驱后继，取较小值删去，并计算代价。 由于可能存在没有前驱后继的情况，初始化时插入一个极大值和一个极小值可以避免各种讨论，当树的 $size=2$ 时认为其为空即可。 复杂度 $O(N\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() {return getchar();}template &lt;class T&gt; inline T gt() {static T x;std::cin &gt;&gt; x;return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') {std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() {static char In[MAXSIZE], *at = In, *en = In;if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin);}return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() {char c;while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {}bool f = c == '-';T x = f ? 0 : c - '0';for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0';}return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() {fwrite(Out, 1, cur - Out, stdout);cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') {static int S[20], *top;top = S;if (x &lt; 0) { *cur++ = '-', x = -x;}do { *++top = x % 10, x /= 10;} while (x);while (top != S) { *cur++ = *top-- + '0';}*cur++ = c;if (cur &gt;= end) { flush();}}#endif} // namespace ioconst int MAXN = 80000 + 5;struct TreapTree {struct Treap { int key, fix; int cnt, sz; Treap *ch[2]; int cmp(int x) { return key == x ? -1 : key &lt; x; } void pushUp() { sz = cnt; if (ch[0]) { sz += ch[0]-&gt;sz; } if (ch[1]) { sz += ch[1]-&gt;sz; } }} Pool[MAXN], *R;int cntP;Treap* newTreap(int x) { Pool[++cntP] = (Treap) {x, rand(), 1, 1, NULL, NULL}; return &amp;Pool[cntP];}void rotate(Treap* &amp;t, int d) { Treap* k = t-&gt;ch[d ^ 1]; t-&gt;ch[d ^ 1] = k-&gt;ch[d]; k-&gt;ch[d] = t; t-&gt;pushUp(); k-&gt;pushUp(); t = k;}void insert(Treap* &amp;t, int x) { if (!t) { t = newTreap(x); return ; } int d = t-&gt;cmp(x); ++t-&gt;sz; if (d == -1) { ++t-&gt;cnt; } else { insert(t-&gt;ch[d], x); if (t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix) { rotate(t, d ^ 1); } }}void erase(Treap* &amp;t, int x) { if (!t) { return ; } int d = t-&gt;cmp(x); if (d == -1) { if (t-&gt;cnt &gt; 1) { --t-&gt;cnt; --t-&gt;sz; } else if (!t-&gt;ch[0]) { t = t-&gt;ch[1]; } else if (!t-&gt;ch[1]) { t = t-&gt;ch[0]; } else { int e = t-&gt;ch[0]-&gt;fix &gt; t-&gt;ch[1]-&gt;fix; rotate(t, e); erase(t-&gt;ch[e], x); } } else { erase(t-&gt;ch[d], x); } if (t) { t-&gt;pushUp(); }}int res;void queryPre(Treap* &amp;t, int x) { if (!t) { return ; } if (t-&gt;key &lt;= x) { res = t-&gt;key; queryPre(t-&gt;ch[1], x); } else { queryPre(t-&gt;ch[0], x); }}void querySub(Treap* &amp;t, int x) { if (!t) { return ; } if (t-&gt;key &gt;= x) { res = t-&gt;key; querySub(t-&gt;ch[0], x); } else { querySub(t-&gt;ch[1], x); }}} T;int main() {int N = io::gt&lt;int&gt;();int type;ll res = 0;T.insert(T.R, -INT_MAX);T.insert(T.R, INT_MAX);while (N--) { int opt = io::gt&lt;int&gt;(); int x = io::gt&lt;int&gt;(); if (T.R-&gt;sz == 2 || type == opt) { T.insert(T.R, x); type = opt; } else { T.queryPre(T.R, x); int pre = T.res; T.querySub(T.R, x); int sub = T.res; if (pre == -INT_MAX) { res += sub - x; T.erase(T.R, sub); } else if (sub == INT_MAX) { res += x - pre; T.erase(T.R, pre); } else { if (x - pre &lt;= sub - x) { res += x - pre; T.erase(T.R, pre); } else { res += sub - x; T.erase(T.R, sub); } } }}printf(\"%lld\\n\", res % 1000000);return 0;}","link":"/BZOJ-1208/"},{"title":"「HNOI 2002」BZOJ 1224 彩票","text":"从 $[1,M]$ 中选取 $N$ 个不同整数 $A_i$，使得 $\\sum{\\frac{1}{A_i}} = \\frac{p}{q}$ 。求有多少种不同选法。 $1\\leq p,q\\leq 100$，$1\\leq N\\leq10$，$1\\leq M\\leq 50$，结果不超过 $10^5$。 分析看到这个数据范围，$N\\leq 10$，比较显然是一个搜索+剪枝。 那么如何剪枝？ 最简单的便是如果当前没选完且 $sum\\geq \\frac{p}{q}$ ，那么就立即返回。 还有两个比较显然的优化。 假设顺序搜索，当前值为 $x$ ，当前和为 $sum$ ，剩余选取 $n$ 个数。 那么如果可能得到 $\\frac{p}{q}$ ，至少要满足$sum + \\frac{1}{x} n \\geq \\frac{p}{q}$ 且 $sum + \\frac{1}{M} n\\leq \\frac{p}{q}$ 。 即当前值加上选取剩余数的最小值 $min$ 一定小于结果，加上最大值 $max$ 一定大于结果，否则不可能存在 $min\\leq a\\leq max$ 使得 $sum + a = \\frac{p}{q}$ 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const double eps = 1e-10;int N, M, X, Y;int ans;double goal;void dfs(int x, int total, double sum) { if(goal - sum - 1.0 / x * (N - total) &gt; eps) { return ; } if(sum + 1.0 / M * (N - total) - goal &gt; eps) { return ; } if(total == N) { if(fabs(sum - goal) &lt;= eps) { ++ans; } return ; } if(x &lt;= M) { dfs(x + 1, total + 1, sum + 1.0 / x); dfs(x + 1, total, sum); }}int main() { scanf(\"%d%d%d%d\", &amp;N, &amp;M, &amp;X, &amp;Y); goal = 1.0 * X / Y; dfs(1, 0, 0); printf(\"%d\\n\", ans); return 0;}`","link":"/BZOJ-1224/"},{"title":"BZOJ 1312 Neerc2006 Hard Life","text":"无向图 $G$ 有 $n$ 个点 $m$ 条边，对于任意子图 $G’\\in G$，定义它的权值为 $|E|/|V|$，其中 $|E|,|V|$ 分别为子图的边数和点数。求在最大化子图权值的条件下，子图点数的最大值。 $n\\leq 100,m\\leq 1000$ 分析如果将 $|E|,|V|$ 拓展为边权和与点权和，那么最大化子图 $|E|/|V|$ 即求最大密度子图。而本题只是边权点权皆为 $1$ 的特殊情况。 对于这类问题，可采用分数规划+最小割来解决。 首先二分 $k=|E|/|V|$，则 $|E| = k\\cdot |V|$。如果两个点被选择，则可以获得这条边的权值，由此问题可以转化为求最大权闭合子图。 将每条边 $(u_i,v_i)$ 抽象为新点 $A_i$，连接 $(S,A_i)$，容量为 $1$。$A_i$ 向 $u_i,v_i$ 连接容量为无穷的边。原点向 $T$ 连边，容量为二分的 $k$ 值。 二分 $k$ 直到求得最大权闭合子图权值 $&lt; 0$ 为止。 既然要求在最大化权值情况下的点个数的最大值，那么再跑一遍最小割（$k$ 取允许的最大值），与 $S$ 联通的原点即为子图的点。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* * @Author: Skqliao * @Date: 2019-02-12 18:50:43 * @LastEditTime: 2019-02-12 22:17:09 * @Source: BZOJ * @Problem: Neerc2006 Hard Life * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1312 */#include &lt;bits/stdc++.h&gt;const int MAXN = 2100 + 5;const int MAXM = MAXN * 5;const double eps = 8e-6;struct Edge { int v; double f, cap; int nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Cur[MAXN], Dis[MAXN];int S, T;void addEdge(int u, int v, double f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, 0, 0, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); if (x == T) return true; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f &gt; eps) { Dis[v] = Dis[x] + 1; Que.push(v); } } } return false;}double dfs(int x, double maxf) { if (x == T) return maxf; double left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f &gt; eps) { double flow = dfs(v, std::min(left, E[i].f)); if (flow &gt; eps) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (left &lt; eps) return maxf; } else Dis[v] = -1; } } return maxf - left;}double dinic() { double flow = 0; while (bfs()) { flow += dfs(S, INT_MAX); } return flow;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}int N, M;bool check(double x) { for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } for (int i = 1; i &lt;= N; ++i) { for (int j = H[i]; ~j; j = E[j].nxt) { if (E[j].v == T) { E[j].f = E[j].cap = x; } } } return M - dinic() &gt; eps;}int main() { int u, v; scanf(\"%d%d\", &amp;N, &amp;M); if (M == 0) { puts(\"1\"); return 0; } init(N + M); for (int i = 1; i &lt;= N; ++i) { addEdge(i, T, 0); } for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(S, i + N, 1); addEdge(i + N, u, INT_MAX); addEdge(i + N, v, INT_MAX); } double l = 0, r = M; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { l = m; } else r = m; } check(l - eps); int ans = 0; for (int i = 1; i &lt;= N; ++i) { if (Dis[i] != -1) ++ans; } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-1312/"},{"title":"「CQOI 2009」BZOJ 1304 叶子的颜色","text":"树上有 $N$ 个节点，其中 $1-M$ 是叶子节点。每个节点可以被染成黑、白，或者不染色。指定某个不是叶子节点的节点作为根，要求给若干个节点染色后使得每个叶子节点到根的路径中第一个被染色节点的颜色为 $C_i$ 。求需要染色的节点的最少个数。 $N\\leq 1000$ 。 分析假设根已经存在，那么这个树形DP很简单。用 $F[x][0/1]$ 表示染完以 $x$ 为根的子树且将 $x$ 染成 $0/1$ 所需要的染色的最少节点数。 则： $F[x][0] = 1 +\\sum{\\min(F[son][0]-1,F[son][1])}$ $F[x][1] = 1 + \\sum{\\min(F[son][1]-1,F[son][0])}$ $F[x][!C_x] = +\\infty (x\\leq M)$ 但是这道题没有指定根，则继续考虑不同根对染色节点数的影响。 假设将根节点 $R$ 修改为 $R$ 的某个儿子$S$（移动了一条边），由于 $S$ 和 $R$ 的颜色必定不同（否则原先就不需要染 $S$) ，因此换根后答案不变。 因此根可以随意移动，也就是说随意选择一个非叶子节点为根，答案均不变。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 10000 + 5;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; }int N, M, C[MAXN];int F[2][MAXN];void dfs(int x, int fa) { F[0][x] = F[1][x] = 1; if(x &lt;= M) { F[C[x]^1][x] = INT_MAX; } for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != fa) { dfs(v, x); F[1][x] += std::min(F[1][v] - 1, F[0][v]); F[0][x] += std::min(F[0][v] - 1, F[1][v]); } }}int main() { int u, v; scanf(\"%d%d\", &amp;N, &amp;M); rep(i, 1, M + 1) { scanf(\"%d\", &amp;C[i]); } rep(i, 1, N) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); } dfs(M + 1, -1); printf(\"%d\\n\", std::min(F[0][M + 1], F[1][M + 1])); return 0;}","link":"/BZOJ-1304/"},{"title":"「Baltic2004」BZOJ 1367 sequence","text":"对于序列 $A_1,A_2,\\cdots,A_n$ ，构造递增序列 $B_1,B_2,\\cdots,B_n$ ，使得$R=\\sum{|A_i-B_i|}$ 最小。求 $R$ 的最小值。 $n\\leq 10^6,A_i\\leq 2\\times 10^9$ 。 分析这是2005年黄清河同学的集训队论文《左偏树的特点及其应用》中的例题。 那我就简化一下他的分析求解，给出基本思路和解法。 首先， $A$ 有两种极端情况： $A_1\\leq A_2\\leq \\cdots\\leq A_n$ ，此时 $B_i = A_i$ 时 $R$ 最小（也可以理解为 $B_i$ 取 $[A_i,A_i]$ 的中位数）； $A_1 \\geq A_2\\geq \\cdots \\geq A_n$ ，此时 $B_1,\\cdots,B_n$ 取 $[A_1,A_n]$ 的中位数时 $R$ 最小； 而如果 $A$ 不是单调的，也可以由若干个小的单调区间组成。 那么把 $A$ 分成 $M$ 个区间，每个区间对应一个解 $W_i$ ，$W_i$ 为 $A$ 在该区间的中位数。（最优性通过归纳法证明，详情可以自行翻阅论文） 那么当 $A_1,\\cdots,A_k$ 已经得到最优解 $W_1,\\cdots,W_p$ ，那么新插入 $A_{k+1}$ ，先将 $A_{k+1}$ 视作单独的一个区间，则该区间的解 $W_{p+1}=A_{k+1}$ 。 但是要求 $B$ 是单调递增的，因此若 $W_{p+1} &lt; W_{p}$ ，则需要将这两个解合并，直到 $W$ 满足单调性为止。 而新区间的最优解（即 $W_p$ 和 $W_{p+1}$ 合并后），应该为大区间的中位数。那如何快速得到新区间的中位数呐？ 第一种想法就是每个区间建一棵平衡树，启发式合并两棵树，并查询第 $K$ （树大小一半）大得到新的中位数。复杂度 $O(n\\log{n})$ 。 但是我们发现这样做复杂度较高，为 $O(n^2\\log{n})$ ，需要更快速的方法。 考虑中位数的定义，中位数的值为 $A[\\lfloor\\frac{n}{2}\\rfloor+1]$ 。也就是说集合中有恰好 $\\lfloor\\frac{n}{2}\\rfloor$ 个数小于它。 那么构造一个大根堆，包含集合中较小的一半元素，堆顶就是中位数。 合并两个堆，如果堆中元素个数超过新区间大小的一半，就将多余的全部弹出，则新的堆顶就是新区间的中位数。 通过左偏树实现大根堆，合并的复杂度为 $O(\\log{n})$ 。 需要注意的是，由于要求 $B$ 是单调递增而不是不递减的，因此需要将 $A_i$ 预处理为 $A_i-i$ 。 如此总复杂度降至 $O(n\\log{n})$ 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 1e6 + 5;struct Leftist { struct Node { int key, sz; int lc, rc, dis; bool operator &lt; (const Node &amp;x) const { return key &gt; x.key; } } A[MAXN]; int tot; int merge(int x, int y) { if(!x || !y) { return x + y; } if(A[y] &lt; A[x]) { std::swap(x, y); } Node &amp;a = A[x]; a.rc = merge(a.rc, y); a.sz = A[a.lc].sz + A[a.rc].sz + 1; if(A[a.rc].dis &gt; A[a.lc].dis) { std::swap(a.lc, a.rc); } a.dis = A[a.rc].dis + 1; return x; } int push(int x) { A[++tot] = (Node) {x, 1, 0, 0, 0}; return tot; } int size(int x) { return A[x].sz; } int top(int x) { return A[x].key; } int pop(int x) { return merge(A[x].lc, A[x].rc); }} T;int A[MAXN], Rt[MAXN], L[MAXN], R[MAXN];int main() { int N; scanf(\"%d\", &amp;N); rep(i, 1, N + 1) { scanf(\"%d\", &amp;A[i]); A[i] -= i; } int cnt = 0; rep(i, 1, N + 1) { Rt[++cnt] = T.push(A[i]); L[cnt] = R[cnt] = i; while(cnt &gt; 1 &amp;&amp; T.top(Rt[cnt]) &lt; T.top(Rt[cnt - 1])) { --cnt; Rt[cnt] = T.merge(Rt[cnt], Rt[cnt + 1]); R[cnt] = R[cnt + 1]; while(T.size(Rt[cnt]) * 2 &gt; R[cnt] - L[cnt] + 2) { Rt[cnt] = T.pop(Rt[cnt]); } } } ll ans = 0; rep(i, 1, cnt + 1) { int x = T.top(Rt[i]); rep(j, L[i], R[i] + 1) { ans += abs(x - A[j]); } } printf(\"%lld\\n\", ans); return 0;}","link":"/BZOJ-1367/"},{"title":"BZOJ 1455 罗马游戏","text":"有 $N$ 个集合，每个集合中包含一个元素 $A_i$ 。有 $M$ 个操作：将 $x,y$ 所在的集合合并；查询并删去 $x$ 所在集合中元素的最小值。 $N\\leq 1000000, M\\leq 100000$ 分析如果没有合并集合的操作，直接使用stl的priority_queue即可完成所有查询删除的操作。 支持合并的堆的有不少，左偏树（leftist tree）就是其中之一。 左偏树合并复杂度为 $O(\\log{n_1}+\\log{n_2})=O(\\log{n})$ ，查询堆顶复杂度 $O(1)$ ，删除堆顶复杂度 $O(\\log{n})$，插入新节点复杂度 $O(\\log{n})$ ，修改节点权值复杂度 $O(n)$。 用并查集维护点所在的集合，左偏树维护查询/删除与合并。复杂度 $O(M(\\alpha(N)+\\log{N}))$ 。 当然，pb_ds的priority_queue是支持合并的，默认是配对堆（pairing heap），各项操作的复杂度均不差于左偏树，修改的复杂度更低，为 $O(\\log{n})$ 。 但是由于本题中没有涉及decrease key的操作，因此复杂度相同。 不过开N个priority_queue似乎空间占用较大，直接MLE了。 我猜N是100w的原因的其中之一就是为了卡pbds，而配对堆的空间复杂度本就高于左偏树。 因此还是乖乖写左偏树吧。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 1000000 + 5;struct Union { int Anc[MAXN]; void init(int n) { rep(i, 1, n + 1) { Anc[i] = i; } } int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]); }} S;struct Leftist { struct Node { int key; int lc, rc, dis; Node (): key(0), lc(0), rc(0), dis(0) {} bool operator &lt; (const Node &amp;x) const { return key &lt; x.key; } } A[MAXN]; void init(int n) { rep(i, 1, n + 1) { scanf(\"%d\", &amp;A[i].key); } A[0].dis = -1; } int merge(int x, int y) { if(!x || !y) { return x + y; } if(A[y] &lt; A[x]) { std::swap(x, y); } Node &amp;a = A[x]; a.rc = merge(a.rc, y); if(A[a.rc].dis &gt; A[a.lc].dis) { std::swap(a.lc, a.rc); } a.dis = A[a.rc].dis + 1; return x; } int get_min(int x) { return A[x].key; } int delete_min(int x) { A[x].key = -1; return merge(A[x].lc, A[x].rc); }} T;int main() { int N, M, x, y; char opt[10]; scanf(\"%d\", &amp;N); T.init(N); S.init(N); scanf(\"%d\", &amp;M); while(M--) { scanf(\"%s\", opt); if(opt[0] == 'M') { scanf(\"%d%d\", &amp;x, &amp;y); if(T.get_min(x) == -1 || T.get_min(y) == -1) { continue; } x = S.findAnc(x), y = S.findAnc(y); if(x != y) { int bl = T.merge(x, y); S.Anc[x] = S.Anc[y] = bl; } } else { scanf(\"%d\", &amp;x); if(T.get_min(x) == -1) { puts(\"0\"); } else { x = S.findAnc(x); printf(\"%d\\n\", T.get_min(x)); int bl = T.delete_min(x); S.Anc[x] = S.Anc[bl] = bl; } } } return 0;}","link":"/BZOJ-1455/"},{"title":"「HNOI 2009」BZOJ 1486 最小圈","text":"在有向图 $G$ 中，定义环 $a$ 的权值 $w_a=\\sum{W[i]}/num$，其中 $W[i]$ 为 $a$ 上边的权值， $num$ 为 $a$ 上的节点数。求图中 $w$ 的最小值。 $n\\leq 1000,m\\leq 5000,|W[i]|\\leq 5000$ 分析设 $w_a=x$，则 $\\sum{W[i]}/num \\geq x$，即 $\\sum{W[i]}\\geq num\\cdot x$。 由于环上点数和边数相同，因此可以改写为 $\\sum(W[i]-x)\\geq 0$。 $x$ 显然可以二分，于是就变成了判断图中是否存在负环的问题，用SPFA可解。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;const int MAXN = 3000 + 5;const int MAXM = 10000 + 5;const double INF = 1e7;const double eps = 1e-9;int N, M;struct Edge { int v; double w; int nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}double Dis[MAXN];bool Vis[MAXN], flag;bool dfs_spfa(int x, double xx) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; double dis = Dis[x] + E[i].w - xx; if (Dis[v] &gt; dis) { Dis[v] = dis; if (Vis[v] || dfs_spfa(v, xx)) { return true; } } } return Vis[x] = 0;}bool check(double a) { flag = 0; for (int i = 1; i &lt;= N; ++i) { Dis[i] = INF; } memset(Vis, 0, sizeof Vis); for (int i = 1; i &lt;= N; ++i) { if (dfs_spfa(i, a)) { return true; } } return false;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); int u, v; double w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%lf\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } double l = -INF, r = INF, ans = 0; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { r = m; ans = m; } else { l = m; } } printf(\"%.8lf\\n\", ans); return 0;}","link":"/BZOJ-1486/"},{"title":"「NOI 2006」BZOJ 1497 最大获利","text":"有 $N$ 个点，选择点 $i$ 花费 $A_i$ 的代价。有 $M$ 个关系，如果点 $x_i,y_i$ 均被选择，则可以获得收益 $B_i$。求收益-代价的最大值。 $N\\leq 5000,M\\leq 50000$ 分析这类问题也是常见的二元关系类题目，称之为最大权闭合子图。 将每个点的花费作为该点的点权（负数），将两点间的边抽象成一个点，点权为收益，新点向这两个点连有向边。 那么如果选择收益对应的点，就必须也选择其所有后继。最终求选择的子图点权和的最大值，这正是求最大权闭合子图。 根据相关建图方法，该问题可以转化为求最小割。 $S$ 向所有正点权的点连边，容量为该点点权。所有负权点向 $T$ 连边，容量为点权的绝对值。原图的所有边保留，容量为无穷大。则原图的最大权闭合子图的权值和为原图中所有正点权权值之和-新图最小割。 简易证明如下： 考虑一条有向边 $x\\rightarrow y$，如果 $x$ 被选择则 $y$ 必须被选择。即若 $y$ 不选且 $x$ 选，需要付出无穷的代价。清楚这一点后，根据网络流之二元关系的建图套路便能得到新图。 按照常理说这么多点和边的图跑网络流是很慢的，1s的时间跑不出来。但是对于这道题而言，图只有四层，即 $S$/正权点/负权点/$T$，所以每次增广时的深度很小，也就跑的很快。（纯粹口胡） 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-02-12 18:09:52 * @LastEditTime: 2019-02-12 18:23:18 * @Source: NOI 2006 * @Problem: 1497: [NOI2006]最大获利 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1497 */#include &lt;bits/stdc++.h&gt;const int MAXN = 55000 + 5;const int MAXM = MAXN * 3;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int S, T;int Cur[MAXN], Dis[MAXN];void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memset(Dis, -1, sizeof Dis); memcpy(Cur, H, sizeof H); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) { flow += dfs(S, INT_MAX); } return flow;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}int N, M;int ans;int main() { int x, y, z; scanf(\"%d%d\", &amp;N, &amp;M); init(N + M); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); addEdge(i, T, x); } for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); addEdge(S, i + N, z); addEdge(i + N, x, INT_MAX); addEdge(i + N, y, INT_MAX); ans += z; } printf(\"%d\\n\", ans - dinic()); return 0;}","link":"/BZOJ-1497/"},{"title":"「JSOI2009」BZOJ 1558 等差数列","text":"长为 $N$ 的序列 $A$ 上 $M$ 个操作，分为两类： 对于 $i\\in [l,r]$ ， 使 $A[i] = A[i] + (i-l)\\times b + a$ 查询 $A[l,r]$ 最少能分成多少个等差数列表示 $N,M\\leq 100000$ 分析操作一是对区间增加一个等差数列，因此将原数组差分，用线段树进行区间加和单点加。那么操作二就转化为查询区间能分成多少个相等的子区间。 差分后区间长度变成 $N-1$ ，则对 $A[l,r]$ 增加 $a+b\\cdot i$ 的等差数列的具体操作为$A[l-1]\\rightarrow A[l-1]+a$，$A[l,r]\\rightarrow A[l,r]+b$，$A[r+1]\\rightarrow A[r+1]-(a+(r-l)\\cdot b)$ 。由于对原数组进行了差分，因此注意判定 $l=1$ 和 $r=N$ 时的边界问题。 需要注意的是，两个数也可以构成等差数列，所以两个相邻不同数可以合并以减少答案。 因此合并答案的时候会复杂一些，用 $s[0/1][0/1]$ 表示左右端点取不取，注意左区间的右端点和右区间的左端点必须至少选择一个。 $s[0][0] = \\min(lc\\rightarrow s[1][0] + rc\\rightarrow s[0][1] - [lc\\rightarrow right = rc\\rightarrow left],lc\\rightarrow s[0][0] + rc\\rightarrow s[0][1],lc\\rightarrow s[1][1] + rc\\rightarrow s[0][0])$ ，剩余三个合并方法类似。 复杂度 $O(M\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (__typeof(l) i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (__typeof(l) i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define irep(i, x) for (__typeof(x.begin()) i = x.begin(); i != x.end(); ++i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())#define debug(...) fprintf(stderr, __VA_ARGS__)#define DEBUG debug(\"passing %d in %s\\n\", __LINE__, __FUNCTION__)typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }inline int read() { static char c; while (c = getchar(), !isdigit(c) &amp;&amp; c != '-'); bool f = c == '-'; int x = f ? 0 : c - '0'; for (c = getchar(); isdigit(c); c = getchar()) { x = x * 10 + c - '0'; } return f ? -x : x;}const int MAXN = 100000 + 5;#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint N, Q, A[MAXN];struct Data { ll left, right; int num[4]; Data operator + (const Data &amp;a) { Data x; x.left = left; x.right = a.right; x.num[0] = num[2] + a.num[1] - (right == a.left); chkMin(x.num[0], num[0] + a.num[1]); chkMin(x.num[0], num[2] + a.num[0]); x.num[1] = num[3] + a.num[1] - (right == a.left); chkMin(x.num[1], num[3] + a.num[0]); chkMin(x.num[1], num[1] + a.num[1]); x.num[2] = num[2] + a.num[3] - (right == a.left); chkMin(x.num[2], num[0] + a.num[3]); chkMin(x.num[2], num[2] + a.num[2]); x.num[3] = num[3] + a.num[3] - (right == a.left); chkMin(x.num[3], num[3] + a.num[2]); chkMin(x.num[3], num[1] + a.num[3]); return x; }};struct Node { ll add; Data x;} T[MAXN &lt;&lt; 2];void pushDown(int rt) { ll &amp;add = T[rt].add; if (add) { T[rt &lt;&lt; 1].add += add; T[rt &lt;&lt; 1 | 1].add += add; T[rt &lt;&lt; 1].x.left += add; T[rt &lt;&lt; 1].x.right += add; T[rt &lt;&lt; 1 | 1].x.left += add; T[rt &lt;&lt; 1 | 1].x.right += add; add = 0; }}void buildTree(int rt, int l, int r) { if (l == r) { T[rt].x.left = T[rt].x.right = A[l]; T[rt].x.num[0] = 0; T[rt].x.num[1] = T[rt].x.num[2] = T[rt].x.num[3] = 1; return ; } int m = (l + r) &gt;&gt; 1; buildTree(LT); buildTree(RT); T[rt].x = T[rt &lt;&lt; 1].x + T[rt &lt;&lt; 1 | 1].x;}void add(int rt, int l, int r, int a, int b, ll x) { if (a &lt;= l &amp;&amp; r &lt;= b) { T[rt].add += x; T[rt].x.left += x; T[rt].x.right += x; return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { add(LT, a, b, x); } if (m &lt; b) { add(RT, a, b, x); } T[rt].x = T[rt &lt;&lt; 1].x + T[rt &lt;&lt; 1 | 1].x;}Data cal(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt].x; } int m = (l + r) &gt;&gt; 1; pushDown(rt); if (b &lt;= m) { return cal(LT, a, b); } else if (a &gt; m) { return cal(RT, a, b); } else { return cal(LT, a, b) + cal(RT, a, b); }}void open() { freopen(\"1558.in\", \"r\", stdin); freopen(\"1558.out\", \"w\", stdout);}int main() { // open(); int l, r, a, b; char opt[5]; N = read(); rep(i, 1, N + 1) { A[i] = read(); } rep(i, 1, N) { A[i] = A[i + 1] - A[i]; } buildTree(1, 1, N - 1); Q = read(); while (Q--) { scanf(\"%s\", opt); l = read(), r = read(); if (opt[0] == 'A') { a = read(), b = read(); if (l &gt; 1) { add(1, 1, N - 1, l - 1, l - 1, a); } if (l &lt; r) { add(1, 1, N - 1, l, r - 1, b); } if (r &lt; N) { add(1, 1, N - 1, r, r, -1ll * b * (r - l) - a); } } else { if (l == r) { puts(\"1\"); } else { printf(\"%d\\n\", cal(1, 1, N - 1, l, r - 1).num[3]); } } } return 0;}","link":"/BZOJ-1558/"},{"title":"「Baltic 2003」BZOJ 1369 Gem","text":"在树上给所有节点标上正整数权值，要求相连的节点权值不同，求权值和的最小值。 $N\\leq 10000$ 分析如果确定了权值的范围，那么这就是个很简单的树形DP。 类似于SDOI2015R2D2T2，树上权值最大为 $log_2{N}$ ，在1e4U群里问了一下原理，但是没有结果… 不过可以想象这个值一定很小，不会超过20 。实际上不超过14 。 那么 $F(x,y)$ 表示以 $x$ 为根的子树中当 $x$ 的权值为 $y$ 时的最小权值和。 则转移方程为 $F(x,y) = \\sum{min(F(s,i)(i\\not= y))}+y$ （ $s$ 为 $x$ 的儿子）。 复杂度 $O(N\\log^2{N})​$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 10000 + 5;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int N;int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}int F[15][MAXN];void dfs(int x, int fa) { for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa) { dfs(v, x); rep(i, 1, 15) { int mn = INT_MAX; rep(j, 1, 15) { if(i != j) { chkMin(mn, F[j][v]); } } F[i][x] += mn; } } } rep(i, 1, 15) { F[i][x] += i; }}int main() { int u, v; scanf(\"%d\", &amp;N); rep(i, 1, N) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); } dfs(1, -1); int res = INT_MAX; rep(i, 1, 15) { chkMin(res, F[i][1]); } printf(\"%d\\n\", res); return 0;}","link":"/BZOJ-1369/"},{"title":"「Usaco2008 Oct」BZOJ 1601 灌水","text":"有 $N$ 块农田，连通两块农田的花费为 $W_{i,j}$ ，直接在农田上建水站费用为 $A_i$ ，求使得所有农田被水灌溉的最小费用。 $N\\leq 300$。 分析如果没有直接建水站的费用，那么使得整个图联通的最小代价即最小生成树的权值和。 但是由于可以建水站，且费用可能低于直接连边，因此可能会存在将图划分成多个连通块，每个块内建立最小生成树使得覆盖所有点的情况（即建多个水站）。 对于这种多个连通块的情况，有一种思路就是建一个虚拟点连接所有点，然后以该点为根构建最小生成树，如此便只需要求一棵MST。 那么对于这道题而言，显然这个根连接其他点的权值为在该点建水站的费用。 由于是张完全图，因此选择Prim算法求MST显然在常数上优于Kruskal算法，因为 $E$ 是 $V^2$ 级别的。 复杂度 $O(E\\log{V})$ 或者 $O(E\\log{E})$ ，即 $O(n^2\\log{n})$。 参考代码Prim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 300 + 5;int N, R;struct Edge { int v, w, nxt;} E[MAXN * MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}typedef std::pair&lt;int, int&gt; pii;int Prim(int x) { static std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt; &gt; Pq; static int Vis[MAXN], Dis[MAXN]; memset(Vis, 0, sizeof Vis); memset(Dis, 0x3f, sizeof Dis); Dis[x] = 0; Pq.push(std::make_pair(0, x)); int cnt = -1, sum = 0; while (!Pq.empty() &amp;&amp; cnt &lt; N) { pii x = Pq.top(); Pq.pop(); if (!chkMax(Vis[x.second], 1)) { continue; } sum += x.first; ++cnt; for (int i = H[x.second]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (chkMin(Dis[v], E[i].w)) { Pq.push(std::make_pair(Dis[v], v)); } } } return sum;}int main() { int w; scanf(\"%d\", &amp;N); rep(i, 1, N + 1) { scanf(\"%d\", &amp;w); addEdge(0, i, w); addEdge(i, 0, w); } rep(i, 1, N + 1) { rep(j, 1, N + 1) { scanf(\"%d\", &amp;w); if (i != j) { addEdge(i, j, w); } } } printf(\"%d\\n\", Prim(R)); return 0;} Kruskal12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 300 + 5;int N, R;struct Edge { int u, v, w, nxt; bool operator &lt; (const Edge &amp;x) const { return w &lt; x.w; }} E[MAXN * MAXN];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE;}int Fa[MAXN], Rnk[MAXN];void init() { rep(i, 0, N + 1) { Fa[i] = i; Rnk[i] = 1; }}int findFa(int x) { return x == Fa[x] ? x : Fa[x] = findFa(Fa[x]);}bool merge(int x, int y) { x = findFa(x), y = findFa(y); if(x == y) { return false; } if(Rnk[x] &lt; Rnk[y]) { Fa[x] = y; } else { Fa[y] = x; if(Rnk[x] == Rnk[y]) { ++Rnk[x]; } } return true;}int Kruskal() { int sum = 0, cnt = 0; init(); std::sort(E + 1, E + cntE + 1); rep(i, 1, cntE + 1) { if(merge(E[i].u, E[i].v)) { sum += E[i].w; if(++cnt == N) { break; } } } return sum;}int main() { int w; scanf(\"%d\", &amp;N); rep(i, 1, N + 1) { scanf(\"%d\", &amp;w); addEdge(0, i, w); } rep(i, 1, N + 1) { rep(j, 1, N + 1) { scanf(\"%d\", &amp;w); if (i &lt; j) { addEdge(i, j, w); } } } printf(\"%d\\n\", Kruskal()); return 0;}","link":"/BZOJ-1601/"},{"title":"「HNOI 2002」BZOJ 1588 营业额统计","text":"给定长为 $N$ 的序列 $A$，最小化 $total = A_1+\\sum\\limits_{i=2}^{N}{|A_i-A_j|}(j &lt; i)$ 。 $N\\leq 32767, A_i\\leq 1000000$ 分析用一棵可以查询前驱后继的Treap/Splay等数据结构维护。 每次查询 $A_i$ 的前驱后继，取与 $A_i$ 的差较小的值计入 $total$，然后将 $A_i$ 插入。 复杂度 $O(N\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 32767 + 5;const int INF = 1e9;struct TreapTree { struct Treap { int key, fix; int cnt, sz; Treap *ch[2]; void pushUp() { sz = cnt; if (ch[0]) { sz += ch[0]-&gt;sz; } if (ch[1]) { sz += ch[1]-&gt;sz; } } int cmp(int x) { return key == x ? -1 : key &lt; x; } } Pool[MAXN], *R; int cntP; Treap* newTreap(int x) { Pool[++cntP] = (Treap) {x, rand(), 1, 1, NULL, NULL}; return &amp;Pool[cntP]; } void rotate(Treap* &amp;t, int d) { Treap *k = t-&gt;ch[d ^ 1]; t-&gt;ch[d ^ 1] = k-&gt;ch[d]; k-&gt;ch[d] = t; t-&gt;pushUp(); k-&gt;pushUp(); t = k; } void insert(Treap* &amp;t, int x) { if (!t) { t = newTreap(x); return ; } int d = t-&gt;cmp(x); ++t-&gt;sz; if (d == -1) { ++t-&gt;cnt; } else { insert(t-&gt;ch[d], x); if (t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix) { rotate(t, d ^ 1); } } } int res; void queryPre(Treap* &amp;t, int x) { if (!t) { return ; } if (t-&gt;key &lt;= x) { res = t-&gt;key; queryPre(t-&gt;ch[1], x); } else { queryPre(t-&gt;ch[0], x); } } void querySub(Treap* &amp;t, int x) { if (!t) { return ; } if (t-&gt;key &gt;= x) { res = t-&gt;key; querySub(t-&gt;ch[0], x); } else { querySub(t-&gt;ch[1], x); } }} T;int main() { int N = io::gt&lt;int&gt;(); int res = io::gt&lt;int&gt;(); T.insert(T.R, res); rep(i, 2, N + 1) { int x = io::gt&lt;int&gt;(); T.res = -1; T.queryPre(T.R, x); int pre = T.res != -1 ? T.res : -INF; T.res = -1; T.querySub(T.R, x); int sub = T.res != -1 ? T.res : INF; res += std::min(x - pre, sub - x); T.insert(T.R, x); } printf(\"%d\\n\", res); return 0;}","link":"/BZOJ-1588/"},{"title":"「USACO2008 MAR」BZOJ 1597 土地购买","text":"有 $n$ 个 $X_i\\times Y_i$ 的矩形，购买矩形的花费为它的面积。允许一次性购买多个矩形，其花费为 $\\max(X_i)\\times \\max(Y_i)$。求购买所有矩形的最小花费。 $n\\leq 50000$ 分析若存在若干个矩形满足 $X_1\\leq X_2\\leq\\cdots\\leq X_m$ 且 $Y_1\\cdots Y_i\\leq Y_m$，则一定打包购买，花费为 $X_m\\times Y_m$。那么剩下的矩形一定满足 $X_i\\leq X_2\\leq\\cdots\\leq X_p$ 且 $Y_1 &gt; Y_2 &gt; \\cdots&gt; Y_p$。 新序列可以通过排序（第一关键字 $x$，第二关键字 $y$）后用单调栈维护 $y$ 值递减处理。 转移方程为 $F_i=\\min\\limits_{1\\leq j &lt; i}{(F_j+X_i\\times Y_{j+1})}$。 决策点 $j$ 优于决策点 $k(j &lt; k)$，当且仅当 $\\frac{F_j-F_k}{B_{k+1}-B_{j+1}} &gt; A_i$。 维护决策点队列，满足斜率单调递增，且大于 $A_i$。 复杂度 $O(n\\log{n})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * @Author: Skqliao * @Source: USACO2008 Mar * @Problem: 1597: [Usaco2008 Mar]土地购买 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1597 * @Date: 2019-02-25 20:43:09 * @LastEditTime: 2019-02-25 22:14:02 */#include &lt;bits/stdc++.h&gt;const int MAXN = 50000 + 5;struct Node { int x, y; bool operator &lt; (const Node &amp;a) const { return x == a.x ? a.y &gt; y : x &lt; a.x; }} A[MAXN], B[MAXN];int N;int Que[MAXN], qh, qt;long long F[MAXN];double slope(int j, int k) { return (double) (F[j] - F[k]) / (B[k + 1].y - B[j + 1].y);}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;A[i].x, &amp;A[i].y); } std::sort(A + 1, A + N + 1); int top = 0; for (int i = 1; i &lt;= N; ++i) { while (top &amp;&amp; B[top].y &lt;= A[i].y) --top; B[++top] = A[i]; } Que[0] = 0; for (int i = 1; i &lt;= top; ++i) { while (qt &gt; qh &amp;&amp; slope(Que[qh], Que[qh + 1]) &lt;= B[i].x) ++qh; int j = Que[qh]; F[i] = F[j] + (long long)B[i].x * B[j + 1].y; while (qt &gt; qh &amp;&amp; slope(Que[qt - 1], Que[qt]) &gt;= slope(Que[qt], i)) --qt; Que[++qt] = i; } printf(\"%lld\\n\", F[top]); return 0;}","link":"/BZOJ-1597/"},{"title":"「USACO2005 Dec」BZOJ 1671 Knights of Ni 骑士","text":"在 $N\\times M$ 的网格图中，初始位于 $(x,y)$。每个点有属性 $1-4$，若属性为 $1$ 则不可经过。要求先走到一个属性为 $4$ 的格子，再走到一个属性为 $3$ 的格子，要求在走到 $4$ 之前不能经过 $3$。求最少步数。 $N,M\\leq 1000$ 分析做两次BFS，第一次初始为 $(x,y)$，求出到每个 $4$ 的最小步数，再以这些点为起点求出总步数。 复杂度 $O(NM)$。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* * @Author: Skqliao * @Source: USACO2005 Dec * @Problem: 1671: [Usaco2005 Dec]Knights of Ni 骑士 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1671 * @Date: 2019-02-22 15:35:46 * @LastEditTime: 2019-02-22 16:14:24 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000 + 5;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;int A[MAXN][MAXN];int Step[MAXN][MAXN];std::queue&lt;std::pair&lt;int, int&gt; &gt; Que;int bfs(int sx, int sy) { memset(Step, 0x3f, sizeof Step); Step[sx][sy] = 0; Que.push(std::make_pair(sx, sy)); while (!Que.empty()) { std::pair&lt;int, int&gt; a = Que.front(); Que.pop(); for (int i = 0; i &lt; 4; ++i) { int x = a.first + Dicx[i]; int y = a.second + Dicy[i]; if (x &lt; 1 || y &lt; 1 || x &gt; N || y &gt; M) continue; if (A[x][y] != 1 &amp;&amp; A[x][y] != 3) { if (Step[x][y] &gt; Step[a.first][a.second] + 1) { Step[x][y] = Step[a.first][a.second] + 1; Que.push(std::make_pair(x, y)); } } } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { if (A[i][j] == 4) { Que.push(std::make_pair(i, j)); } else { Step[i][j] = 0x3f3f3f3f; } } } while (!Que.empty()) { std::pair&lt;int, int&gt; a = Que.front(); Que.pop(); for (int i = 0; i &lt; 4; ++i) { int x = a.first + Dicx[i]; int y = a.second + Dicy[i]; if (x &lt; 1 || y &lt; 1 || x &gt; N || y &gt; M) continue; if (A[x][y] != 1) { if (Step[x][y] &gt; Step[a.first][a.second] + 1) { Step[x][y] = Step[a.first][a.second] + 1; Que.push(std::make_pair(x, y)); } } } } int ans = INT_MAX; for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { if (A[i][j] == 3) ans = std::min(ans, Step[i][j]); } } return ans;}int main() { int sx = 0, sy = 0; scanf(\"%d%d\", &amp;M, &amp;N); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); if (A[i][j] == 2) { sx = i, sy = j; } } } printf(\"%d\\n\", bfs(sx, sy)); return 0;}","link":"/BZOJ-1671/"},{"title":"「Usaco2007 Dec」BZOJ 1691 挑剔的美食家","text":"$N$ 头奶牛， $M$ 种草料。第 $i$ 头奶牛要求其草料价格不小于 $A_i$，鲜嫩程度不小于 $B_i$ 。要求奶牛吃的草料互不相同，求最小花费。如果无解，输出 $-1$ 。$N,M\\leq 100000$ 。 分析贪心的想，每头奶牛肯定选择满足要求的最小价格的草料。 将草料和奶牛按照其鲜嫩程度从大到小排序，对每头奶牛，将所有鲜嫩程度满足要求的草料价格插入到一个 multiset中，在里面lower_bound得到满足条件的最小价格，统计答案并将它删去。如果找不到，输出 $-1$ 。 由于草料的鲜嫩程度是不增的，因此已经插入的所有草料价格一定都满足鲜嫩程度不小于当前奶牛的要求，只需要继续插入后面满足条件的草料。 因此每个草料最多按顺序插入一次。 复杂度 $O(N\\log{N}+M\\log{M})$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 100000 + 5;struct Node { int cost, val; bool operator &lt; (const Node &amp;x) const { return val &gt; x.val; }} A[MAXN], B[MAXN];std::multiset&lt;int&gt; S;int main() { int N, M; ll ans = 0; scanf(\"%d%d\", &amp;N, &amp;M); rep(i, 0, N) { scanf(\"%d%d\", &amp;A[i].cost, &amp;A[i].val); } rep(i, 0, M) { scanf(\"%d%d\", &amp;B[i].cost, &amp;B[i].val); } std::sort(A, A + N); std::sort(B, B + M); int cur = 0; rep(i, 0, N) { while(cur &lt; M &amp;&amp; B[cur].val &gt;= A[i].val) { S.insert(B[cur++].cost); } std::multiset&lt;int&gt;::iterator p = S.lower_bound(A[i].cost); if(p == S.end()) { puts(\"-1\"); return 0; } else { ans += *p; S.erase(p); } } printf(\"%lld\\n\", ans); return 0;}","link":"/BZOJ-1691/"},{"title":"「USACO2007 Mar」BZOJ 1639 Monthly Expense 月度开支","text":"将 $A[1 \\cdots N]$ 划分成 $M$ 个区间，使得各区间和的最大值最小。 $N,M\\leq 100000$ 分析二分答案。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * @Author: Skqliao * @Source: USACO2007 Mar * @Problem: 1639: [Usaco2007 Mar]Monthly Expense 月度开支 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1639 * @Date: 2019-02-22 17:05:58 * @LastEditTime: 2019-02-22 17:19:34 */#include &lt;bits/stdc++.h&gt;const int MAXN = 100000 + 5;int N, M;int A[MAXN];bool check(long long x) { int left = M; long long sum = 0; for (int i = 1; i &lt;= N; ++i) { if (sum + A[i] &gt; x) { sum = 0; --left; } sum += A[i]; } return left &gt; 0;}int main() { long long mx = 0, sum = 0; scanf(\"%d%d\", &amp;N, &amp;M); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); sum += A[i]; mx = std::max(mx, (long long)A[i]); } long long l = mx, r = sum; long long ans = 0; while (l &lt;= r) { long long m = (l + r) / 2; if (check(m)) { r = m - 1; ans = m; } else l = m + 1; } printf(\"%lld\\n\", ans); return 0;}","link":"/BZOJ-1639/"},{"title":"「CQOI 2010」BZOJ 1816 扑克牌","text":"有 $N$ 种牌，各有 $A_i$ 张。还有一类特殊的牌，有 $M$ 张。每副牌由 $N$ 张不同的牌组成，求最多能凑出多少副牌。 $N\\leq 50,M,A_i\\leq 5000000000$ 分析答案显然具有单调性，因此可以二分答案将求最值问题转为判定可行性问题。 假设当前判定是否能凑出 $x$ 副牌。对于 $A_i\\geq x$ 的牌，显然每副牌中都能放一张；对于 $A_i &lt; x$ 的牌，需要用特殊的牌补。若特殊的牌不够或者在一副牌中出现两次，则判定失败。 也就是说这些牌需要至少凑够前 $N-1$ 个位置，用特殊的牌补最后一张，即需要满足 $\\sum{min(x,A_i)} &lt; min(M,x)$ 。 复杂度 $O(M\\log{\\sum{A_i}})$。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243/* * @Author: Skqliao * @Source: CQOI 2010 * @Problem: 1816: [Cqoi2010]扑克牌 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1816 * @Date: 2019-02-22 16:23:14 * @LastEditTime: 2019-02-22 16:55:38 */#include &lt;bits/stdc++.h&gt;const int MAXN = 50 + 5;int N;long long M, A[MAXN];bool check(long long x) { long long tot = 0; for (int i = 1; i &lt;= N; ++i) { tot += std::min(x, A[i]); } return N * x - tot &lt;= std::min(x, M);}int main() { scanf(\"%d%lld\", &amp;N, &amp;M); long long sum = M; for (int i = 1; i &lt;= N; ++i) { scanf(\"%lld\", &amp;A[i]); sum += A[i]; } long long l = 0, r = sum / N; long long ans = 0; while (l &lt;= r) { long long m = (l + r) / 2; if (check(m)) { ans = m; l = m + 1; } else r = m - 1; } printf(\"%lld\\n\", ans); return 0;}","link":"/BZOJ-1816/"},{"title":"「Usaco2010 Hol」BZOJ 1776 cowpol 奶牛政坛","text":"在 $N$ 个节点的有根树 $T$ 中，节点被分成 $K$ 。求每一组组内距离最远的两个节点的距离值。 $N\\leq 200000,K\\leq N/2$ 分析可以证明集合中距离最远的点对的其中之一一定是集合中深度最大的点。 证明如下： $depth(x)$ 表示节点 $x$ 的深度， $dis(u,v)$ 表示节点 $u,v$ 的距离， $lca(u,v)$ 表示节点 $u,v$ 的最近公共祖先。 利用反证法。假设集合中节点 $u,v$ 均不是深度最大的节点，且 $dis(u,v)$ 为集合中点对距离的最大值。 设该集合中深度最大的节点为 $x$ 。 则有 $dis(u,v)=depth(u)+depth(v)-2 depth(lca(u,v))$ ， $dis(x,v)=depth(x)+depth(v)-2 depth(lca(x,v))$。 由于 $dis(u,v)&gt;dis(x,v)$ ，则 $depth(u)-2 depth(lca(u,v))&gt;depth(x)-2 depth(lca(x,v))$ ；又因为 $depth(x)&gt;depth(u)$ ，则 $depth(lca(u,v)) &lt; depth(lca(x,v))$ 。 那么 $x$ 的位置有两个可能，$x$ 在 $v$ 的子树中； $x$ 不在 $v$ 的子树中。 若是前者，则 $dis(u,x) &gt; dis(u,v)$ 是毫无疑问的；若是后者，若 $x$ 不在 $u$ 的子树中，则一定存在 $lca(u,v)=lca(x,u)$ ，显然 $depth(lca(u,v)) &lt; depth(lca(x,v))$ 不成立，若 $x$ 在 $u$ 的子树中，则又转化为前者。 因此若 $dis(u,v)$ 为集合中距离最大的点对，其中之一一定是集合内深度最大的节点。 那么求距离的最大值，只需要求集合内所有节点和深度最大的节点之间的距离，取最大值即可。 利用在线算法求LCA，复杂度 $O(N\\log{N})$ 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 200000 + 5;const int MAXM = 20;int N, K;std::vector&lt;int&gt; Son[MAXN], V[MAXN];int Depth[MAXN], Fir[MAXN];int Id[MAXN &lt;&lt; 1], cntI;void dfs(int x, int fa) { Depth[x] = Depth[fa] + 1; Id[++cntI] = x; Fir[x] = cntI; rep(i, 0, SZ(Son[x])) { dfs(Son[x][i], x); Id[++cntI] = x; }}int F[MAXM][MAXN &lt;&lt; 1];int Log[MAXN &lt;&lt; 1], Pow[MAXM];void buildST(int N) { int k = log2(N); Pow[0] = 1; rep(i, 1, k + 1) { Pow[i] = Pow[i - 1] &lt;&lt; 1; } rep(i, 2, N + 1) { Log[i] = Log[i &gt;&gt; 1] + 1; } rep(i, 1, N + 1) { F[0][i] = Id[i]; } rep(j, 0, k) { rof(i, N + 1, 1) { if (i + Pow[j] &lt;= N) { if (Depth[F[j][i]] &lt; Depth[F[j][i + Pow[j]]]) { F[j + 1][i] = F[j][i]; } else { F[j + 1][i] = F[j][i + Pow[j]]; } } } }}int queryLCA(int l, int r) { if (l &gt; r) { std::swap(l, r); } int k = Log[r - l + 1]; int &amp;a = F[k][l], &amp;b = F[k][r - Pow[k] + 1]; return Depth[a] &lt; Depth[b] ? a : b;}int main() { int a, f, R; scanf(\"%d%d\", &amp;N, &amp;K); rep(i, 1, N + 1) { scanf(\"%d%d\", &amp;a, &amp;f); V[a].push_back(i); Son[f].push_back(i); if (f == 0) { R = i; } } dfs(R, 0); buildST(cntI); rep(i, 1, K + 1) { int max_dep = 0, id = 0; rep(j, 0, SZ(V[i])) { if (chkMax(max_dep, Depth[V[i][j]])) { id = V[i][j]; } } int max_dis = 0; rep(j, 0, SZ(V[i])) { if (V[i][j] != id) { int dep = Depth[queryLCA(Fir[V[i][j]], Fir[id])]; chkMax(max_dis, Depth[V[i][j]] + Depth[id] - dep * 2); } } printf(\"%d\\n\", max_dis); } return 0;}","link":"/BZOJ-1776/"},{"title":"「AHOI 2009」BZOJ 1798 维护序列","text":"维护序列 $A[1…N]$ ，共 $M$ 次操作，分为三种： $A[l,r]$ 所有数加 $x$ $A[l,r]$ 所有数乘 $x$ $A[l,r]$ 求和 答案对 $P$ 取模。 $N,M\\leq 100000,1\\leq P\\leq 1000000000$ 分析线段树模板，注意lazy标签先处理乘法。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;struct Segment { int sum, add, mul;} T[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rll P;template&lt;class T, class G&gt; void inc(T &amp;x, G y) { (x += y) %= P;}template&lt;class T, class G&gt; void inu(T &amp;x, G y) { (x *= y) %= P;}void pushUp(int rt) { inc(T[rt].sum = 0, T[rt &lt;&lt; 1].sum + T[rt &lt;&lt; 1 | 1].sum);}void pushDown(int rt, int L) { Segment &amp;ls = T[rt &lt;&lt; 1], &amp;rs = T[rt &lt;&lt; 1 | 1]; int &amp;add = T[rt].add, &amp;mul = T[rt].mul; if (mul != 1) { inu(ls.sum, mul); inu(rs.sum, mul); inu(ls.add, mul); inu(rs.add, mul); inu(ls.mul, mul); inu(rs.mul, mul); mul = 1; } if (add != 0) { inc(ls.sum, add * (L - (L &gt;&gt; 1))); inc(rs.sum, add * (L &gt;&gt; 1)); inc(ls.add, add); inc(rs.add, add); add = 0; }}void build(int rt, int l, int r) { T[rt].add = 0, T[rt].mul = 1; if (l == r) { inc(T[rt].sum = 0, io::gt&lt;ll&gt;()); return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void mul(int rt, int l, int r, int a, int b, ll x) { if (a &lt;= l &amp;&amp; r &lt;= b) { inu(T[rt].sum, x); inu(T[rt].add, x); inu(T[rt].mul, x); return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { mul(LT, a, b, x); } if (m &lt; b) { mul(RT, a, b, x); } pushUp(rt);}void add(int rt, int l, int r, int a, int b, ll x) { if (a &lt;= l &amp;&amp; r &lt;= b) { inc(T[rt].sum, x * (r - l + 1)); inc(T[rt].add, x); return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { add(LT, a, b, x); } if (m &lt; b) { add(RT, a, b, x); } pushUp(rt);}ll querySum(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt].sum; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; ll res = 0; if (a &lt;= m) { inc(res, querySum(LT, a, b)); } if (m &lt; b) { inc(res, querySum(RT, a, b)); } return res;}int main() { int N = io::gt&lt;int&gt;(); P = io::gt&lt;ll&gt;(); build(1, 1, N); int M = io::gt&lt;int&gt;(); while (M--) { int opt = io::gt&lt;int&gt;(); int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); if (opt == 1) { mul(1, 1, N, l, r, io::gt&lt;ll&gt;() % P); } else if (opt == 2) { add(1, 1, N, l, r, io::gt&lt;ll&gt;() % P); } else { io::pt(querySum(1, 1, N, l, r)); } } io::flush(); return 0;}","link":"/BZOJ-1798/"},{"title":"「SCOI 2010」BZOJ 1858 序列操作","text":"在一个01序列中，有五种变换操作和询问操作： 0 a b 把$[a, b]$区间内的所有数全变成$0$ 1 a b 把$[a, b]$区间内的所有数全变成$1$ 2 a b 把$[a,b]$区间内的所有数全部取反，也就是说把所有的$0$变成$1$，把所有的$1$变成$0$ 3 a b 询问$[a, b]$区间内总共有多少个$1$ 4 a b 询问$[a, b]$区间内最多有多少个连续的$1$ $1\\leq n, m\\leq 100000$ 分析这种区间操作、区间查询，且满足区间加法的题，再看一下 $1e5$ 的数据范围，很显然是用线段树来维护。 维护区间中 $1$ 的数目（即区间和），左右连续 $0,1$ 的长度，最长的连续的 $0,1$ 的长度，当然还有取反和重置 $0/1$ 的标记。 那么合并的时候，连续的 $0,1$ 有两种合并方式：继承左右，或者左右合并（即左区间的右+右区间的左，这两段拼起来是连续的）。 区间取反，即交换所有关于 $0,1$ 的信息；区间重置，根据区间长度直接更新信息。 复杂度 $O(m\\log{n})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rstruct Segment { int l, r; int sum, rev, trn; int ln[2], rn[2], mx[2];} T[MAXN &lt;&lt; 2];int max3(int a, int b, int c) { return std::max(a, std::max(b, c));}Segment merge(Segment x, Segment y) { Segment a; a.trn = -1, a.rev = 0; a.l = x.l, a.r = y.r; a.sum = x.sum + y.sum; rep(i, 0, 2) { a.ln[i] = x.ln[i], a.rn[i] = y.rn[i]; a.mx[i] = max3(x.mx[i], y.mx[i], x.rn[i] + y.ln[i]); if (!x.mx[i ^ 1]) { a.ln[i] = x.mx[i] + y.ln[i]; } if (!y.mx[i ^ 1]) { a.rn[i] = y.mx[i] + x.rn[i]; } } return a;}void turn(Segment &amp;x, int d) { x.rev = 0; x.ln[d] = x.rn[d] = x.mx[d] = x.r - x.l + 1; x.ln[d ^ 1] = x.rn[d ^ 1] = x.mx[d ^ 1] = 0; if (d == 1) { x.sum = x.r - x.l + 1; } else { x.sum = 0; }}void rever(Segment &amp;x) { x.sum = x.r - x.l + 1 - x.sum; std::swap(x.mx[0], x.mx[1]); std::swap(x.ln[0], x.ln[1]); std::swap(x.rn[0], x.rn[1]);}void pushDown(int rt) { Segment &amp;x = T[rt], &amp;ls = T[rt &lt;&lt; 1], &amp;rs = T[rt &lt;&lt; 1 | 1]; if (x.trn != -1) { ls.trn = rs.trn = x.trn; turn(ls, x.trn); turn(rs, x.trn); x.trn = -1; } if (x.rev) { ls.rev ^= 1; rs.rev ^= 1; rever(ls); rever(rs); x.rev = 0; }}void build(int rt, int l, int r) { if (l == r) { Segment &amp;x = T[rt]; x.rev = 0, x.trn = -1; x.l = x.r = l; x.sum = io::gt&lt;int&gt;(); x.ln[x.sum] = x.rn[x.sum] = x.mx[x.sum] = 1; x.ln[x.sum ^ 1] = x.rn[x.sum ^ 1] = x.mx[x.sum ^ 1] = 0; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); T[rt] = merge(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}void change(int rt, int a, int b, int x) { int l = T[rt].l, r = T[rt].r; if (a &lt;= l &amp;&amp; r &lt;= b) { T[rt].trn = x; turn(T[rt], x); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { change(rt &lt;&lt; 1, a, b, x); } if (m &lt; b) { change(rt &lt;&lt; 1 | 1, a, b, x); } T[rt] = merge(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}void reverse(int rt, int a, int b) { int l = T[rt].l, r = T[rt].r; if (a &lt;= l &amp;&amp; r &lt;= b) { T[rt].rev ^= 1; rever(T[rt]); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { reverse(rt &lt;&lt; 1, a, b); } if (m &lt; b) { reverse(rt &lt;&lt; 1 | 1, a, b); } T[rt] = merge(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}int querySum(int rt, int a, int b) { int l = T[rt].l, r = T[rt].r; if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt].sum; } pushDown(rt); int res = 0; int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { res += querySum(rt &lt;&lt; 1, a, b); } if (m &lt; b) { res += querySum(rt &lt;&lt; 1 | 1, a, b); } return res;}Segment queryMax(int rt, int a, int b) { int l = T[rt].l, r = T[rt].r; if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt]; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (b &lt;= m) { return queryMax(rt &lt;&lt; 1, a, b); } else if (m &lt; a) { return queryMax(rt &lt;&lt; 1 | 1, a, b); } else { return merge(queryMax(rt &lt;&lt; 1, a, b), queryMax(rt &lt;&lt; 1 | 1, a, b)); }}int main() { int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); build(1, 1, N); while (M--) { int opt = io::gt&lt;int&gt;(); int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); ++l, ++r; if (opt == 0 || opt == 1) { change(1, l, r, opt); } else if (opt == 2) { reverse(1, l, r); } else if (opt == 3) { io::pt(querySum(1, l, r)); } else if (opt == 4) { io::pt(queryMax(1, l, r).mx[1]); } } io::flush(); return 0;}","link":"/BZOJ-1858/"},{"title":"「JSOI2010」BZOJ 1826 缓存交换","text":"起初有 $M$ 个空位置。有 $N$ 次插入，若插入的数在位置上，则无需操作；否则需要用它替换掉原位置中的一个数。每次可以自由选择替换的位置，求最小替换次数。 $M\\leq N\\leq 100000$ 。 分析对于一个插入的数 $x$ ，若当前位置未满且 $x$ 不在任意位置中，则直接插入 $x$ ，次数 $+1$。 若 $x$ 存在于某个位置中，则无需任何操作。 如果不存在，应该替换掉位置上 $M$ 个数中下一次出现最晚的那个数（如果不再出现，则当其下一次出现的位置为 $INF$ ）。 这是个贪心的策略， 形象的理解就是，该元素占了那个位置最长的没有意义的时间，（元素两次插入间隔的时间被认为是没有意义的）。 预处理出 $Nxt[i]$ ，表示 $i$ 位置的元素下一次出现的下标，如果没有下一次，将其置为 $N+1$。 维护大根堆，每次插入 $Nxt[i]$ 。 若 $i$ 不在堆中，则说明需要进行了一次替换，并删除堆顶元素。 复杂度 $O(N\\log{N})$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 100000 + 5;int N, M;std::multiset&lt;int&gt; In;std::map&lt;int, int&gt; Lst;int A[MAXN], Nxt[MAXN];int main() { int res = 0; scanf(\"%d%d\", &amp;N, &amp;M); rep(i, 1, N + 1) { scanf(\"%d\", &amp;A[i]); Nxt[i] = N + 1; Nxt[Lst[A[i]]] = i; Lst[A[i]] = i; } rep(i, 1, N + 1) { if(In.find(i) != In.end()) { In.erase(i); } else { ++res; if(SZ(In) == M) { In.erase(--In.end()); } } In.insert(Nxt[i]); } printf(\"%d\\n\", res); return 0;}","link":"/BZOJ-1826/"},{"title":"「SCOI2010」BZOJ 1855 股票交易","text":"一共 $T$ 天，每天股票的买入价为 $A_i$ ，卖出价为 $B_i$ ，最多允许购买 $C_i$ 股，售出 $D_i$ 股。要求两次交易之间至少间隔 $W$ 天，持有的总股票数不超过 $P$ 。假设可以无利息借钱购买股票，求最大收益。 $T\\leq 2000$ 。 分析记 $F(i,j)$ 表示第 $i$ 天持有 $j$ 股的最大收益。 首先 $F(i,j)$ 可以直接购买获得， $F(i,j) = -A_i\\times j(j\\leq C_i)$ 。 其次可以由前一天直接转移获得， $F(i,j) = F(i-1,j)$ 。 最后可以通过 $i-w-1$ 天的状态转移， $$ F(i,j) = \\max\\limits_{max(1,j-C_i)\\leq k\\leq j}{F(i-w-1,k)+(k-j)\\times A_i}\\ F(i,j)=\\max\\limits_{max(1,j-C_i)\\leq k\\leq j}{F(i-w-1,k)+(k-j)\\times B_i} $$ 如果枚举 $k$ ，复杂度会达到 $TP^2$ ，显然不行。 再观察转移方程，它可以转化成 $F(i,j) = \\max\\limits_{max(1,j-C_i)\\leq k\\leq j}{(F(i-w-1,k)+k\\times A_i})-j\\times A_i$。 这是典型的单调队列可以优化的形式（形如 $f[x] = \\max(g[k])+w[x]$ ）。 单调队列分别维护 $F(i-w-1,k)+k\\times A_i$ 和 $F(i-w-1,k)+k\\times B_i$ 。 需要注意的是，前者 $k$ 从 $0$ 到 $j$ 枚举，而后者是从 $P$ 到 $j$ 枚举。因为随着 $j$ 的增大，前者当 $k &lt; j - C_i$ 时不在枚举范围，而后者当 $k &gt; j + D_i$ 时不在枚举范围。 如此使得 $F[i][1\\cdots P]$ 的决策分摊 $O(P)$ 的复杂度，复杂度降至 $O(TP)$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 2000 + 5;int N, P, W;int F[MAXN][MAXN];int Que[MAXN];int main() { int a, b, maxa, maxb; scanf(\"%d%d%d\", &amp;N, &amp;P, &amp;W); memset(F, 0x80, sizeof F); rep(i, 1, N + 1) { scanf(\"%d%d%d%d\", &amp;a, &amp;b, &amp;maxa, &amp;maxb); rep(j, 0, maxa + 1) { F[i][j] = -a * j; } rep(j, 0, P + 1) { chkMax(F[i][j], F[i - 1][j]); } if (i - W &lt;= 1) { continue; } int h = 0, t = -1; rep(j, 0, P + 1) { while (h &lt;= t &amp;&amp; Que[h] &lt; j - maxa) { ++h; } while (h &lt;= t &amp;&amp; F[i - W - 1][Que[t]] + Que[t] * a &lt;= F[i - W - 1][j] + j * a) { --t; } Que[++t] = j; chkMax(F[i][j], F[i - W - 1][Que[h]] + (Que[h] - j) * a); } h = 0, t = -1; rof(j, P + 1, 0) { while (h &lt;= t &amp;&amp; Que[h] &gt; j + maxb) { ++h; } while (h &lt;= t &amp;&amp; F[i - W - 1][Que[t]] + Que[t] * b &lt;= F[i - W - 1][j] + j * b) { --t; } Que[++t] = j; chkMax(F[i][j], F[i - W - 1][Que[h]] + (Que[h] - j) * b); } } int res = 0; rep(i, 0, P + 1) { chkMax(res, F[N][i]); } printf(\"%d\\n\", res); return 0;}","link":"/BZOJ-1855/"},{"title":"「APIO 2010」BZOJ 1911 特别行动队","text":"将序列 $A[1 \\cdots n]$划分成若干个不相交区间，区间 $[l,r]$ 的权值为 $a\\cdot x^2+b\\cdot x+c$，其中 $x=\\sum\\limits_{i=l}^{r}{A[i]}$。求最大权值和。 $n\\leq 1000000,-5\\leq a\\leq -1, |b|,|c|\\leq 10000000,A[i]\\leq 100$ 分析令 $S_i=\\sum\\limits_{j=1}^{i}{A_i}$，$F_i$ 表示将前 $i$ 个数划分成若干区间的最大权值和。 则 $F_i=\\min\\limits_{1\\leq j &lt; i}{(F_j+a\\cdot (S_i-S_j)^2+b\\cdot (S_i-S_j) + c)}$。 考虑 $i$ 从两个决策点 $j,k$ 转移，若 $j$ 更优，则需要满足： $F_j-F_k+a\\cdot (S_i-S_j)^2+b\\cdot (S_i-S_j) + c-(a\\cdot (S_i-S_k)^2+b\\cdot (S_i-S_k) + c) &gt; 0$ 移项整理可得 $\\frac{F_j-F_k+a(S_j^2-S_k^2)}{S_j-S_k} &lt; 2aS_i+b$。 维护单调队列，每次取队首更新当前答案，维护队列中斜率单调递减，且不超过 $2aS_i+b$。 复杂度 $O(n)$。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243/* * @Author: Skqliao * @Source: APIO 2010 * @Problem: 1911: [Apio2010]特别行动队 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1911 * @Date: 2019-02-23 17:04:48 * @LastEditTime: 2019-02-24 10:03:05 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000000 + 5;int N;long long a, b, c;long long S[MAXN], F[MAXN];template &lt;class T&gt;T sqr(T x) { return x * x;}double slop(int x, int y) { return (double)(F[x] - F[y] + a * (S[x] + S[y]) * (S[x] - S[y])) / (S[x] - S[y]);}int Que[MAXN], qh, qt;int main() { long long x; scanf(\"%d%lld%lld%lld\", &amp;N, &amp;a, &amp;b, &amp;c); Que[qt] = 0; for (int i = 1; i &lt;= N; ++i) { scanf(\"%lld\", &amp;x); S[i] = S[i - 1] + x; while (qt &gt; qh &amp;&amp; slop(Que[qh], Que[qh + 1]) &gt;= 2 * a * S[i] + b) ++qh; int j = Que[qh]; F[i] = F[j] + a * sqr(S[i] - S[j]) + b * (S[i] - S[j]) + c; while (qt &gt; qh &amp;&amp; slop(Que[qt], i) &gt;= slop(Que[qt - 1], Que[qt])) --qt; Que[++qt] = i; } printf(\"%lld\\n\", F[N]); return 0;}","link":"/BZOJ-1911/"},{"title":"「ZJOI 2006」BZOJ 1862 GameZ游戏排名系统","text":"有 $n$ 个操作： 更新name的得分为score（删除以前的得分） 查询name的排名（得分相同按照时间先后排名） 查询得分第 $[k,k+10]$ 名的人的名字（如果没有 $k+10$ 个人就输出到最后一名为止） $n\\leq 250000$ 分析很明显的平衡树的板子，只是处理起来麻烦一些。 按照得分为第一关键字，时间为第二关键字维护平衡树，用一个map映射名字对应的得分。 平衡树需支持插入，删除，查询第 $k$ 大，查询名次，查询前驱的操作。 复杂度 $O(n\\log{n})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173/* * @Author: Skqliao * @Source: ZJOJ 2006 * @Problem: 1862: [Zjoi2006]GameZ游戏排名系统 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=1862 * @Date: 2019-02-21 16:26:15 * @LastEditTime: 2019-02-22 13:59:09 */#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;const int MAXN = 250000 + 5;int N;std::string s;struct Treap { std::string name; int key, key2, fix; int sz; Treap* ch[2]; int cmp(int x, int y) { if (key == x) { return y == key2 ? -1 : y &lt; key2; } return x &gt; key; } void pushUp() { sz = 1; if (ch[0]) sz += ch[0]-&gt;sz; if (ch[1]) sz += ch[1]-&gt;sz; }} *R(NULL), Pool[MAXN];int cntP;Treap* newTreap(int x, int t) { Pool[++cntP] = (Treap) {s, x, t, rand(), 1, NULL, NULL}; return Pool + cntP;}void rotate(Treap*&amp; t, int d) { Treap* k = t-&gt;ch[d ^ 1]; t-&gt;ch[d ^ 1] = k-&gt;ch[d]; k-&gt;ch[d] = t; t-&gt;pushUp(); k-&gt;pushUp(); t = k;}void insert(Treap*&amp; t, int x, int y) { if (!t) { t = newTreap(x, y); return; } int d = t-&gt;cmp(x, y); ++t-&gt;sz; insert(t-&gt;ch[d], x, y); if (t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix) { rotate(t, d ^ 1); }}void erase(Treap*&amp; t, int x, int y) { if (!t) return; --t-&gt;sz; int d = t-&gt;cmp(x, y); if (d == -1) { if (!t-&gt;ch[0]) { t = t-&gt;ch[1]; } else if (!t-&gt;ch[1]) { t = t-&gt;ch[0]; } else { int e = t-&gt;ch[0]-&gt;fix &gt; t-&gt;ch[1]-&gt;fix; rotate(t, e); erase(t-&gt;ch[e], x, y); } } else { erase(t-&gt;ch[d], x, y); } if (t) { t-&gt;pushUp(); }}int queryRank(Treap*&amp; t, int x, int y) { int num = t-&gt;ch[1] ? t-&gt;ch[1]-&gt;sz : 0; int d = t-&gt;cmp(x, y); if (d == -1) { return num + 1; } else if (d == 0) { return num + 1 + queryRank(t-&gt;ch[0], x, y); } else { return queryRank(t-&gt;ch[1], x, y); }}std::pair&lt;int, int&gt; queryKth(Treap*&amp; t, int x) { int num = t-&gt;ch[1] ? t-&gt;ch[1]-&gt;sz : 0; if (x == num + 1) { return std::make_pair(t-&gt;key, t-&gt;key2); } else if (x &lt;= num) { return queryKth(t-&gt;ch[1], x); } else { return queryKth(t-&gt;ch[0], x - num - 1); }}int mn, mn2;void queryPre(Treap*&amp; t, int x, int y) { if (!t) return; int d = t-&gt;cmp(x, y); if (d != 0) { if (t-&gt;key &gt; mn) { mn = t-&gt;key; mn2 = t-&gt;key2; s = t-&gt;name; } else if (t-&gt;key == mn &amp;&amp; t-&gt;key2 &lt; mn2) { mn2 = t-&gt;key2; s = t-&gt;name; } queryPre(t-&gt;ch[1], x, y); } else { queryPre(t-&gt;ch[0], x, y); }}__gnu_pbds::gp_hash_table&lt;std::string, int&gt; Map, Map2;int main() { int x; //srand((unsigned long long)new char); std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cin &gt;&gt; N; s = \"skqliao\"; insert(R, -INT_MAX, INT_MAX); for (int i = 1; i &lt;= N; ++i) { std::cin &gt;&gt; s; if (s[0] == '+') { s = s.substr(1); std::cin &gt;&gt; x; if (Map.find(s) != Map.end()) { erase(R, Map[s], Map2[s]); } Map[s] = x; Map2[s] = i; insert(R, x, i); } else if (s[0] == '?') { if (isdigit(s[1])) { int x = 0; for (size_t i = 1; i &lt; s.size(); ++i) { x = x * 10 + s[i] - '0'; } std::pair&lt;int, int&gt; a = queryKth(R, x); x = a.first; int y = a.second; for (int i = 0; i &lt; 10; ++i) { mn = -INT_MAX; mn2 = INT_MAX; queryPre(R, x, y); if (mn == -INT_MAX) break; std::cout &lt;&lt; s &lt;&lt; \" \"; x = mn, y = mn2 + 1; } std::cout &lt;&lt; \"\\n\"; } else { std::cout &lt;&lt; queryRank(R, Map[s.substr(1)], Map2[s.substr(1)]) &lt;&lt; \"\\n\"; } } } return 0;}","link":"/BZOJ-1862/"},{"title":"「SDOI 2009」BZOJ 1878 HH的项链","text":"在序列 $A[1 \\cdots N]$ 中，有 $M$ 个询问，查询 $[L_i,R_i]$ 中不同的数的个数。 $N\\leq 500000,M\\leq 200000$。 分析原题的数据 $N\\leq 50000$，莫队可以直接 $O(N\\sqrt{N+M})$ 水过。但是数据加强后 $N$ 增大到了原来10倍，带根号的复杂度不再满足要求，考虑一个log的方法。 这道题本质就是查询区间 $[l,r]$ 中不同的数的数目，重点在于处理相同的数。可以显然发现这是不符合区间减法的，因此单纯统计区间中数的出现次数是不行的。 如果同一时间只维护记录所有相同的数中的一个数，那么能保证不会重复统计；如果再保证查询的时候如果这个数存在于区间中，就一定能被查询到，那么就不会保证算少。 如果满足这两条，那么就使得原本查询区间中不同数的个数变成了查询区间中数的个数。 假如查询的区间都是 $[1,R_i]$ ，那么只需要统计同一个数中位置最靠左的那个数是否在 $[1, R_i]$中；如果是 $[L_i,R_i]$ ，同理统计的数就变成了出现位置尽可能接近 $L_i$ 且大于它的那个数是否在 $[L_i,R_i]$ 中。 那么维护方法就很显然了，记录每个数$A[i]$的下一个相同的数的位置 $Nxt[i]$，即满足 $A[i] = A[Nxt[i]]$ 。 随着区间的右移，删去 $A[i]$ 并插入 $A[Nxt[i]]$ ，再统计 $[L_i,R_i]$ 中数的个数。 这样的话查询的区间一定是要求有序的，因此需要离线操作，将所有区间按照左端点排序。 复杂度 $O(M\\log{M}+M\\log{N})$ 。 P.S 参考代码中是按照右端点排序的，操作同理，记录最靠右的数以及它靠前的相同的数的位置即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 500000 + 5;const int MAXM = 1000000 + 5;int N, M, A[MAXN];int Lst[MAXM], Pre[MAXN];int C[MAXN];int lowbit(int x) { return x &amp; -x;}void add(int p, int x) { for(; p &lt; MAXM; p += lowbit(p)) { C[p] += x; }}int query(int p) { int res = 0; for(; p &gt; 0; p -= lowbit(p)) { res += C[p]; } return res;}struct Query { int l, r, id; bool operator &lt; (const Query &amp;x) const { return r &gt; x.r; }} Q[MAXN];int Ans[MAXN];int main() { N = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { A[i] = io::gt&lt;int&gt;(); if(Lst[A[i]] != 0) { add(Lst[A[i]], -1); Pre[i] = Lst[A[i]]; } Lst[A[i]] = i; add(i, 1); } int M = io::gt&lt;int&gt;(); rep(i, 0, M) { Q[i].l = io::gt&lt;int&gt;(); Q[i].r = io::gt&lt;int&gt;(); Q[i].id = i; } std::sort(Q, Q + M); int pre = N; rep(i, 0, M) { while(pre &gt; Q[i].r) { add(pre, -1); if(Pre[pre]) { add(Pre[pre], 1); } pre--; } Ans[Q[i].id] = query(Q[i].r) - query(Q[i].l - 1); pre = Q[i].r; } rep(i, 0, M) { io::pt(Ans[i]); } io::flush(); return 0;}","link":"/BZOJ-1878/"},{"title":"「SHOI 2009」BZOJ 2028 会场预约","text":"初始集合为空，有两种操作： 插入一个区间，并删去集合中与它相交的区间，输出删除的区间个数 查询集合中区间个数 $N\\leq 200000,1\\leq Start End\\leq 100000$ 分析首先根据题意，可以得到集合中任意时刻不存在相交的区间。 假设集合中区间是有序的，那么插入一个区间 $[L,R ]$ 后所需要删除的区间一定是连续的。 两个区间 $[l,r]$ 和 $[L,R]$ ($l\\leq L$)如果相交，会有两种情况： $l \\leq L\\leq R\\leq r$ $L\\leq l\\leq r\\leq R$ 总结一下，如果满足 $l\\leq R$ 且 $L\\leq r$ ，那么这两个区间就是相交的。 那么找到第一个满足 $L\\leq r$ 的区间 $[l,r]$ 后，如果再满足 $l\\leq R$ ，就删除 $[l,r]$ ，重复该步骤直到集合为空或者 $R &lt; l$ 。 集合有序，二分寻找 $[l,r]$，删除节点，统计集合大小，STL库提供std::set 可以轻松实现上述功能。 值得注意的是，std::lower_bound(s.begin(),s.end(),x) 和 s.lower_bound(x) 的效率是不同的。由于std::set 的元素存储是随机的，因此直接二分寻找必须考虑寻找元素的复杂度，而它的提供的内置函数可以避免这个问题。 复杂度 $O(N\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace iostruct Node { int l, r; bool operator &lt; (const Node &amp;a) const { return r &lt; a.r; }};std::set&lt;Node&gt; Set;int main() { int N = io::gt&lt;int&gt;(); while (N--) { char opt = io::gc(); while (!isalpha(opt)) { opt = io::gc(); } if (opt == 'A') { int ans = 0; int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); std::set&lt;Node&gt;::iterator p = Set.lower_bound((Node) {0, l}); while (p != Set.end() &amp;&amp; r &gt;= p-&gt;l) { Set.erase(p++); ++ans; } Set.insert((Node) {l, r}); io::pt(ans); } else { io::pt(SZ(Set)); } } io::flush(); return 0;}","link":"/BZOJ-2028/"},{"title":"「POI2010」BZOJ 2086 Blocks","text":"序列 $A$ 有 $N$ 个数，有 $M$ 次查询。每次给定 $K$ 并可以进行以下操作：如果 $A[i] &gt; K$ 则可以将其减 $1$ 并使 $A[i-1]$ 或 $A[i+1]$ 加 $1$ 。经过任意多次操作后，求最长的连续子序列，其中元素值均不小于 $K$。 $N\\leq 1000000,M\\leq 50$ 。 分析若 $\\sum\\limits_{i=l}^{r}{A_i} \\geq K\\times (r - l + 1)$ ，则 $A[l\\cdots r]$ 一定可以经过若干次操作使得其中每个元素均不小于 $K$ 。 为了方便起见，使 $A[i] = A[i]-K$ ，则当 $\\sum\\limits_{i=l}^{r}{A_i} \\geq 0$ 成立时即可。 记 $Sum[i] = \\sum\\limits_{i=1}^{i}{A_i}$ ，则 $Sum[r]\\geq Sum[l-1]$ 与上式等价。 问题转化为求 $\\max(r-l)$ 使得 $Sum[r]\\geq Sum[l-1]$ 成立。 而所有可能成为最大区间的左端点的前缀和一定是单调递减的，因为若 $i &lt; j$ 且 $Sum[i] \\leq Sum[j]$ ，则选择 $i$ 作为左端点一定强于选 $j$ 。 同理若 $i &gt; j$ 且 $Sum[i] \\geq Sum[j]$，则选择 $i$ 作为右端点一定强于选 $j$，因此 $r$ 可以直接从右向左扫描右端点。 记当前栈顶（左端点）为 $S[top]$ ，若 $Sum[r] \\geq Sum[S[top]]$ 则弹出栈顶，直到满足 $Sum[r] &lt; Sum[S[top]]$ 为止。 那么之前的栈顶 $S[top+1]+1$ 到 $r$ ，是以 $r​$ 为右端点满足条件的最大区间。 答案为这些区间大小的最大值，复杂度 $O(NM)$ 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 1000000 + 5;int N, M, A[MAXN];int solve(int x) {static ll F[MAXN];static int Stk[MAXN];int top = 0, res = 0;rep(i, 1, N + 1) { F[i] = F[i - 1] + A[i] - x; if (F[Stk[top]] &gt; F[i]) { Stk[++top] = i; }}rof(i, N + 1, 1) { if (F[i] &gt;= 0) { return std::max(res, i); } while (top &amp;&amp; F[i] &gt;= F[Stk[top - 1]]) { --top; } chkMax(res, i - Stk[top]);}return res;}int main() {int x;scanf(\"%d%d\", &amp;N, &amp;M);rep(i, 1, N + 1) { scanf(\"%d\", &amp;A[i]);}rep(i, 0, M) { scanf(\"%d\", &amp;x); printf(\"%d \", solve(x));}return 0;}","link":"/BZOJ-2086/"},{"title":"「POI2010」BZOJ 2096 PIL-Pilots","text":"给定一个长度为 $N$ 的序列，求最长的最大值与最小值的差不超过 $K$ 的子段。 $N\\leq 3000000,k\\leq 2000000000$ 。 分析记 $l, r$ 为当前子段的首尾下标。开始尽可能让 $r$ 向右拓展。 当最小最大值的差超过 $K$ 时，让 $l$ 向右移动，直到满足条件为止。 通过两个单调队列维护极值，$\\max {r-l+1}$ 为答案。 复杂度 $O(N)$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }int N, K;std::deque&lt;int&gt; Dup, Ddown;std::deque&lt;int&gt; Qup, Qdown;void push(int x) { while(!Dup.empty() &amp;&amp; Dup.back() &lt; x) { Dup.pop_back(); } while(!Ddown.empty() &amp;&amp; Ddown.back() &gt; x) { Ddown.pop_back(); } Dup.push_back(x); Ddown.push_back(x); Qup.push_back(x); Qdown.push_back(x);}void pop() { int x = Qup.front(); Qup.pop_front(); if(x == Dup.front()) { Dup.pop_front(); } x = Qdown.front(); Qdown.pop_front(); if(x == Ddown.front()) { Ddown.pop_front(); }}void moveRight(int x) { push(x); while(!Dup.empty() &amp;&amp; Dup.front() - Ddown.front() &gt; K) { pop(); }}int main() { int x, ans = 0; scanf(\"%d%d\", &amp;K, &amp;N); rep(i, 1, N + 1) { scanf(\"%d\", &amp;x); moveRight(x); chkMax(ans, SZ(Qup)); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-2096/"},{"title":"「Usaco2010 Dec」BZOJ 2097 Exercise","text":"边权为 $1$ 的树上删去 $S$ 条边，求剩下森林中所有树的直径的最大值的最小值。 $N\\leq 100000$ 。 分析求最大值的最小值，这让我们想到了贪心。 二分确定当前直径的最大值 $L$ ，再通过贪心去删边，检查是否删去超过 $S$ 条边。 记 $f(i)$ 为以 $x$ 为根的子树中经过 $x$ 的最长链，对 $f(i)$ 进行排序。 删去最长链，直到当前最长链和次长链 $f(i)+f(i-1)\\leq L$ 。 那么 $f(x)$ 的递推关系式为 $f(x) = \\max{f(i)}$ ，显然 $f(i) \\leq L$ 。 复杂度 $O(N\\log^2{N})$ 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 100000 + 5;struct Edge {int v, nxt;} E[MAXN &lt;&lt; 1];int N, M;int H[MAXN], cntE;void addEdge(int u, int v) {E[++cntE] = (Edge) {v, H[u]};H[u] = cntE;E[++cntE] = (Edge) {u, H[v]};H[v] = cntE;}int F[MAXN], A[MAXN], total;void dfs(int x, int fa, int limit) {int cnt = 0;for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != fa) { dfs(v, x, limit); }}for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != fa) { A[++cnt] = F[v] + 1; }}std::sort(A, A + cnt + 1);while(cnt &amp;&amp; A[cnt] + A[cnt - 1] &gt; limit) { --cnt, ++total;}F[x] = A[cnt];}int check(int limit) {total = 0;dfs(1, -1, limit);return total &lt;= M;}int main() {int u, v;scanf(\"%d%d\", &amp;N, &amp;M);rep(i, 1, N) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v);}int l = 1, r = N, ans = N;while(l &lt;= r) { int m = (l + r) &gt;&gt; 1; if(check(m)) { ans = m; r = m - 1; } else { l = m + 1; }}printf(\"%d\\n\", ans);return 0;}","link":"/BZOJ-2097/"},{"title":"「JSOI 2010」BZOJ 2208 连通数","text":"给定 $n\\times n$ 的01矩阵表示有向图的连边情况。求有多少组 $(a,b)$ 满足 $a$ 到 $b$ 联通（$a,b$ 可以相同）。 $n\\leq 2000$ 分析Folyd传递闭包+bitset优化的模板题。 复杂度 $O(n^3/64)$ 或 $O(nm/64)$。 参考代码12345678910111213141516171819202122232425262728293031323334353637/* * @Author: Skqliao * @Source: JSOI 2010 * @Problem: 2208: [Jsoi2010]连通数 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2208 * @Date: 2019-03-05 20:26:54 * @LastEditTime: 2019-03-05 21:11:23 */#include &lt;bits/stdc++.h&gt;const int MAXN = 2000 + 5;int N;char S[MAXN];std::bitset&lt;MAXN&gt; B[MAXN];int main() { scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; ++i) { scanf(\"%s\", S); for (int j = 0; j &lt; N; ++j) { B[i][j] = S[j] == '1'; } B[i][i] = 1; } for (int i = 0; i &lt; N; ++i) { for (int j = 0; j &lt; N; ++j) { if (B[i][j]) B[i] |= B[j]; } } int ans = 0; for (int i = 0; i &lt; N; ++i) { ans += B[i].count(); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-2208/"},{"title":"「2010 集训队测验」BZOJ 2127 文理分科","text":"在 $n\\times m$ 的矩阵中，每个格子可以选择 $0/1$，分别获得收益 $A_{i,j},B_{i,j}$。如果上下两个格子选择相同，则额外获得收益 $C_{i,j}$ 与 $D_{i,j}$（都选 $0$ 或都选 $1$），如果左右两个格子选择相同，则额外获得收益 $E_{i,j}$ 与 $F_{i,j}$。求总收益的最大值。 $n,m\\leq 100,A,B,C,D,E,F_{i,j}\\leq 5000$ 分析这是集训队论文《浅谈一类最小割问题》中的例题，也是网络流建模之二元关系的一道典型题目。 根据相关建图模型，对于每个点 $x$，分别与 $S,T$ 连边，割去 $(S,x)$表示选择文科，割去 $(x,T)$ 表示选择理科。 由于只能求最小割，因此可以先累计所有收益再减去最小割得到最大值。 由于每个点与相邻的点之间的选择会影响结果，因此 $x$ 与相邻的点连边。 对于任意两个相邻点 $x,y$，子图有边 $(S,x),(S,y),(x,y),(y,x),(x,T),(y,T)$。 割去 $(S,x),(S,y)$ 表示都选文，割去 $(x,T),(y,T)$ 表示都选理，割去 $(S,x),(x,y),(y,T)$ 表示 $x$ 选文，$y$选理，剩下一种情况同理第三种。 假设 $x,y$ 选文的收益分别为 $a_x,a_y$，选理的收益为 $b_x,b_y$，都选文/理的收益为 $c,d$，则边权应满足： $$(S,x)+(S,y)=b_x+b_y+d\\(x,T)+(y,T)=a_x+a_y+c\\(S,x)+(x,y)+(y,T)=a_y+b_x+c+d\\(S,y)+(y,x)+(x,T)=a_x+b_y+c+d\\$$得到一组解： $$(x,y)=(y,x)=\\frac{c+d}{2}\\(S,x)=a_x+\\frac{c}{2}\\(S,y)=a_y+\\frac{c}{2}\\(x,T)=b_x+\\frac{d}{2}\\(y,T)=b_y+\\frac{d}{2}\\$$ 由此建图求最大流即可。 Tips：将两点间所有边的边权整合成一条边会大大提高运行速度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* * @Author: Skqliao * @Date: 2019-02-10 20:45:11 * @LastEditTime: 2019-02-10 21:37:48 * @Source: 2010 集训队测试题 * @Problem: 2127: happiness * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2127 */#include &lt;bits/stdc++.h&gt;namespace mxf {const int MAXN = 100 * 100 + 5;const int MAXM = MAXN * 4;struct Edge {int v, f, nxt;} E[MAXM &lt;&lt; 1];int S, T;int H[MAXN], cntE;void addEdge(int u, int v, int f, bool directed = 1) {E[++cntE] = (Edge){v, f, H[u]};H[u] = cntE;if (directed) f = 0;E[++cntE] = (Edge){u, f, H[v]};H[v] = cntE;}int Dis[MAXN], Cur[MAXN];bool bfs() {static std::queue&lt;int&gt; Que;while (!Que.empty()) Que.pop();memset(Dis, -1, sizeof Dis);memcpy(Cur, H, sizeof H);Dis[S] = 0;Que.push(S);while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } }}return false;}int dfs(int x, int maxf) {if (x == T) return maxf;int left = maxf;for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; }}return maxf - left;}int dinic() {int flow = 0;while (bfs()) { flow += dfs(S, INT_MAX);}return flow;}void init(int tot) {cntE = -1;memset(H, -1, sizeof H);S = tot + 1, T = tot + 2;}} // namespace mxfusing mxf::addEdge;using mxf::S;using mxf::T;const int MAXN = 100 + 5;int N, M;int Id[MAXN][MAXN];int A[MAXN][MAXN], B[MAXN][MAXN], C[MAXN][MAXN], D[MAXN][MAXN], E[MAXN][MAXN], F[MAXN][MAXN];int ans;int main() {scanf(\"%d%d\", &amp;N, &amp;M);mxf::init(N * M);for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { Id[i][j] = (i - 1) * M + j; }}for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); ans += A[i][j]; A[i][j] *= 2; }}for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;B[i][j]); ans += B[i][j]; B[i][j] *= 2; }}for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;C[i][j]); ans += C[i][j]; A[i][j] += C[i][j]; A[i + 1][j] += C[i][j]; }}for (int i = 1; i &lt; N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;D[i][j]); ans += D[i][j]; B[i][j] += D[i][j]; B[i + 1][j] += D[i][j]; addEdge(Id[i][j], Id[i + 1][j], C[i][j] + D[i][j], 0); }}for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;E[i][j]); ans += E[i][j]; A[i][j] += E[i][j]; A[i][j + 1] += E[i][j]; }}for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt; M; ++j) { scanf(\"%d\", &amp;F[i][j]); ans += F[i][j]; B[i][j] += F[i][j]; B[i][j + 1] += F[i][j]; addEdge(Id[i][j], Id[i][j + 1], E[i][j] + F[i][j], 0); }}for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { addEdge(S, Id[i][j], A[i][j]); addEdge(Id[i][j], T, B[i][j]); }}printf(\"%d\\n\", ans - mxf::dinic() / 2);return 0;}","link":"/BZOJ-2127/"},{"title":"「SDOI 2011」BZOJ 2243 染色","text":"给定一棵有 $N$ 个节点的树，每个节点有一个颜色。 现有$M$个操作，分为两类： 将节点对 $(u,v)$ 之间路径上的所有节点的颜色染成 $x$ 查询节点对 $(u,v)$ 之间颜色段的个数（相邻且相同颜色的节点对属于同一个颜色段） $N,M\\leq 10^5,x\\leq 10^9$ 分析思路很简单，树剖之后用线段树维护区间颜色段的个数。 线段树总共需要维护区间的颜色段个数，最左边颜色和最右边颜色，当然还有lazy标签。 如果区间 $[l,m]$ 的最右边的颜色和区间 $[m+1,r+1]$ 最左边的颜色相同，则 $[l,r]$ 区间中颜色段个数为两者的和减一。 查询的时候有一个细节。 $(u,v)$ 之间颜色段的个数即若干条链上颜色段的个数之和，但是要注意链顶和它的父亲颜色是否相同。 这两个节点也是相邻的，但是在链的查询中不会被涉及到。 复杂度 $O(N+M\\log^2{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 1e5 + 4;struct Graph { struct Edge { int v, nxt; } E[MAXN &lt;&lt; 1]; int N, R; int Depth[MAXN], Son[MAXN], Fa[MAXN], Sz[MAXN]; int Dfn[MAXN], cntD, Top[MAXN]; int W[MAXN], Wp[MAXN]; int H[MAXN], cntE; void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; } void dfs(int x) { Son[x] = 0, Sz[x] = 1; for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { Fa[v] = x; Depth[v] = Depth[x] + 1; dfs(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } } } void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; W[cntD] = Wp[x]; if(Son[x]) { dfs2(Son[x], top); } for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Son[x] &amp;&amp; v != Fa[x]) { dfs2(v, v); } } }#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, r int Num[MAXN &lt;&lt; 2], Mark[MAXN &lt;&lt; 2], Left[MAXN &lt;&lt; 2], Right[MAXN &lt;&lt; 2]; void pushUp(int rt) { Num[rt] = Num[rt &lt;&lt; 1] + Num[rt &lt;&lt; 1 | 1] - (Right[rt &lt;&lt; 1] == Left[rt &lt;&lt; 1 | 1]); Left[rt] = Left[rt &lt;&lt; 1]; Right[rt] = Right[rt &lt;&lt; 1 | 1]; } void pushDown(int rt, int L) { int &amp;mrk = Mark[rt]; if(!mrk) { return ; } Mark[rt &lt;&lt; 1] = Mark[rt &lt;&lt; 1 | 1] = mrk; Num[rt &lt;&lt; 1] = Num[rt &lt;&lt; 1 | 1] = 1; Left[rt &lt;&lt; 1] = Left[rt &lt;&lt; 1 | 1] = mrk; Right[rt &lt;&lt; 1] = Right[rt &lt;&lt; 1 | 1] = mrk; mrk = 0; } void build(int rt, int l, int r) { if(l == r) { Num[rt] = 1; Left[rt] = Right[rt] = W[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt); } void change(int rt, int l, int r, int a, int b, int x) { if(a &lt;= l &amp;&amp; r &lt;= b) { Num[rt] = 1; Left[rt] = Right[rt] = x; Mark[rt] = x; return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { change(LT, a, b, x); } if(m &lt; b) { change(RT, a, b, x); } pushUp(rt); } int queryNum(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Num[rt]; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; int res = 0, times = 0; if(a &lt;= m) { res += queryNum(LT, a, b); ++times; } if(m &lt; b) { res += queryNum(RT, a, b); ++times; } if(times == 2 &amp;&amp; Right[rt &lt;&lt; 1] == Left[rt &lt;&lt; 1 | 1]) { --res; } return res; } int query(int rt, int l, int r, int p) { if(l == r) { return Left[rt]; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { return query(LT, p); } else { return query(RT, p); } } void changePath(int u, int v, int x) { int tu = Top[u], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } change(1, 1, N, Dfn[tv], Dfn[v], x); v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } change(1, 1, N, Dfn[u], Dfn[v], x); } int queryPath(int u, int v) { int res = 0, tu = Top[u], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } res += queryNum(1, 1, N, Dfn[tv], Dfn[v]); if(query(1, 1, N, Dfn[tv]) == query(1, 1, N, Dfn[Fa[tv]])) { --res; } v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } res += queryNum(1, 1, N, Dfn[u], Dfn[v]); return res; } void prepare() { dfs(R); dfs2(R, R); build(1, 1, N); }} G;int main() { G.N = io::gt&lt;int&gt;(); G.R = 1; int M = io::gt&lt;int&gt;(); rep(i, 1, G.N + 1) { G.Wp[i] = io::gt&lt;int&gt;(); } rep(i, 1, G.N) { G.addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } G.prepare(); while(M--) { char c = io::gc(); while(!isalpha(c)) { c = io::gc(); } int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); if(c == 'C') { G.changePath(u, v, io::gt&lt;int&gt;()); } else { io::pt(G.queryPath(u, v)); } } io::flush(); return 0;}","link":"/BZOJ-2243/"},{"title":"「ZJOI 2011」BZOJ 2229 最小割","text":"$T$ 组数据，$Q$ 个询问。在无向图 $G$ 中，求有多少个点对 $(s,t)$ 使得它们之间的最小割不超过 $x$。 $T\\leq 10,n\\leq 150,m\\leq 3000,q\\leq 30$ 分析建完最小割树后，问题转化为求树上有多少个点对路径上的边权最小值不超过 $x$。 枚举点对再用倍增判断，复杂度 $O(n^2\\log{n})$。 也存在线性做法，对于边权不超过 $x$ 的边，统计路径通过该边新增的点对数量，复杂度 $O(n)$。 然而由于复杂度瓶颈在建立最小割树上，因此两种方法实际效率相仿。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* * @Author: Skqliao * @Date: 2019-02-02 22:57:06 * @LastEditTime: 2019-02-03 11:53:06 * @Source: ZJOI 2011 * @Problem: 2229: [Zjoi2011]最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2229 */#include &lt;bits/stdc++.h&gt;const int MAXN = 150 + 5;const int MAXM = 3000 + 5;namespace GH_Tree {struct Edge { int v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge){v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, w, H[v]}; H[v] = cntE;}int Fa[MAXN], Sz[MAXN];int dfs(int x) { Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; Sz[x] += dfs(v); } } return Sz[x];}int ans;int dfs(int x, int sz, int mx) { int tot = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { if (E[i].w &lt;= mx) { tot += Sz[v]; ans += Sz[v] * (sz - Sz[v]); sz -= Sz[v]; dfs(v, Sz[v], mx); } else { int tmp = dfs(v, sz, mx); sz -= tmp; tot += tmp; } } } return tot;}void init() { cntE = 0; memset(H, 0, sizeof H);}int query(int x) { ans = 0; dfs(1, Sz[1], x); return ans;}namespace Init { struct Edge { int v, f, cap, nxt; } E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; int Idx[MAXN], Tmp[MAXN]; int S, T; int Dis[MAXN], Cur[MAXN]; int Col[MAXN]; void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; } } void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE; } bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false; } int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left; } int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow; } void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); } } void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); GH_Tree::addEdge(S, T, f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r); } void solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); }} // namespace Init} // namespace GH_Treeint T, N, M, Q;int main() { int x; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;N, &amp;M); GH_Tree::init(); GH_Tree::Init::solve(N, M); GH_Tree::dfs(1); scanf(\"%d\", &amp;Q); while (Q--) { scanf(\"%d\", &amp;x); printf(\"%d\\n\", GH_Tree::query(x)); } puts(\"\"); } return 0;}","link":"/BZOJ-2229/"},{"title":"「SCOI 2011」BZOJ 2330 糖果","text":"有 $N$ 个数 $A[1 \\cdots N](A[i] &gt; 0)$，要求满足 $M$ 个条件。条件形如： $A[i] \\leq A[j]$，$A[i] &lt; A[j]$， $A[i] = A[j]$ 。如果可以满足所有条件，求 $\\sum{A_i}$ 的最小值，否则输出 -1。 $N,M\\leq 100000$ 分析将条件依次转化为 $A[j] - A[i] \\geq 0$，$A[j] - A[i]\\geq 1$，$A[j]-A[i]\\geq 0 \\&amp; A[i]-A[j]\\geq 0$。 根据 $u - v\\geq w$ 建有向边 $(v, u, w)$ 的方式建图，求最长路。 如果单纯通过spfa进队 $N$ 次来判断无解可能会导致超时，发现无解本质为出现正环。因此可以采用Tarjan求联通分量，判断各分量内是否存在非零边的方法做到 $O(N+M)$ 判断无解。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;const int MAXN = 100000 + 5;int N, K;struct Edge { int u, v, w, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE;}std::queue&lt;int&gt; Que;long long Dis[MAXN];bool Inq[MAXN];long long spfa() { for (int i = 1; i &lt;= N; ++i) { Dis[i] = 1; Que.push(i); } while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &lt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } long long res = 0; for (int i = 1; i &lt;= N; ++i) { res += Dis[i]; } return res;}int Dfn[MAXN], Low[MAXN], cntD;int Stk[MAXN], top;int Belong[MAXN], cntB;void dfs(int x) { Dfn[x] = Low[x] = ++cntD; Stk[++top] = x; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (!Dfn[v]) { dfs(v); Low[x] = std::min(Low[x], Low[v]); } else if (!Belong[v]) { Low[x] = std::min(Low[x], Dfn[v]); } } if (Dfn[x] == Low[x]) { Belong[x] = ++cntB; do { Belong[Stk[top]] = cntB; } while (Stk[top--] != x); }}int main() { int opt, x, y; scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 1; i &lt;= K; ++i) { scanf(\"%d%d%d\", &amp;opt, &amp;x, &amp;y); if (opt == 1) { addEdge(x, y, 0); addEdge(y, x, 0); } else if (opt == 2) { addEdge(x, y, 1); } else if (opt == 3) { addEdge(y, x, 0); } else if (opt == 4) { addEdge(y, x, 1); } else if (opt == 5) { addEdge(x, y, 0); } if (opt % 2 == 0 &amp;&amp; x == y) { puts(\"-1\"); return 0; } } for (int i = 1; i &lt;= N; ++i) { if (!Dfn[i]) { dfs(i); } } bool flag = 0; for (int i = 1; i &lt;= cntE; ++i) { if (E[i].w &amp;&amp; Belong[E[i].u] == Belong[E[i].v]) { flag = 1; break; } } if (flag) { puts(\"-1\"); } else { printf(\"%lld\\n\", spfa()); } return 0;}","link":"/BZOJ-2330/"},{"title":"「中山市选 2009」 BZOJ 2464 小明的游戏","text":"在一个 $N\\times M$ 的01网格图中，每次可以向相邻的格子移动，移动到同一类型的格子的花费为 $0$，否则为 $1$，求起点到终点的最小花费。 $1\\leq n, m\\leq 500$ 分析由于边权非 $0$ 即 $1$，因此SPFA的复杂度上限就是点数，即 $N^2$ 。 复杂度 $O(T\\times N^2)$ ，其中 $T$ 为数据组数。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"game.in\", \"r\", stdin); freopen(\"game.out\", \"w\", stdout);}const int MAXN = 500 + 5;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;char Str[MAXN][MAXN];int sx, sy, ex, ey;bool check(int x, int y) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &lt; M;}int spfa() { static int Dis[MAXN][MAXN]; static bool Inq[MAXN][MAXN]; std::queue&lt;int, std::deque&lt;int&gt; &gt; Qx, Qy; memset(Inq, 0, sizeof Inq); memset(Dis, 0x3f, sizeof Dis); Qx.push(sx); Qy.push(sy); Dis[sx][sy] = 0; while (!Qx.empty()) { int x = Qx.front(), y = Qy.front(); Qx.pop(), Qy.pop(); Inq[x][y] = 0; rep(i, 0, 4) { int nx = x + Dicx[i];; int ny = y + Dicy[i]; if (!check(nx, ny)) { continue ; } int dis = Dis[x][y] + (Str[x][y] != Str[nx][ny]); if (Dis[nx][ny] &gt; dis) { Dis[nx][ny] = dis; if (!Inq[nx][ny]) { Inq[nx][ny] = 1; Qx.push(nx); Qy.push(ny); } } } } return Dis[ex][ey];}int main() { //open(); while (true) { scanf(\"%d%d\", &amp;N, &amp;M); if (N + M == 0) { break; } rep(i, 0, N) { scanf(\"%s\", Str[i]); } scanf(\"%d%d%d%d\", &amp;sx, &amp;sy, &amp;ex, &amp;ey); printf(\"%d\\n\", spfa()); } return 0;}","link":"/BZOJ-2464/"},{"title":"「POI2011」BZOJ 2276 Temperature","text":"长为 $N$ 的序列中，每个数的取值范围为 $[L_i,R_i]$ 。求最长不下降连续子序列的长度。 $N\\leq 10^6$ 分析单调队列维护递减的 $l$ ，如果当前 $r$ 比队首的 $l$ 小，则弹出队首直到 $r$ 大于等于它为止。 读入数据很大，需要读入优化。 复杂度 $O(N)$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace iostruct Mqueue { std::deque&lt;int&gt; Q, M; void push(int x) { while(!M.empty() &amp;&amp; M.back() &lt; x) { M.pop_back(); } M.push_back(x); Q.push_back(x); } void pop() { int x = Q.front(); Q.pop_front(); if(x == M.front()) { M.pop_front(); } } void maintain(int x) { while(!M.empty() &amp;&amp; M.front() &gt; x) { pop(); } } size_t size() { return SZ(Q); }}Q;int main() { int res = 0; int N = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); Q.maintain(r); Q.push(l); chkMax(res, SZ(Q)); } printf(\"%d\\n\", res); return 0;}","link":"/BZOJ-2276/"},{"title":"「中山市选 2009」BZOJ 2465 小球","text":"$n$ 个球放进 $m$ 个瓶子里，每个球有分数$A_i$，每个瓶子有容积 $B_i$，且瓶中球的分数都不能超过 $C_i$，求可放入球的最大数量以及在该条件下的最大分数和。 $1\\leq n\\leq 200,0\\leq m\\leq 200,1 \\leq p\\leq 10^6, 0\\leq c\\leq 200, 1\\leq q\\leq 10^6$ 分析费用流第一看看就是个很裸的费用流，用最大流来保证取的球最多，最小费用来保证总分数最大（分数取反作费用）。 用 $(u,v,f,c)$ 表示一条由 $u$ 到 $v$ 流量限制为 $f$ 费用为 $c$ 的边，那么本题建图方法如下： $(S, i, 1, 0) ,i \\in[1, n]$ $(i,T,B_i,0),i\\in[n+1,n+m]$ $(i,j,1,-A_i),A_i\\leq C_j$ 复杂度 $O(NMF)$，$F$ 为最大流的值。 贪心其实此题更明显的做法应该是贪心。 将球按照分数排序，由于它们空间相同（都是 $1$），因此将分数大的球放到分数限制大的瓶子里一定会放置最多的球。 复杂度 $O(M\\log{M}+N\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt; #define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"ball.in\", \"r\", stdin); freopen(\"ball.out\", \"w\", stdout);} const int MAXN = 400 + 5;const int INF = INT_MAX;int A[MAXN], B[MAXN], C[MAXN]; struct Edge { int v, c, f, nxt;} E[MAXN * MAXN];int N, M, S, T;int cost, flow;int H[MAXN], cntE;int Lp[MAXN], Le[MAXN], Dis[MAXN];std::bitset&lt;MAXN&gt; Inq; void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE;} bool spfa() { static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if (!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;} void buildGraph() { S = N + M + 1, T = N + M + 2; memset(H, -1, sizeof H); cntE = -1; rep(i, 1, N + 1) { addEdge(S, i, 1, 0); } rep(i, 1, M + 1) { addEdge(i + N, T, B[i], 0); } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (::A[i] &lt;= ::C[j]) { addEdge(i, N + j, INF, -::A[i]); } } }} void mcmf() { buildGraph(); cost = flow = 0; while (spfa()) { int f = INF; for (int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } cost += f * Dis[T]; flow += f; for (int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } }} int main() { //open(); while (true) { scanf(\"%d%d\", &amp;N, &amp;M); if (N + M == 0) { break; } rep(i, 1, N + 1) { scanf(\"%d\", &amp;A[i]); } rep(i, 1, M + 1) { scanf(\"%d%d\", &amp;B[i], &amp;C[i]); } mcmf(); printf(\"%d %d\\n\", flow, -cost); } return 0;}","link":"/BZOJ-2465/"},{"title":"「中山市选 2009」BZOJ 2466 树","text":"树 $T$ 上的每个节点都一盏熄灭的灯，已知按下某个节点的开关会改变它与它相连的所有节点的灯的状态，求将所有灯变亮的最少操作次数。 $1\\leq n\\leq 100$ 分析发现每个操作都是独立的，也就是说至多每个开关按一次。 再根据按开关会改变所有与它相连的灯的状态，想到一定是自叶子到根进行操作，那么就树形DP。 DP中注意当前节点无论亮与否，它的子树一定是全亮的（因为操作是一直往根上走的）。 对于一个节点有四种状态：按开关且亮、按开关且灭、不按开关且亮、不按开关且灭。 可以发现第二种没有意义（不按都亮了那还按它干什么）。 考虑剩余三种的状态如何从儿子转移。 其中“按开关且亮”的状态最简单，因为按了它之后要保证它的子树的灯全是亮的，因此从“它的所有儿子都灭且没按”的状态转移而来。 “不按开关且灭”的状态从“当前亮+当前儿子按且亮”或“当前灭+当前儿子不按且亮”转移。 “不按开关且亮”的状态从“当前亮+当前儿子不按且亮”或“当前灭+当前儿子按且亮”转移。 复杂度 $O(n)$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;void open() { freopen(\"tree.in\", \"r\", stdin); freopen(\"tree.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int INF = 0x03ffffff;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int N;int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}int F[MAXN][2][2];void dfs(int x, int fa) { int a = 0, b = INF, c = 0; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa) { int aa = a, bb = b; dfs(v, x); a = std::min(aa + F[v][0][1], bb + F[v][1][1]); b = std::min(aa + F[v][1][1], bb + F[v][0][1]); c += F[v][0][0]; } } F[x][0][0] = a; F[x][0][1] = b; F[x][1][1] = c + 1;}int main() { //open(); int u, v; while (true) { scanf(\"%d\", &amp;N); if (N == 0) { break; } cntE = -1; memset(H, -1, sizeof H); rep(i, 1, N) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); } dfs(1, 0); printf(\"%d\\n\", std::min(F[1][0][1], F[1][1][1])); } return 0;}","link":"/BZOJ-2466/"},{"title":"「SHOI2010」BZOJ 2521 最小生成树","text":"$N$ 点 $M$ 边的无向图 $G$ 中，每次可以使一条边边权+1。求最少进行多少次操作可以使得第 $id$ 条边一定出现在 $G$ 的最小生成树中。 $1\\leq N\\leq 500,1\\leq M\\leq 800$ 分析首先题目中的“除了指定一条边，其他所有边边权-1”的操作本质上就是使该边边权+1，其他边不变。 根据Kruskal的流程，若某条边权为 $x$ 的边 $e(u,v)$ 出现在MST中，就说明加完所有边权小于等于它的边后， $u,v$ 两点不联通。 在这道题中，边权小于等于 $x$ 的边构成了子图 $T$，为了保证 $e$ 一定在MST上，必须使得 $T$ 中 $u,v$ 不联通，而可以进行的操作就是增加边权。 若增加后某边的边权超过 $x$ ，这条边就相当于从 $T$ 中被删去。也就是说删去一条边权为 $w$ 的边，只需要将其增加至 $x+1$ ，即增加了 $x+1-w$ 次。 既然是破坏 T 中两点的联通性，就想到割。最小割即为将破坏源汇点联通性所需要的最小代价。第 $i$ 条边被割的代价为 $x+1-w_i$ 。 那么把 $u$ 做源点， $v$ 做汇点，建图，图的边权为 $x+1-w_i(w_i\\leq x)$ ，求得的最小割的值即为答案。 注意加边的时候需要加双向边，因为原图是无向图。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 500 + 5;const int MAXM = 800 * 2 + 5;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int N, M, S, T;int H[MAXN], cntE;int Cur[MAXN], Lv[MAXN], Dis[MAXN], tim, ffffc;int Flow[MAXM &lt;&lt; 1];void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for (Que[qt++] = S; qh &lt; qt;) { int &amp;x = Que[qh++]; if (x == T) { return true; } for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] != tim &amp;&amp; E[i].f) { Lv[v] = tim; Dis[v] = Dis[x] + 1; Que[qt++] = v; } } } return false;}int dfs(int x, int maxf) { if (x == T || maxf == 0) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}int dinic() { int F = 0; while (true) { while (bfs()) { memcpy(Cur, H, sizeof Cur); F += dfs(S, INT_MAX); } if (!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof Flow); } return F;}std::vector&lt;std::pair&lt;int, pii&gt; &gt; V;int main() { int u, v, w, id; scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;id); memset(H, -1, sizeof H); cntE = -1; --id; rep(i, 0, M) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); V.push_back(std::make_pair(w, std::make_pair(u, v))); } S = V[id].second.first, T = V[id].second.second; rep(i, 0, M) { if(V[i].first &lt;= V[id].first &amp; i != id) { addEdge(V[i].second.first, V[i].second.second, V[id].first - V[i].first + 1); addEdge(V[i].second.second, V[i].second.first, V[id].first - V[i].first + 1); } } printf(\"%d\\n\", dinic()); return 0;}","link":"/BZOJ-2521/"},{"title":"「WC 2008」BZOJ 2595 游览计划","text":"在 $n\\times m$ 的网格图上有 $k$ 个景点，图上选择任意一个点有费用 $a_{i,j}$。求选择若干个点使得这 $k​$ 个景点联通，最小化花费并输出方案。 $n,m,k\\leq 10$ 分析这是一道最小斯坦纳树（minimum Steiner tree）的模板题。 其实看到这么小的数据范围也不难想到状压DP。用 $F[i][j][S]$ 表示当前选择点 $(i,j)$，图的联通状态为 $S$ 的最小花费。 转移方程有两个，一是状态间转移： $F[i][j][S] = \\min\\limits_{T\\in S}{F[i][j][T]+F[i][j][S-T]-A[i][j]}$；二是在同一个状态内松弛： $F[i][j][S] = \\min{F[i’][j’][S]+A[i][j]}$，其中 $(i’,j’)$ 与 $(i,j)$ 联通且属于 $S$。 前者可以通过枚举子集的方法转移，复杂度$O(6^k\\cdot n\\cdot m)$，后者用spfa或其他最短路算法松弛，复杂度 $O(2^k\\cdot f)$，$f$ 为最短路复杂度。总复杂度 $O(6^k\\cdot nm+2^k\\cdot f)$ 。 在转移/松弛时记录前一个点的状态，最后从终点一遍dfs得到所有被选择的点。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 /* * @Author: Skqliao * @Date: 2019-01-27 10:29:05 * @LastEditTime: 2019-01-27 12:39:07 * @Source: WC2008 * @Problem: 2595: [Wc2008]游览计划 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=2595 */#include &lt;bits/stdc++.h&gt;const int MAXN = 10 + 2;const int MAXS = 1 &lt;&lt; MAXN;const int INF = 0x3f3f3f3f;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;int A[MAXN][MAXN];int F[MAXN][MAXN][MAXS];struct Node { int x, y, s;} Pre[MAXN][MAXN][MAXS];std::queue&lt;Node&gt; Que;bool Vis[MAXN][MAXN];void spfa(int s) { while (!Que.empty()) { Node a = Que.front(); Vis[a.x][a.y] = 0; Que.pop(); for (int i = 0; i &lt; 4; ++i) { int x = a.x + Dicx[i]; int y = a.y + Dicy[i]; if (x &lt; 1 || y &lt; 1 || x &gt; N || y &gt; M) { continue; } if (F[a.x][a.y][s] + A[x][y] &lt; F[x][y][s]) { F[x][y][s] = F[a.x][a.y][s] + A[x][y]; Pre[x][y][s] = (Node){a.x, a.y, s}; if (!Vis[x][y]) { Que.push((Node) {x, y, 0}); Vis[x][y] = 1; } } } }}void dfs(int x, int y, int s) { Vis[x][y] = 1; Node &amp;a = Pre[x][y][s]; if (a.x == 0 &amp;&amp; a.y == 0) { return ; } dfs(a.x, a.y, a.s); if (x == a.x &amp;&amp; y == a.y) { dfs(a.x, a.y, s - a.s); }}int main() { int cnt = 0; scanf(\"%d%d\", &amp;N, &amp;M); memset(F, 0x3f, sizeof F); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;A[i][j]); if (!A[i][j]) { F[i][j][1 &lt;&lt; cnt++] = 0; } } } int S = (1 &lt;&lt; cnt) - 1; for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { for (int x = s; x; x = (x - 1) &amp; s) { if (F[i][j][x] + F[i][j][s - x] - A[i][j] &lt; F[i][j][s]) { F[i][j][s] = F[i][j][x] + F[i][j][s - x] - A[i][j]; Pre[i][j][s] = (Node) {i, j, x}; } } if (F[i][j][s] &lt; INF) { Que.push((Node) {i, j, 0}); Vis[i][j] = 1; } } } spfa(s); } bool flag = 0; for (int i = 1; i &lt;= N &amp;&amp; !flag; ++i) { for (int j = 1; j &lt;= M; ++j) { if (A[i][j] == 0) { printf(\"%d\\n\", F[i][j][S]); dfs(i, j, S); flag = 1; break; } } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { if (!A[i][j]) { putchar('x'); } else if (Vis[i][j]) { putchar('o'); } else { putchar('_'); } } puts(\"\"); } return 0;}","link":"/BZOJ-2595/"},{"title":"BZOJ 2741【FOTILE模拟赛】L","text":"给定长为 $N$ 的序列 $A[1 \\cdots N]$，$M$ 个询问。查询 $[l,r]$ 的最大异或和子区间，强制在线。 $N\\leq 12000,M\\leq 6000$ 分析可持久化Trie+分块。 记 $s[i]$ 为第 $i$ 块的左端点，$f(i,j)$ 表示$[s[i],r-1]$中的某个点为左端点，右端点为 $r$ 的最大异或子区间。 记 $g(i,j)$ 为$[s[i],r]$ 中的最大异或子区间，则 $g(i,j)=max(g(i,j-1),f(i,j))$。 查询时跨越的完整块直接查 $g$ 数组，剩下的部分在可持久化Trie中查询，取最大值。 复杂度 $O(n\\sqrt{n}\\log{max(A_i)})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;const int MAXN = 12000 + 5;const int MAXM = 40;const int MAXK = 130;int N, M, A[MAXN];struct Trie { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], nT = 1;int insert(int pre, int x) { int rt = ++nT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++nT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int len, n, Belong[MAXN], G[MAXK][MAXN];int queryLR(int l, int r) { int ans = 0, t = r; for (int i = 1; i &lt;= n; ++i) { if ((i - 1) * len + 1 &gt;= l &amp;&amp; (i - 1) * len + 1 &lt;= r) { ans = G[i][r]; t = (i - 1) * len + 1; break; } } for (int i = l; i &lt;= t; ++i) { ans = std::max(ans, query(Rt[l - 1], Rt[r], A[i])); } return ans;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); len = sqrt(N), n = N / len + (N % len &gt; 0); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); A[i] ^= A[i - 1]; Rt[i] = insert(Rt[i - 1], A[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = (i - 1) * len + 1; j &lt;= N; ++j) { G[i][j] = std::max(G[i][j - 1], query(Rt[(i - 1) * len], Rt[j - 1], A[j])); if (i == 1) { G[i][j] = std::max(G[i][j], A[j]); } } } int ans = 0, l, r; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d\", &amp;l, &amp;r); ans %= N; l = (l + ans) % N + 1; r = (r + ans) % N + 1; if (l &gt; r) { std::swap(l, r); } printf(\"%d\\n\", ans = queryLR(l - 1, r)); } return 0;}","link":"/BZOJ-2741/"},{"title":"BZOJ 2654 tree","text":"在一张无向带权连通图中，每条边是黑色或白色。求一棵恰好有need条白色边的生成树，并使得权值和最小。 $V\\leq 50000,E\\leq 100000$ 。 分析直接求最小生成树显然不能保证一定出现need条白边，而最小生成树只跟边权有关，因此需要对这些边权做一些手脚。 记 $f(x)$ 为所有白边边权增加 $x$ 后，新图的最小生成树中白边的个数，易得 $f(x)$ 随 $x$ 增大而单调不递增。 证明如下：考虑Kruskal算法的流程，如果 $x$ 增加，新排序的白边一定会集体向后移动，而黑边则会排在更前面的位置，因此生成树上白边的数量一定不会增加，最多维持不变。 那么假设白边边权全部增加 $x$ 后新图的最小生成树的白边数量恰好为need条，权值和为 $sum$ ，则实际生成树的权值和为 $sum-need\\times x$ 。 如此就可以对 $x$ 二分，极端情况就是将权值最小的白边排在权值最大的黑边后面，因此 $x$ 的上界是为 $max{w_i}$ ， $w_i$ 为原图的边权。 当出现黑边和白边边权相等的情况时，将白边排在前面，如此可以使得白边尽可能的多。 复杂度 $O(E\\log{E}\\log{\\max{w_i}})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 50000 + 5;const int MAXM = 100000 + 5;struct Edge {int u, v, val, col;bool operator &lt; (const Edge &amp;x) const { return val == x.val ? col &lt; x.col : val &lt; x.val;}} E[MAXM];int N, M, Q;int Anc[MAXN], Rnk[MAXN];void init() {rep(i, 0, N) { Anc[i] = i; Rnk[i] = 1;}}int findAnc(int x) {return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) {x = findAnc(x), y = findAnc(y);if(x == y) { return false;}if(Rnk[x] &lt; Rnk[y]) { Anc[x] = y;} else { Anc[y] = x; if(Rnk[x] == Rnk[y]) { ++Rnk[x]; }}return true;}pii Kruskal(int x) {init();rep(i, 0, M) { if(!E[i].col) { E[i].val += x; }}std::sort(E, E + M);int sum = 0, cnt = 1, num = 0;rep(i, 0, M) { if(merge(E[i].u, E[i].v)) { sum += E[i].val; if(!E[i].col) { ++num; } if(++cnt == N) { break; } }}rep(i, 0, M) { if(!E[i].col) { E[i].val -= x; }}return std::make_pair(num, sum - x * Q);}int main() {int u, v, w, c;int l, r = 0, ans = 0;scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;Q);rep(i, 0, M) { scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;w, &amp;c); E[i] = (Edge) {u, v, w, c}; r = std::max(r, w + 1);}l = -r;while(l &lt; r) { int m = (l + r) &gt;&gt; 1; pii x = Kruskal(m); if(x.first &gt;= Q) { ans = x.second; l = m + 1; } else { r = m; }}printf(\"%d\\n\", ans);return 0;}","link":"/BZOJ-2654/"},{"title":"「HNOI 2012」BZOJ 2733 永无乡","text":"$N$ 个点分别有权值 $W_i$ ，其中有$M$ 条无向边使其分成若干个联通分量。 现有 $Q$ 次操作，分为两类： 查询点$x$ 所在的联通分量中，权值第 $k$ 小的节点编号 合并点 $x,y$ 所在的联通分量 $M\\leq N\\leq 100000,Q\\leq 300000$ 分析动态查询第 $k$ 大，考虑用Treap，Splay等数据结构来维护。 那么如何合并两棵平衡树？通过启发式合并。 说是启发式合并，不过就是暴力合并，把两棵树中较小的一棵的所有节点拆下来插入到较大的那棵中，复杂度 $O(N\\log{N})$。 总复杂度分析，每个点至多被合并 $N$ 次，但是复杂度显然不是 $O(N^2\\log{N})$，其实不大会算… 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;struct Treap { int key, fix, belong, sz; Treap *ch[2]; Treap() { key = INT_MAX, fix = rand(); belong = -1, sz = 1; ch[0] = ch[1] = NULL; } Treap(int x, int y){ key = x, fix = rand(); belong = y, sz = 1; ch[0] = ch[1] = NULL; } int cmp(int x) { return key &lt;= x; } void pushUp() { sz = 1; if(ch[0]) { sz += ch[0]-&gt;sz; } if(ch[1]) { sz += ch[1]-&gt;sz; } }} T[MAXN &lt;&lt; 2];int Belong[MAXN];int cntT;std::vector&lt;Treap*&gt; R;Treap* newTreap(std::pair&lt;int, int&gt; x) { T[++cntT] = Treap(x.first, x.second); return &amp;T[cntT];}void rotate(Treap* &amp;t, int d) { Treap *k = t-&gt;ch[d ^ 1]; t-&gt;ch[d ^ 1] = k-&gt;ch[d]; k-&gt;ch[d] = t; t-&gt;pushUp(); k-&gt;pushUp(); t = k;}void insert(Treap* &amp;t, std::pair&lt;int, int&gt; x) { if(!t) { t = newTreap(x); return ; } int d = t-&gt;cmp(x.first); ++t-&gt;sz; insert(t-&gt;ch[d], x); if(t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix) { rotate(t, d ^ 1); }}int queryKth(Treap* &amp;t, int k) { int num = t-&gt;ch[0] ? t-&gt;ch[0]-&gt;sz : 0; if (k == num + 1) { return t-&gt;belong; } else if(k &lt;= num) { return queryKth(t-&gt;ch[0], k); } else { return queryKth(t-&gt;ch[1], k - num - 1); }}void merge(Treap* &amp;t, Treap* &amp;k, int rt) { if(t-&gt;ch[0]) { merge(t-&gt;ch[0], k, rt); } if(t-&gt;ch[1]) { merge(t-&gt;ch[1], k, rt); } if(t-&gt;belong != -1) { Belong[t-&gt;belong] = rt; insert(k, std::make_pair(t-&gt;key, t-&gt;belong)); }}void mergeTree(int x, int y) { int bx = Belong[x], by = Belong[y]; if(bx != by) { if(R[bx]-&gt;sz &gt; R[by]-&gt;sz) { merge(R[by], R[bx], bx); } else { merge(R[bx], R[by], by); } }}int query(int x, int k) { if(R[Belong[x]]-&gt;sz &lt;= k) { return -1; } return queryKth(R[Belong[x]], k);}int A[MAXN];int main() { int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { A[i] = io::gt&lt;int&gt;(); R.push_back(new Treap); insert(R.back(), std::make_pair(A[i], i)); Belong[i] = SZ(R) - 1; } while(M--) { int x = io::gt&lt;int&gt;(), y = io::gt&lt;int&gt;(); mergeTree(x, y); } int Q = io::gt&lt;int&gt;(); while(Q--) { char opt = io::gc(); while(!isalpha(opt)) { opt = io::gc(); } if(opt == 'Q') { int x = io::gt&lt;int&gt;(), k = io::gt&lt;int&gt;(); io::pt(query(x, k)); } else { mergeTree(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } } io::flush(); return 0;}","link":"/BZOJ-2733/"},{"title":"BZOJ 3031 理科男","text":"求 $\\frac{A}{B}$ 在 $K$ 进制下的混循环位数以及循环节长度。 $A,B,K\\leq 10^{12}$ 分析根据小学奥数的相关知识，如果一个混循环小数的混循环部分长度为 $M$ ，循环节长度为 $N$ ，那么转化成分数，分母为 $10^M(10^N-1)$ 。 这是在十进制下的情况，在 $K$ 进制下分母为 $K^M(K^N-1)$ 。 那么 $\\frac{A}{B}=\\frac{C}{K^M(K^N-1)}$ ，那么 $B$ 可以写成$K^M(K^N-1)_ A/C = a_1^{p_1}_ \\cdots_a_n^{p_n}_ x$ ，而 $K=a_1^{q_1}\\cdots_a_n^{q_m}$ ，一定存在某个$i$ 满足 $p_i=M\\times q_i$ 。 那么每次使 $B = B / (B, K)$ ，直到 $(B,K)=1$ ，进行的次数为$max{\\lceil p_i/q_i\\rceil}=M$ ，即为混循环小数的位数。 那么剩下的问题就是如何求 $N$ 。 令 $a_i$ 为第 $i-1$ 次除 $B$ 的余数，则 $a_1=A$ ；设 $r_i$ 为第 $i$ 位小数。 由于求 $N$ 时的终止条件为 $(B,K)=1$ ，也就是说新的 $A / B$ 在 $K$ 进制下一定是个纯循环小数。 根据模运算的周期性，当 $r_1=r_p$ 时， $r[1,p-1]$ 就构成了循环节，其长度为 $p$ 。 若 $r_1=r_p$ 则一定存在 $a_1=a_p$。由于$a_i=a_{i-1}_ K\\bmod B$， 因此 $a_p=a_1_K^p\\bmod B$ 。 而 $a_1\\equiv a_p\\pmod{B}$ ，代入得 $a_1\\equiv a_1\\times K^P\\pmod{B}$ ，即 $K^p\\equiv 1\\pmod{B}$ 。 $N$ 转化为求 $K$ 模 $B$ 的阶的问题。 根据欧拉定理， $K^{\\varphi(B)}\\equiv 1\\pmod{B}$ ，即 $\\varphi(B)$ 一定为循环节的长度，但是不一定为循环节的最短长度。 若对 $B$ 分解质因数得 $B=\\prod{a_i^{p_i}}$ ，则 $\\varphi(B)=\\prod{(1-\\frac{1}{a_i})}$ ，通过试除法或者Pollard-Rho+Miller-Rabin分解质因数可以求得。 那么最短循环节的长度一定为 $\\varphi(B)$ 的因数，Pollard-Rho+Miller-Rabin分解质因数后，依次通过快速幂检验 $K^{\\frac{\\varphi{B}}{a}}\\equiv 1\\pmod{B}$ 是否成立，即可求得长度的最小值。 复杂度分析通过gcd求混循环节长度的复杂度为 $O(\\log{B})$ ，Pollard-Rho+Miller-Rabin的复杂度为 $O(B^{\\frac{1}{4}})$ ，快速幂复杂度为 $O(\\log{\\varphi(B)})$ ，因此复杂度为 $O(\\log{B}+B^{\\frac{1}{4}}+\\log^2{\\varphi(B)})$ ，即 $O(B^{\\frac{1}{4}})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }ll mul(ll x, ll t, ll p) { ll res = 0; for (; t; t &gt;&gt;= 1) { if (t &amp; 1) { res = (res + x) % p; } x = (x + x) % p; } return res;}ll pow(ll x, ll t, ll p) { ll res = 1; for (; t; t &gt;&gt;= 1) { if (t &amp; 1) { res = mul(res, x, p); } x = mul(x, x, p); } return res;}bool Miller_Rabin(ll x) { static ll Prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41}; if (x == 2 || x == 3) { return true; } if (x &lt; 2 || (x % 6 != 1 &amp;&amp; x % 6 != 5)) { return false; } ll s = x - 1; while (!(s &amp; 1)) { s &gt;&gt;= 1; } rep(i, 0, 13) { if (x == Prime[i]) { return true; } ll t = s, m = pow(Prime[i], s, x); while (t != x - 1 &amp;&amp; m != 1 &amp;&amp; m != x - 1) { m = mul(m, m, x); t &lt;&lt;= 1; } if (!(t &amp; 1) &amp;&amp; m != x - 1) { return false; } } return true;}ll Factor[1000];int cntP;ll gcd(ll a, ll b) { while (b ^= a ^= b ^= a %= b); return a;}ll Pollard_Rho(ll n, ll c) { ll i = 1, k = 2; ll x = rand() % (n - 1) + 1, y = x; while (1) { i++; x = (mul(x, x, n) + c) % n; ll d = gcd(((y - x) + n) % n, n) % n; if (d &gt; 1 &amp;&amp; d &lt; n) { return d; } if (y == x) { return n; } if (i == k) { y = x; k &lt;&lt;= 1; } }}void findFac(ll n, ll c) { if (n == 1) { return; } if (Miller_Rabin(n)) { Factor[cntP++] = n; return; } ll p = n; while (p &gt;= n) { p = Pollard_Rho(n, c--); } findFac(n / p, c); findFac(p, c);}ll getPhi(ll x) { cntP = 0; findFac(x, 120); std::sort(Factor, Factor + cntP); cntP = std::unique(Factor, Factor + cntP) - Factor; double ans = x; rep(i, 0, cntP) { ans *= 1 - (1.0 / Factor[i]); } return ans;}ll cal(ll A, ll B) { ll x = getPhi(B), y = x; cntP = 0; findFac(x, 120); std::sort(Factor, Factor + cntP); cntP = std::unique(Factor, Factor + cntP) - Factor; rep(j, 0, cntP) { ll &amp;i = Factor[j]; while (y % i == 0 &amp;&amp; pow(A, y / i, B) == 1) { y /= i; } } return y;}int main() { ll A, B, K, T; scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld%lld%lld\", &amp;A, &amp;B, &amp;K); ll _gcd = gcd(A, B); A /= _gcd, B /= _gcd; int a = 0; while (true) { ll _gcd = gcd(B, K); if (_gcd == 1) { break; } B /= _gcd; ++a; } if (B == 1) { printf(\"%d %d\\n\", a, 0); } else { printf(\"%d %lld\\n\", a, cal(K, B)); } } return 0;}","link":"/BZOJ-3031/"},{"title":"BZOJ 3032 七夕祭","text":"$N\\times M$ 的黑白矩阵中某些格子是黑色的。每次可以交换相邻两个格子的颜色，尽可能使得行与行/列与列之间的黑色格子数量相同，如果可行 ，输出最少交换次数。 $1\\leq N, M\\leq 100000$ 。 分析首先如果 $T$ 不是 $N,M$ 的倍数，那么肯定不能均分，如此可以判断输出 both 还是什么其它的情况。 可以发现行与列颜色个数相同的要求是相互独立的，可以通过左右交互使得列相同，上下交换使得行相同。 令 $a_i$ 为第 $i$ 行已有的黑色格子个数， $x_i$ 为第 $i$ 行和第 $i+1$ 行交换的格子个数，那么能得到以下等式： $$ \\begin{equation}x_1=a_1+x_n-p\\ x_2=a_2+x_1-p\\ \\cdots\\ x_n=a_n+x_{n-1}-p\\\\end{equation} $$ 那么交换的总次数为 $\\sum{|x_i|}$ ，代入上式得 $\\sum{|x_i|}=\\sum|a_i+x_{i-1}-p|$ 。 再将 $x_i$ 的表达式代入 $x_{i+1}$ 可得： $$ \\begin{equation}x_1=a_1+x_n-p\\ x_2=a_2+(a_1+x_n-p)-p=a_1+a_2+x_n-2p\\ \\cdots\\ x_n=a_1+a_2+\\cdots+a_n+x_n-np\\end{equation} $$ 令 $s_i = \\sum\\limits_{j=1}^{i}{a_j}-ip$ ，即 ${a_i-p}$ 的前缀和，化简为 $\\sum{|x_i|}=|s_i+x_n|$ 。 根据绝对值不等式， $x_n$ 为 $s[1…n]$ 的中位数的相反数时，原式取最小值。 对于列同理。 具体即先统计每行/列的黑格子个数，前缀和后通过 std::nth_element() $O(N)$ 实现。 复杂度 $O(N)$ 。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 100000 + 5;ll N, M, Q;int Col[MAXN], Row[MAXN];ll cal(int A[], ll n) { static ll Num[MAXN]; ll num = Q / n, ans = 0; Num[0] = 0; rep(i, 1, n) { Num[i] = 1ll * Num[i - 1] + A[i] - num; } std::nth_element(Num + 1, Num + (n &gt;&gt; 1), Num + n); ll x = Num[n &gt;&gt; 1]; rep(i, 0, n) { ans += (ll)std::abs(x - Num[i]); } return ans;}ll cal() { ll sum = 0; if (Q % N == 0) { sum += cal(Row, N); } if (Q % M == 0) { sum += cal(Col, M); } return sum;}int main() { int x, y; scanf(\"%lld%lld%lld\", &amp;N, &amp;M, &amp;Q); rep(i, 0, Q) { scanf(\"%d%d\", &amp;x, &amp;y); ++Row[x]; ++Col[y]; } if (Q % N != 0 &amp;&amp; Q % M != 0) { puts(\"impossible\"); return 0; } if (Q % N == 0 &amp;&amp; Q % M == 0) { printf(\"both \"); } else if (Q % N == 0) { printf(\"row \"); } else { printf(\"column \"); } printf(\"%lld\\n\", cal()); return 0;}","link":"/BZOJ-3032/"},{"title":"BZOJ 3156 防御准备","text":"每个点 $i$ 要么花费 $a_i$ 建塔，要么花费 $j-i$ （$j$ 为 $i$ 右边第一个塔的标号）。点 $n$ 必须建塔，求最小总花费。 $n\\leq 10^6,a_i\\leq 10^9$ 分析将点左右翻转，点 $1$ 必须建塔，则转移方程为 $f_i=a_i+\\min\\limits_{j &lt; i}{(f_j+(i-j)\\cdot (i-j-1)/2)}$ 若决策点 $j$ 优于决策点 $k(j &lt; k)$，需满足 $\\frac{2(f_k-f_j)+k(k+1)-j(j+1)}{2(k-j)} &gt; i$。 维护决策点队列斜率单调递增，且斜率 $&gt;i$。 复杂度 $O(n)$。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940/* * @Author: Skqliao * @Source: BZOJ * @Problem: 3156: 防御准备 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=3156 * @Date: 2019-02-26 21:32:07 * @LastEditTime: 2019-02-27 20:02:09 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1e6 + 5;int N;long long A[MAXN], S[MAXN], F[MAXN];int Que[MAXN], qh, qt;double slope(int j, int k) { return (double)(2 * (F[k] - F[j]) + (long long)k * (k + 1) - (long long)j * (j + 1)) / (2 * (k - j));}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%lld\", &amp;A[i]); } std::reverse(A + 1, A + N + 1); F[1] = A[1]; Que[0] = 1; long long ans = LLONG_MAX; for (int i = 2; i &lt;= N; ++i) { while (qh &lt; qt &amp;&amp; slope(Que[qh], Que[qh + 1]) &lt;= i) ++qh; int j = Que[qh]; F[i] = F[j] + (long long)(i - j) * (i - j - 1) / 2 + A[i]; while (qh &lt; qt &amp;&amp; slope(Que[qt - 1], Que[qt]) &gt;= slope(Que[qt], i)) --qt; Que[++qt] = i; ans = std::min(ans, F[i] + (long long)(N - i) * (N - i + 1) / 2); } printf(\"%lld\\n\", ans); return 0;}","link":"/BZOJ-3156/"},{"title":"BZOJ 3211 花神游历各国","text":"维护一个序列，支持区间开方（向下取整）和区间求和。 序列长为 $N$，共 $M$ 次操作。 $1\\leq N.M\\leq 100000 $，序列中元素 $0\\leq A_i\\leq 10^{12}$ 。 分析区间开方并不满足区间加法，所以只能每个数暴力开方。 由于开方是向下取整，因此对于 $1$ 和 $0$ 而言，开方后还是自己，对区间和没有产生影响。 而对于最大值 $10^{12}$ 而言，最多开 $5$ 次方就会变成 $1$ ，也就是说开方对一个数的影响最多只有 $5$ 次。 那么假如对于操作区间 $[l,r]$ 而言，其中的元素非 $0$ 即 $1$，那么这个区间就无需继续操作。 因此用线段树维护区间和，同时对无需继续操作的区间打标记。 每次区间开方的时候，如果两个子树都被打了标记，则无需继续；否则递归到单个元素进行开方，并检查是否成为 $0$ 和 $1$ ，对其打标记；如果两个子树都被打上标记，那么就将标记上移到父亲节点。 复杂度 $O(M\\log{N}\\log{\\log{W}})$ ，其中 $W$ 为元素最大值。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;struct SegmentTree {#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, r ll Sum[MAXN &lt;&lt; 2], Flag[MAXN &lt;&lt; 2]; void pushUp(int rt) { Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1]; Flag[rt] = Flag[rt &lt;&lt; 1] &amp; Flag[rt &lt;&lt; 1 | 1]; } void build(int rt, int l, int r) { if(l == r) { Sum[rt] = io::gt&lt;ll&gt;(); return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt); } void change(int rt, int l, int r, int a, int b) { if(Flag[rt]) { return ; } if(l == r) { Sum[rt] = sqrt(Sum[rt]); if(Sum[rt] == 1 || Sum[rt] == 0) { Flag[rt] = 1; } return ; } int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { change(LT, a, b); } if(m &lt; b) { change(RT, a, b); } pushUp(rt); } ll querySum(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Sum[rt]; } int m = (l + r) &gt;&gt; 1; ll res = 0; if(a &lt;= m) { res += querySum(LT, a, b); } if(m &lt; b) { res += querySum(RT, a, b); } return res; }} T;int main() { int N = io::gt&lt;int&gt;(); T.build(1, 1, N); int M = io::gt&lt;int&gt;(); while(M--) { int opt = io::gt&lt;int&gt;(); int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(); if(opt == 2) { T.change(1, 1, N, l, r); } else { printf(\"%lld\\n\", T.querySum(1, 1, N, l, r)); } } return 0;}","link":"/BZOJ-3211/"},{"title":"「HEOI 2013」BZOJ 3166 Alo","text":"给定长为 $N$ 的序列 $A[1 \\cdots N]$，定义 $F[i,j]$ 为$A[i \\cdots j]$ 的次大值与区间内另一个数异或的最大值。求 $A$ 所有子区间的 $F$ 最大值。 $1\\leq N\\leq 50000, A_i\\leq 10^9$ 分析将问题反过来看，其实就是找到每一个数对应的区间，使得它在区间中是次大值，且区间长度最大。 记$L[i],R[i]$ 为 $A[i]$ 左右第一个比它大的数， $LL[i],RR[i]$ 为 $A[i]$ 左右第二个大的数，那么区间为 $[LL[i]+1,R[i]-1]$ 和 $[L[i]+1,RR[i]-1]$。 可以通过在ST表上二分的方法求出 $LL[i],RR[i]$，复杂度 $O(N\\log{N})$。 最后用可持久化Trie求每个区间与 $A[i]$ 的最大异或值，答案为这些值取max，这一步操作的复杂度为 $O(N\\log{max(A_i)})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;const int MAXN = 50000 + 5;const int MAXM = 40;struct Trie { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], cntT;int insert(int pre, int x) { int rt = ++cntT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++cntT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int N, A[MAXN];int L[MAXN], R[MAXN];int Stk[MAXN], top;int LL[MAXN], RR[MAXN];int bSearch(int x) { int l = 1, r = top; int ans = 0; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (A[Stk[m]] &gt; A[x]) { ans = Stk[m]; l = m + 1; } else { r = m - 1; } } return ans;}int F[MAXN][MAXM];void buildST(int n) { for (int i = 1; i &lt;= n; ++i) { F[i][0] = A[i]; } int k = log2(n); for (int j = 1; j &lt;= k; ++j) { for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) { if (F[i][j - 1] &gt; F[i + (1 &lt;&lt; (j - 1))][j - 1]) { F[i][j] = F[i][j - 1]; } else { F[i][j] = F[i + (1 &lt;&lt; (j - 1))][j - 1]; } } }}int queryMax(int l, int r) { int k = log2(r - l + 1); return std::max(F[l][k], F[r - (1 &lt;&lt; k) + 1][k]);}int getL(int i) { int p = L[i], x = A[i]; int l = 1, r = p - 1, ans = 1; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (queryMax(m, p - 1) &gt; x) { ans = m; l = m + 1; } else { r = m - 1; } } return ans;}int getR(int i) { int p = R[i], x = A[i]; int l = p + 1, r = N + 1, ans = N + 1; while (l &lt;= r) { int m = (l + r) &gt;&gt; 1; if (queryMax(p + 1, m) &gt; x) { ans = m; r = m - 1; } else { l = m + 1; } } return ans;}int main() { scanf(\"%d\", &amp;N); Rt[1] = insert(Rt[0], 0); ++N; for (int i = 2; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); Rt[i] = insert(Rt[i - 1], A[i]); } A[1] = A[N + 1] = INT_MAX; Stk[top = 1] = 1; for (int i = 2; i &lt;= N; ++i) { while (A[Stk[top]] &lt;= A[i]) { --top; } L[i] = Stk[top]; Stk[++top] = i; } Stk[top = 1] = N + 1; for (int i = N; i &gt;= 2; --i) { while (A[Stk[top]] &lt;= A[i]) { --top; } R[i] = Stk[top]; Stk[++top] = i; } buildST(N + 1); for (int i = 2; i &lt;= N; ++i) { LL[i] = getL(i); RR[i] = getR(i); } int ans = 0; for (int i = 2; i &lt;= N; ++i) { if (L[i] == 1 &amp;&amp; R[i] == N + 1) { continue; } ans = std::max(ans, query(Rt[LL[i]], Rt[R[i] - 1], A[i])); ans = std::max(ans, query(Rt[L[i]], Rt[RR[i] - 1], A[i])); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-3166/"},{"title":"BZOJ 3261 最大异或和","text":"开始给定一个长为 $N$ 的序列 $A[1\\cdots N]$，有 $M$ 个操作。在 $A$ 的末尾插入 $x$；或者给定 $x,l,r$，查询 $max(x\\oplus A[p]\\oplus\\cdots\\oplus A[N])$，其中$p\\in[l,r]$，$N$为当前序列长度。 $N\\leq 300000,A[i]\\leq 10^7$ 分析维护前缀异或和，令$S[i]=A[1]\\oplus\\dots\\oplus A[i]$，问题转化为查询 $S[N]\\oplus S[p-1]\\oplus x$ 的最大值，其中 $S[N]$ 和 $x$ 都是已知的。 由于是区间问题，可以用可持久化Trie树维护。对于每个新插入的数在01Trie树新建一条链，并将链上所有点的状态+1。通过权值相减来判断区间内是否存在该点，剩下的就是常规01Tire树求异或最大值的操作。 需要注意的一个细节，由于存在插入操作，因此序列中的元素个数最大可能为 $N+M$，需要开两倍空间。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;const int MAXN = 600000 + 5;const int MAXM = 50;struct Node { int sz; int ch[2];} T[MAXN * MAXM];int Rt[MAXN], cntT;int N, M;int insert(int pre, int x) { int rt = ++cntT, tmp = rt; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; T[rt].sz = T[pre].sz + 1; T[rt].ch[c] = ++cntT; T[rt].ch[c ^ 1] = T[pre].ch[c ^ 1]; rt = T[rt].ch[c]; pre = T[pre].ch[c]; } T[rt].sz = T[pre].sz + 1; return tmp;}int query(int u, int v, int x) { int ans = 0; for (int i = 31; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (T[T[v].ch[c ^ 1]].sz - T[T[u].ch[c ^ 1]].sz) { ans += (1 &lt;&lt; i); v = T[v].ch[c ^ 1], u = T[u].ch[c ^ 1]; } else { v = T[v].ch[c], u = T[u].ch[c]; } } return ans;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); int cur = 0, x, l, r; char opt[10]; ++N; Rt[1] = insert(Rt[0], 0); for (int i = 2; i &lt;= N; ++i) { scanf(\"%d\", &amp;x); cur ^= x; Rt[i] = insert(Rt[i - 1], cur); } for (int i = 1; i &lt;= M; ++i) { scanf(\"%s\", opt); if (opt[0] == 'A') { scanf(\"%d\", &amp;x); cur ^= x; ++N; Rt[N] = insert(Rt[N - 1], cur); } else { scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); printf(\"%d\\n\", query(Rt[l - 1], Rt[r], x ^ cur)); } } return 0;}","link":"/BZOJ-3261/"},{"title":"BZOJ 3436 小 K 的农场","text":"有若干组关系，形如 $A_i - A_j \\leq x, \\geq x, = x$。 求 $A[1 \\cdots N]$ 是否能满足所有关系。 分析将三种形式转化成不等式的形式，即： $a - b \\leq c$ $a-b \\geq c$ $a = b$ 要求这个不等式组是否有解。 通过查分约束，转换成图上问题。 根据三角不等式 $d_u + d(u,v)\\geq d_v$，转化一下即 $d_u - d_v \\geq d(u,v)$ 。 那么按照如下方法建图： $a - b\\leq c$ ，即 $d(b,a) = c$ $a-b \\geq c$ ，即 $d(a,b) = -c$ $a=b$ ，即 $d(a,b)=d(b,a)=0$ 。其中 $d(u,v)$ 表示 $u$ 到 $v$ 的有向边的距离。 无解的条件即图中出现负环。 通过 SPFA算法， 如果一个点入队 $n$ 次说明存在负环。 复杂度上界 $O(nm)$ ，实际数据很弱。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;#define ONLINE_JUDGEnamespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace iovoid open() { freopen(\"farm.in\", \"r\", stdin); freopen(\"farm.out\", \"w\", stdout);}const int MAXN = 10000 + 5;struct Edge { int v, w, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}int N, M;int Dis[MAXN], Cnt[MAXN], Inq[MAXN];bool spfa(int n) { static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; rep(i, 0, n) { Inq[i] = true; Que.push(i); } while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; if (!Inq[v]) { Que.push(v); Inq[v] = true; if (++Cnt[v] &gt; n) { return true; } } } } } return false;}int main() { //open(); int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); while (M--) { int opt = io::gt&lt;int&gt;(); int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); if (opt == 1) { addEdge(u, v, -io::gt&lt;int&gt;()); } else if (opt == 2) { addEdge(v, u, io::gt&lt;int&gt;()); } else { addEdge(u, v, 0); } } rep(i, 0, N + 1) { addEdge(0, i, 0); } if (spfa(N + 1)) { puts(\"No\"); } else { puts(\"Yes\"); } return 0;}","link":"/BZOJ-3436/"},{"title":"「SCOI 2014」BZOJ 3597 方伯伯运椰子","text":"在有向无环图 $G$ 中，每条边的流量与容量相等。现可以修改每条边的容量，使得新的边依然满足流量与容量相等，且总流量不变。已知扩展/缩小每条边容量的单位花费，以及流量通过该边的单位花费。记原总花费 $X$，现在总花费 $Y$（包括修改容量和流量的花费），修改了 $K$ 条边的容量，则收益为 $w=(X-Y)/K$，求$w$的最大值。 $N\\leq 5000$ 分析这道题的核心在于理解“总流量不变且每条边跑满”，可以用网络流的模型理解。 所谓扩容即增广，花费为扩容费用+流量费用；压缩即退流，花费为压缩费用-流量费用。 假设 $a\\geq(X-Y)/K$，则 $Y-X+a\\cdot K\\geq 0$。 而 $Y-X$ 就是增广和退流的费用之和，$K$ 可以分摊到每条边上，即让每条边的权值增加 $K$。 $a$ 显然是可以二分的，那么若新图出现负环，则说明 $a$ 的值不够大，直到得到解为止。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;const int MAXN = 5000 + 5;const double INF = 1e9;const double eps = 1e-4;int N, M;struct Edge { int v; double w; int nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE;}double Dis[MAXN];bool Vis[MAXN];bool dfs_spfa(int x, double xx) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; double dis = Dis[x] + E[i].w + xx; if (Dis[v] &gt; dis) { Dis[v] = dis; if (Vis[v] || dfs_spfa(v, xx)) { return true; } } } return Vis[x] = 0;}bool check(double a) { for (int i = 1; i &lt;= N; ++i) { Dis[i] = INF; } Dis[N - 1] = 0; memset(Vis, 0, sizeof Vis); for (int i = 1; i &lt;= N; ++i) { if (dfs_spfa(i, a)) { return true; } } return false;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); N += 2; int a, b, c, d, u, v; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d%d%d%d\", &amp;u, &amp;v, &amp;a, &amp;b, &amp;c, &amp;d); if (u == N - 1) { continue; } if (c) { addEdge(v, u, a - d); } addEdge(u, v, b + d); } double l = 0, r = INF, ans; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { ans = l = m; } else { r = m; } } printf(\"%.2lf\\n\", ans); return 0;}","link":"/BZOJ-3597/"},{"title":"「LNOI 2014」BZOJ 3626 LCA","text":"给定一棵 $N$ 个节点的有根树，有 $M$ 组询问。每组询问给定 $l, r, z$，查询 $\\sum\\limits_{l\\leq i\\leq r}{depth(lca(i, z))}$ 。 $N,M\\leq 50000$ 。 分析约定： $u\\rightarrow v$ 指的是 $u$ 到 $v$ 路径上的所有点，默认根节点为 $1$ 。 由于只是求 $lca(u,v)$ 的深度，因此将 $u\\rightarrow 1$ 上的所有节点权值 $+1$ ，那么答案应该是 $v\\rightarrow 1$ 上节点的权值和。（因为 $v\\rightarrow 1$ 上所有有权值的点都在 $lca(u,v) \\rightarrow 1$ 上） 那么假设求 $\\sum{depth(lca(u_i,v))}$ ，同理可以分别将 $u_i\\rightarrow 1$ 上所有点权值 $+1$ ，最后统计 $v\\rightarrow 1$ 上的权值和。 实现起来很简单，树链剖分+线段树，复杂度 $O(m\\log^2{n})$ ，其中 $m$ 为组数， $n$ 为节点数。 假如把 $v$ 换成 $z$ ，其实只需要将最后统计的链从 $v\\rightarrow 1$ 改成了 $z\\rightarrow 1$，对前面 $+1$ 的操作没有影响，单次只是 $O(\\log^2{n})$ 的复杂度。 那么再看这道题的询问 $\\sum\\limits_{l\\leq i\\leq r}{depth(lca(i, z))}$ ，可以发现与上面的式子是类似的。 由于每次都是 $[l_i,r_i]$ 这样一个连续区间，将它差分成 $[1,r_i]-[1,l_i-1]$ 。 那么如果节点编号按从 $1\\cdots n$ 的顺序进行 $+1$ 的操作， $+1$ 后计算 $u_i\\rightarrow 1$ 的权值和。 所有查询的区间差分后得到的 $[1,r_i]$ 和 $[1,l_i-1]$ 都能算出来，而且所有点只操作（增加）了一次，如此复杂度是可以接受的。 那么把所有查询都分别挂在节点 $l_i-1$ 和 $r_i$ 上，让 $i$ 从 $1$ 开始按顺序对 $i\\rightarrow 1$ 进行 $+1$ 操作。 $+1$ 之后处理所有挂在上面的询问。分别 $u_i\\rightarrow 1$ 的权值和，若 $i$ 是左区间则减，反之则加。 复杂度 $O(N+M\\log^2{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 50000 + 5;const int MOD = 201314;struct Edge { int v, nxt;} E[MAXN];int N, M;int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE;}int Fa[MAXN], Son[MAXN], Sz[MAXN];int Top[MAXN], Dfn[MAXN], cntD;void dfs(int x) { Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { dfs(v); Sz[x] += Sz[v]; if (Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } }}void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; if (Son[x]) { dfs2(Son[x], top); } for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x] &amp;&amp; v != Son[x]) { dfs2(v, v); } }}#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Sum[MAXN &lt;&lt; 2], Add[MAXN &lt;&lt; 2];void inc(int &amp;x, int y) { (x += y) %= MOD; if (x &lt; 0) { x += MOD; }}void pushUp(int rt) { inc(Sum[rt] = 0, Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1]);}void pushDown(int rt, int L) { int &amp;add = Add[rt]; if (add) { inc(Add[rt &lt;&lt; 1], add); inc(Add[rt &lt;&lt; 1 | 1], add); inc(Sum[rt &lt;&lt; 1], add * (L - (L &gt;&gt; 1))); inc(Sum[rt &lt;&lt; 1 | 1], add * (L &gt;&gt; 1)); add = 0; }}void add(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { inc(Sum[rt], r - l + 1); inc(Add[rt], 1); return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { add(LT, a, b); } if (m &lt; b) { add(RT, a, b); } pushUp(rt);}int querySum(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return Sum[rt]; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; int res = 0; if (a &lt;= m) { inc(res, querySum(LT, a, b)); } if (m &lt; b) { inc(res, querySum(RT, a, b)); } return res;}void modify(int u) { while (u) { add(1, 1, N, Dfn[Top[u]], Dfn[u]); u = Fa[Top[u]]; }}int query(int u) { int res = 0; while (u) { inc(res, querySum(1, 1, N, Dfn[Top[u]], Dfn[u])); u = Fa[Top[u]]; } return res;}std::vector&lt;int&gt; L[MAXN], R[MAXN];int Ask[MAXN], Ans[MAXN];int main() { int l, r; scanf(\"%d%d\", &amp;N, &amp;M); rep(i, 2, N + 1) { scanf(\"%d\", &amp;Fa[i]); addEdge(++Fa[i], i); } dfs(1); dfs2(1, 1); rep(i, 0, M) { scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;Ask[i]); L[l].push_back(i); R[r + 1].push_back(i); ++Ask[i]; } rep(i, 1, N + 1) { modify(i); rep(j, 0, SZ(R[i])) { inc(Ans[R[i][j]], query(Ask[R[i][j]])); } rep(j, 0, SZ(L[i])) { inc(Ans[L[i][j]], -query(Ask[L[i][j]])); } } rep(i, 0, M) { printf(\"%d\\n\", Ans[i]); } return 0;}","link":"/BZOJ-3626/"},{"title":"BZOJ 3437 小P的牧场","text":"每个点 $i$ 要么花费 $a_i$ 建塔，要么花费 $(j-i)\\cdot b_i$ （$j$ 为 $i$ 右边第一个塔的标号）。求最小总花费。 $n\\leq 10^6,0 &lt; a_i,b_i\\leq 10^5$ 分析设 $X_i=\\sum\\limits_{j=1}^{i-1}{B_j}$,$Y_i=\\sum\\limits_{j=1}^{i-1}{b_i\\cdot i}$，则转移方程为 $f_i=a_i+\\min\\limits_{j &lt; i}{(f_j+X_{i-1}-X_j-Y_{i-1}+Y_j)}$ 若决策点 $j$ 优于决策点 $k(j &lt; k)$，需满足 $\\frac{f_k-f_j+Y_k-Y_j}{X_k-X_j} &gt; i$。 维护决策点队列斜率单调递增，且斜率 $&gt;i$。 复杂度 $O(n)$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041/* * @Author: Skqliao * @Source: BZOJ * @Problem: 3437: 小P的牧场 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=3437 * @Date: 2019-02-27 20:22:08 * @LastEditTime: 2019-02-27 20:27:08 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1e6 + 5;int N;long long A[MAXN], B[MAXN];long long X[MAXN], Y[MAXN], F[MAXN];int Que[MAXN], qh, qt;double slope(int j, int k) { return (double) (F[k] - F[j] + Y[k] - Y[j]) / (X[k] - X[j]);}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%lld\", &amp;A[i]); } for (int i = 1; i &lt;= N; ++i) { scanf(\"%lld\", &amp;B[i]); X[i] = X[i - 1] + B[i]; Y[i] = Y[i - 1] + i * B[i]; } for (int i = 1; i &lt;= N; ++i) { while (qt &gt; qh &amp;&amp; slope(Que[qh], Que[qh + 1]) &lt;= i) ++qh; int j = Que[qh]; F[i] = F[j] + i * (X[i - 1] - X[j]) - (Y[i - 1] - Y[j]) + A[i]; while (qt &gt; qh &amp;&amp; slope(Que[qt - 1], Que[qt]) &gt;= slope(Que[qt], i)) --qt; Que[++qt] = i; } printf(\"%lld\\n\", F[N]); return 0;}","link":"/BZOJ-3437/"},{"title":"BZOJ 3033 太鼓达人","text":"给定字串长度 $K$ ，需要构造一个长度为 $M$ 的01串（环状），使得所有长度为 $K$ 的子串互不相同。求 $M$ 的最大值以及对应的字典序最小串。 $K\\leq 11$ 分析将 $k$ 位二进制都看成点，图中一共有 $2^k$ 个不同的点。 每一个点可以删去第一位并在最后填充 $0$ 或 $1$ 转移到其它点，所有所有点的出度入度都是 $2$ 。 这个有向图所有点出入度相等，因此存在欧拉回路，即这是一个欧拉图。 那么 $M$ 即在该图中的回路长度的最大值，根据欧拉回路的性质，$M=2^k$ 。 由于要求串的字典序最小，因此前 $k$ 位皆为 $0$ ，在此基础上爆搜即可得到整个串的排序。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Copyright (C) 2018 SNqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chNMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chNMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = (1 &lt;&lt; 11) + 5;int N, T;int Ans[MAXN];bool Vis[MAXN];bool dfs(int x, int y) { if(Vis[x]) { return false; } if(y == T) { return true; } Ans[y] = x &amp; 1; Vis[x] = 1; if(dfs((x &lt;&lt; 1) &amp; (T - 1), y + 1) || dfs((x &lt;&lt; 1 | 1) &amp; (T - 1), y + 1)) { return true; } Vis[x] = 0; return false;}int main() { scanf(\"%d\", &amp;N); T = 1 &lt;&lt; N; printf(\"%d \", T); dfs(0, 1); rep(i, 1, N) { printf(\"0\"); } rep(i, 1, T - N + 2) { printf(\"%d\", Ans[i]); } return 0;}","link":"/BZOJ-3033/"},{"title":"「PA 2014」BZOJ 3714 Kuglarz","text":"一排 $N$ 个杯子中某些杯子里有小球。可以花费 $C_{l,r}$ 来获取 $[l,r]$ 中小球总数的奇偶性，求得知每个杯子小球状态的最小花费。 $N\\leq 2000$。 分析首先注意到花费的数据范围是 $10^9$ ，因此可能会爆int，需要使用long long。 由于区间球总数的奇偶性满足区间加减法，即 $[l,r] = [1,r]-[1,l-1]$ ，若已知 $[1,l]$ 和 $[1,l+1]$ 那么就能得到杯子 $l$ 是否有球。 那么如果想知道每个杯子下面是否有球，最少需要购买 $n$ 次，即 $[1,1],[2,2],…[n,n]$ ，可以证明这是购买次数的下界。 那么把杯子抽象成点，购买关系抽象成边，由于奇偶性满足区间减法/加法，因此让$[l+1,r]$ 区间转化为边 $i\\rightarrow j$ ，边权为花费。 如此路径 $i\\rightarrow j\\rightarrow k$ 即 $[i+1,j],[j+1,k]$ ，合并即可知道 $[i+1,k]$ 的奇偶性。也就是说在同一个联通分量的两个点 $l,r$ ，我们可以通过它们之间的路径得到 $[l+1,r]$ 的奇偶性。 易得图中出现环显然是不优的，那么考虑生成树（生成森林）。 由于可以购买任意 $[l,r]$ 的奇偶性，也就是说生成树可以得到任意 $[l,r]$ 的奇偶性，也就能得到任意一个杯子是否有球在下面。 而构造新图中同时构造了一个新点 $0$ （通过 $[1,x]$ 得到 $0\\rightarrow x$） ，所以新图的生成树是 $n$ 条边，符合之前的推论。 如此求得新图的最小生成树的权值和即为最小花费。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 2000 + 5;struct Edge { int u, v, w; bool operator &lt; (const Edge &amp;x) const { return w &lt; x.w; }} E[MAXN * MAXN];int N, cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w};}int Anc[MAXN], Rnk[MAXN];void init() { rep(i, 0, N + 1) { Anc[i] = i; Rnk[i] = 1; }}int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) { x = findAnc(x), y = findAnc(y); if(x == y) { return false; } if(Rnk[x] &lt; Rnk[y]) { Anc[x] = y; } else { Anc[y] = x; if(Rnk[x] == Rnk[y]) { ++Rnk[x]; } } return true;}ll Kruskal() { init(); std::sort(E + 1, E + cntE + 1); ll sum = 0; int cnt = -1; rep(i, 1, cntE + 1) { if(merge(E[i].u, E[i].v)) { sum += E[i].w; if(++cnt == N) { break; } } } return sum;}int main() { int w; scanf(\"%d\", &amp;N); rep(i, 1, N + 1) { rep(j, i, N + 1) { scanf(\"%d\", &amp;w); addEdge(i - 1, j, w); } } printf(\"%lld\\n\", Kruskal()); return 0;}","link":"/BZOJ-3714/"},{"title":"「湖南省队训练 2013」BZOJ 3894 文理分科","text":"在 $n\\times m$ 的矩阵中，每个格子可以选择 $0$ 或 $1$，分别获得收益 $A_{i,j}$ 与 $B_{i,j}$。如果一个格子和与它四相邻的格子选择相同，则额外获得收益 $C_{i,j}$ 与 $D_{i,j}$（都选 $0$ 或都选 $1$）。求总收益的最大值。 $n,m\\leq 100,A_{i,j},B_{i,j},C_{i,j},D_{i,j}\\leq 500$ 分析还是二元关系的题目，相比于happiness要复杂一些。 照旧将最大值转化为所有收益-最小割。 建图方法如下： 对于每个点 $x$，割去 $(S,x)$ 表示不选文科，割去 $(x,T)$ 表示不选理科，容量为 $A_x$ 和 $B_x$。 新建点 $a_x,b_x$，表示 $x$ 以及四相邻的点均选择 $0$ 或 $1$。连接 $(S,a_x)$ 和 $(b_x,T)$，容量分别为 $C_x$ 和 $D_x$。 但是可能会出现不合法的情况，即相邻点选择理科，但是又割去 $(b_x,T)$。因此让 $a_x$ 向这五个点（ $x$ 与相邻的四个点）连接一条容量为无穷的边。这就使在这种情况下 $(b_x,T)$ 无法被割去（因为割会经过一条容量为无穷的边，这样的割显然不是最小割）。 同理，让这五个点向 $b_x$ 连接一条容量为无穷的边。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * @Author: Skqliao * @Date: 2019-02-11 22:29:59 * @LastEditTime: 2019-02-11 22:56:26 * @Source: 2013湖南省队集训 * @Problem: 3894: 文理分科 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=3894 */#include &lt;bits/stdc++.h&gt;namespace mxf {const int MAXN = 3 * 100 * 100 + 10;const int MAXM = MAXN * 5;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int S, T;int Cur[MAXN], Dis[MAXN];void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, 0, H[v]}; H[v] = cntE;}void init(int tot) { cntE = -1; memset(H, -1, sizeof H); S = tot + 1, T = tot + 2;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(E[i].f, left)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; if (!left) return maxf; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow;}} // namespace mxfusing mxf::addEdge;using mxf::S;using mxf::T;const int MAXN = 100 + 5;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M;int ans;int Id[MAXN][MAXN];bool judge(int x, int y) { return x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= N &amp;&amp; y &lt;= M; }int main() { int x; scanf(\"%d%d\", &amp;N, &amp;M); mxf::init(N * M * 3); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { Id[i][j] = (i - 1) * M + j; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); ans += x; addEdge(S, Id[i][j], x); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); ans += x; addEdge(Id[i][j], T, x); } } int cur = N * M; for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); ans += x; addEdge(S, ++cur, x); addEdge(cur, Id[i][j], INT_MAX); for (int k = 0; k &lt; 4; ++k) { int x = i + Dicx[k]; int y = j + Dicy[k]; if (judge(x, y)) addEdge(cur, Id[x][y], INT_MAX); } } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= M; ++j) { scanf(\"%d\", &amp;x); ans += x; addEdge(++cur, T, x); addEdge(Id[i][j], cur, INT_MAX); for (int k = 0; k &lt; 4; ++k) { int x = i + Dicx[k]; int y = j + Dicy[k]; if (judge(x, y)) addEdge(Id[x][y], cur, INT_MAX); } } } printf(\"%d\\n\", ans - mxf::dinic()); return 0;}","link":"/BZOJ-3894/"},{"title":"「PA 2014」BZOJ 3712 Fiolki","text":"$N$ 个瓶子里起初各有 $G_i$ 克第 $i$ 种物质。共 $M$ 步操作，第 $i$ 步会将第 $A_i$ 瓶中物质全部倒入第 $B_i$ 瓶中。已知共有 $K$ 组反应，瓶中每一克 $C_i$ 和 $D_i$ 可以转化为两克沉淀，沉淀不再参与反应。瓶中物质若可以进行多种反应，按照反应出现的前后次序进行。求最后剩下多少沉淀。 $0\\leq M&lt; N\\leq 200000,0\\leq K\\leq 500000,1\\leq G_i \\leq 10^9$ 。 分析这种合并两个瓶子内物质的操作，可以用树形结构来表示。 将初始状态作为叶子节点，若将 $a$ 倒入 $b$ ，则建立一个新点 $x$ 作为 $a,b$ 的父亲，若再将 $b$ 倒入 $c$ ，则再建立新点 $y$ 作为 $x,c$ 的父亲，依次类推，将 $a$ 倒入 $b$ 转化为建立新点作为 $a,b$ 祖先的父亲。 那么会形成一个森林，而根据瓶中物质的初始状态，易得物质 $x,y$ 反应只会出现在节点 $lca(x,y)$ 处。 那么剩下需要处理的就是反应顺序的问题了。 根据建图的方法，若 $depth(x) &lt; depth(y)$ ，则 $x$ 一定先于 $y$ 发生，或者 $x,y$ 中的物质交集为空；如果 $depth(x)=depth(y)$ ，则根据给定顺序进行反应。如此就确定了所有反应发生的顺序。 用倍增求LCA，根据 $depth(lca(C_i,D_i))$ 排序，复杂度 $O(N\\log{N}+K\\log{K})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = (200000 + 5) &lt;&lt; 1;const int MAXK = 500000 + 5;int N, M, K;int G[MAXN];struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE;}int Anc[MAXN];int Depth[MAXN];int Fa[20][MAXN];void dfs(int x, int fa) { Depth[x] = Depth[fa] + 1; Fa[0][x] = fa; rep(i, 1, 20) { Fa[i][x] = Fa[i - 1][Fa[i - 1][x]]; } for(int i = H[x]; i; i = E[i].nxt) { dfs(E[i].v, x); }}int queryLCA(int u, int v) { if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } rep(i, 0, 20) { if((Depth[v] - Depth[u]) &gt;&gt; i &amp; 1) { v = Fa[i][v]; } } if(u == v) { return v; } rof(i, 20, 0) { if(Fa[i][v] != Fa[i][u]) { u = Fa[i][u]; v = Fa[i][v]; } } return Fa[0][u];}struct Node { int u, v, dep, ord; bool operator &lt; (const Node &amp;x) const { return dep == x.dep ? ord &lt; x.ord : dep &gt; x.dep; }} P[MAXK];int main() { int u, v; scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;K); rep(i, 1, N + 1) { scanf(\"%d\", &amp;G[i]); Anc[i] = i; } int cntP = N + 1; rep(i, 1, M + 1) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(N + i, Anc[u]); addEdge(N + i, Anc[v]); Anc[v] = N + i; } rof(i, N + M + 1, N + 1) { if(!Depth[i]) { dfs(i, 0); } } cntE = 0; rep(i, 0, K) { scanf(\"%d%d\", &amp;u, &amp;v); int lca = queryLCA(u, v); if(lca) { P[cntE++] = (Node) {u, v, Depth[lca], i}; } } std::sort(P, P + cntE); ll ans = 0; rep(i, 0, cntE) { ll add = std::min(G[P[i].u], G[P[i].v]); G[P[i].u] -= add; G[P[i].v] -= add; ans += add; } printf(\"%lld\\n\", ans &lt;&lt; 1); return 0;}","link":"/BZOJ-3712/"},{"title":"BZOJ 3910 火车","text":"$N$ 个节点的树上，指定一条共 $M$ 个节点的路径，每次会前往剩余节点中没有经过的最靠前的节点。求经过的总边数。 $N\\leq 500000 ,M\\leq 400000$ 分析根据 $dis(u,v) = depth(u) + depth(v) - 2 * depth(lca(u,v ))$ ，可以在 $O(\\log{N})$ 的时间求得两点间的距离。 现在的问题是如何快速判定某个点是否已经经过。 易得 $u\\rightarrow v$ 的路径为 $u\\rightarrow lca(u,v)\\rightarrow v$ ，那么一个简单的思路就是直接更新这两条链上所有节点的状态，实现方法为树链剖分后用树状数组做区间覆盖，复杂度为 $O(N+M\\log^{2}{N})$ ，过不了。 那么还有一个想法就是缩点，将已经经过的联通的所有点缩成一个点，可以通过并查集实现。 每次合并联通块的个数必会减一，所以最多进行 $N$ 次合并。 复杂度 $O(N\\alpha(N)+M\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 500000 + 5;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int N, M, R;int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}int Depth[MAXN], Par[20][MAXN];void dfs(int x, int fa) { Depth[x] = Depth[fa] + 1; Par[0][x] = fa; rep(i, 1, 20) { Par[i][x] = Par[i - 1][Par[i - 1][x]]; } for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != fa) { dfs(v, x); } }}int queryLCA(int u, int v) { if (Depth[u] &gt; Depth[v]) { std::swap(u, v); } rof(i, 20, 0) { if ((Depth[v] - Depth[u]) &gt;&gt; i &amp; 1) { v = Par[i][v]; } } if (u == v) { return u; } rof(i, 20, 0) { if (Par[i][u] != Par[i][v]) { u = Par[i][u]; v = Par[i][v]; } } return Par[0][u];}int Anc[MAXN], Vis[MAXN];void init() { rep(i, 1, N + 1) { Anc[i] = i; }}int findAnc(int x) { return x == Anc[x] ? x : Anc[x] = findAnc(Anc[x]);}void update(int u, int v) { while(Depth[u] &gt; Depth[v]) { Vis[u] = 1; Anc[u] = Par[0][u]; u = findAnc(Par[0][u]); }}int main() { int u, v, w; ll ans = 0; scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;R); rep(i, 1, N) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); } init(); dfs(R, 0); u = R; rep(i, 0, M) { scanf(\"%d\", &amp;v); if (Vis[v]) { continue; } int lca = queryLCA(u, v); ans += Depth[u] + Depth[v] - 2 * Depth[lca]; update(u, lca); update(v, lca); u = v; } printf(\"%lld\\n\", ans); return 0;}","link":"/BZOJ-3910/"},{"title":"「TJOI 2013」BZOJ 3170 松鼠聚会","text":"坐标系中有 $n$ 个点 $(x_i,y_i)$，选择一点 $(x_j,y_j)$，使得所有点到该点的切比雪夫距离之和最小。 $n\\leq 10^5$ 分析$dis(i,j)=max(|x_i-x_j|,|y_i-y_j|)$。 设 $X_i=x_i-y_i,Y_i=x_i+y_i$，则 $dis(i,j)=\\frac{|X_i-X_j|+|Y_i-Y_j|}{2}$，因此 $x,y$ 两部分可以分别计算。 分别按 $x,y$ 排序，做前缀和，则 $\\sum\\limits_{i=1}^{n}|{X_i-X_j}|=(j-1)\\cdot X_j-sumx_{j-1}+sum_n-sum_j-(n-j)\\cdot X_j$。即可 $O(n)$ 计算出最小距离。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * @Author: Skqliao * @Source: TJOI 2013 * @Problem: 3170: [Tjoi2013]松鼠聚会 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=3170 * @Date: 2019-02-22 14:13:36 * @LastEditTime: 2019-02-22 15:06:32 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1e5 + 5;struct Node { int id; long long x, y;} A[MAXN];int N;bool cmp1(const Node&amp; x, const Node&amp; y) { return x.x &lt; y.x;}bool cmp2(const Node&amp; x, const Node&amp; y) { return x.y &lt; y.y;}long long Sum[MAXN];long long X[MAXN], Y[MAXN];int main() { int x, y; scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;x, &amp;y); A[i] = (Node) {i, x - y, x + y}; } std::sort(A + 1, A + N + 1, cmp1); for (int i = 1; i &lt;= N; ++i) { Sum[i] = Sum[i - 1] + A[i].x; } for (int i = 1; i &lt;= N; ++i) { X[A[i].id] = Sum[N] - Sum[i] - (N - i) * A[i].x; X[A[i].id] += (i - 1) * A[i].x - Sum[i - 1]; } std::sort(A + 1, A + N + 1, cmp2); for (int i = 1; i &lt;= N; ++i) { Sum[i] = Sum[i - 1] + A[i].y; } for (int i = 1; i &lt;= N; ++i) { Y[A[i].id] = Sum[N] - Sum[i] - (N - i) * A[i].y; Y[A[i].id] += (i - 1) * A[i].y - Sum[i - 1]; } long long ans = LLONG_MAX; for (int i = 1; i &lt;= N; ++i) { ans = std::min(ans, X[i] + Y[i]); } printf(\"%lld\\n\", ans / 2); return 0;}","link":"/BZOJ-3170/"},{"title":"「JLOI 2015」BZOJ 4006 管道连接","text":"无向图中有 $n$ 个 $m$ 条边，边有权值 $W_i$，有 $p$ 个点有编号 $A_i$。现要求选择一些边，使得（有编号且）编号相同的点联通，求最小权值和。 $n\\leq 1000,m\\leq 3000,p\\leq 10$ 分析如果要求所有有编号的点联通，那么这就是一个最小斯坦纳树的模板题。 现在只要求编号相同的点联通，我们可以分别考虑每个编号的点联通的费用，然后组合出最终的答案。 因此依然先求这 $p$ 个点的最小斯坦纳树。然后再用状压DP合并费用，注意合并时（$s=a+b$）， $a,b$ 必须分别完整包含若干个编号的节点，否则不合题意。 复杂度 $O(3^p\\cdot n)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* * @Author: Skqliao * @Date: 2019-01-27 13:24:25 * @LastEditTime: 2019-01-27 14:52:32 * @Source: JLOI 2015 * @Problem: 4006: [JLOI2015]管道连接 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4006 */#include &lt;bits/stdc++.h&gt;const int MAXN = 1000 + 2;const int MAXM = 30000 + 5;const int MAXS = 1 &lt;&lt; 12;const int INF = 0x3f3f3f3f;struct Edge { int u, v, w, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int N, M, P;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {v, u, w, H[v]}; H[v] = cntE;}int F[MAXN][MAXS];std::queue&lt;int&gt; Que;bool Vis[MAXN];void spfa(int s) { while (!Que.empty()) { int x = Que.front(); Vis[x] = 0; Que.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (F[x][s] + E[i].w &lt; F[v][s]) { F[v][s] = F[x][s] + E[i].w; if (!Vis[v]) { Que.push(v); Vis[v] = 1; } } } }}int Dp[MAXS];int St[MAXN];std::vector&lt;int&gt; V[MAXN];bool check(int s) { for (int i = 1; i &lt;= 10; ++i) { if (!St[i]) { continue; } if ((St[i] &amp; s) != 0 &amp;&amp; (St[i] &amp; s) != St[i]) { return false; } } return true;}int main() { scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;P); int u, v, w; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } memset(F, 0x3f, sizeof F); int p = 0; for (int i = 1; i &lt;= P; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); V[u].push_back(p); F[v][1 &lt;&lt; p++] = 0; } for (int i = 1; i &lt;= 10; ++i) { for (size_t j = 0; j &lt; V[i].size(); ++j) { St[i] |= 1 &lt;&lt; V[i][j]; } } int S = (1 &lt;&lt; p) - 1; memset(Dp, 0x3f, sizeof Dp); for (int s = 0; s &lt;= S; ++s) { for (int i = 1; i &lt;= N; ++i) { for (int x = s; x; x = (x - 1) &amp; s) { F[i][s] = std::min(F[i][s], F[i][x] + F[i][s - x]); } if (F[i][s] &lt; INF) { Que.push(i); } } spfa(s); for (int i = 1; i &lt;= N; ++i) { Dp[s] = std::min(Dp[s], F[i][s]); } } for (int s = 0; s &lt;= S; ++s) { if (check(s)) { for (int x = s; x; x = (x - 1) &amp; s) { if (check(x)) { Dp[s] = std::min(Dp[s], Dp[x] + Dp[s - x]); } } } } printf(\"%d\\n\", Dp[S]); return 0;}","link":"/BZOJ-4006/"},{"title":"「HAOI 2015」BZOJ 4034 树上操作","text":"在一棵有 $N$ 个节点的树上，每个点有初始权值 $W_i$ 。现有 $M$ 个操作，分别为： ADD(u,x) 节点 $u$ 权值增加 $v$ ADD2(u,x)节点 $u$ 的子树的所有节点权值增加 $v$ QUERY(u) 查询节点 $u$ 到根节点($1$)的权值和 $N,M\\leq 100000$，且所有输入数据的绝对值都不会超过 $10^6$ 。 分析树链剖分+线段树模板。 注意需要long long，否则只有30分。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { flush(); }}#endif} // namespace iostruct Graph { static const int MAXN = 100000 + 5; struct Edge { int v, nxt; } E[MAXN &lt;&lt; 1]; int N, R; int H[MAXN], cntE; int Depth[MAXN], Fa[MAXN], Son[MAXN], Sz[MAXN]; int Dfn[MAXN], Top[MAXN], cntD; int W[MAXN], Wp[MAXN]; void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; } void dfs(int x) { Son[x] = 0, Sz[x] = 1; for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { Fa[v] = x; Depth[v] = Depth[x] + 1; dfs(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } } } void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; W[cntD] = Wp[x]; if(Son[x]) { dfs2(Son[x], top); } for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Son[x] &amp;&amp; v != Fa[x]) { dfs2(v, v); } } }#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, r ll Sum[MAXN &lt;&lt; 2], Add[MAXN &lt;&lt; 2]; void pushUp(int rt) { Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1]; } void pushDown(int rt, int L) { ll &amp;add = Add[rt]; if(!add) { return ; } Sum[rt &lt;&lt; 1] += add * (L - (L &gt;&gt; 1)); Sum[rt &lt;&lt; 1 | 1] += add * (L &gt;&gt; 1); Add[rt &lt;&lt; 1] += add; Add[rt &lt;&lt; 1 | 1] += add; add = 0; } void build(int rt, int l, int r) { if(l == r) { Sum[rt] = W[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt); } void add(int rt, int l, int r, int a, int b, ll x) { if(a &lt;= l &amp;&amp; r &lt;= b) { Sum[rt] += x * (r - l + 1); Add[rt] += x; return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { add(LT, a, b, x); } if(m &lt; b) { add(RT, a, b, x); } pushUp(rt); } ll querySum(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return Sum[rt]; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; ll res = 0; if(a &lt;= m) { res += querySum(LT, a, b); } if(m &lt; b) { res += querySum(RT, a, b); } return res; } void addNode(int u, int x) { add(1, 1, N, Dfn[u], Dfn[u], x); } void addTree(int rt, int x) { add(1, 1, N, Dfn[rt], Dfn[rt] + Sz[rt] - 1, x); } ll queryPath(int v) { ll res = 0; int u = R, tu = Top[R], tv = Top[v]; while(tu != tv) { if(Depth[tu] &gt; Depth[tv]) { std::swap(tu, tv); std::swap(u, v); } res += querySum(1, 1, N, Dfn[tv], Dfn[v]); v = Fa[tv]; tv = Top[v]; } if(Depth[u] &gt; Depth[v]) { std::swap(u, v); } res += querySum(1, 1, N, Dfn[u], Dfn[v]); return res; } void prepare() { dfs(R); dfs2(R, R); build(1, 1, N); }} G;int main() { G.N = io::gt&lt;int&gt;(); G.R = 1; int M = io::gt&lt;int&gt;(); rep(i, 1, G.N + 1) { G.Wp[i] = io::gt&lt;int&gt;(); } rep(i, 1, G.N) { G.addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } G.prepare(); rep(i, 0, M) { int opt = io::gt&lt;int&gt;(); if(opt == 1) { int u = io::gt&lt;int&gt;(), x = io::gt&lt;int&gt;(); G.addNode(u, x); } else if(opt == 2) { int u = io::gt&lt;int&gt;(), x = io::gt&lt;int&gt;(); G.addTree(u, x); } else { io::pt(G.queryPath(io::gt&lt;int&gt;())); } } io::flush(); return 0;}","link":"/BZOJ-4034/"},{"title":"「HAOI 2015」BZOJ 4033 树上染色","text":"有一棵点数为 $N$ 的树，树边有边权。给你一个在 $0$ ~ $N$ 之内的正整数 $K$ ，你要在这棵树中选择 $K$ 个点，将其染成黑色，并将其他的 $N-K$ 个点染成白色 。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的受益。问受益最大值是多少。 $0\\leq K\\leq N\\leq 2000$ 分析感觉就是一道联赛难度的树形DP，思路很simple。 枚举当前节点的某个儿子作为根的子树中染成黑色的节点数目，如此该子树内、外各自的黑白节点个数就已知了，可以计算当前这条边（当前节点和该儿子相连的边）对答案的贡献，进行类似01背包的操作。 计算复杂度的话，复杂度上界为 $\\sum\\limits_{x=1}^{N}{\\sum\\limits_{u,v\\in Son[x]}{Sz[u]\\times Sz[v]}}$ 。$Sz[u]\\times Sz[v]$ 可以将其视作从以 $x$ 为根的子树中任意选择两个点，使得它们的LCA是 $x$ 的方案数。由于每个节点对只有一个最近公共祖先，因此它就是在树上选取节点对的方案数，即 $N^2$ 。 复杂度 $O(N^2)$ 。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 2000 + 5;struct Edge { int v, w, nxt;} E[MAXN &lt;&lt; 1];int N, K;int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {v, w, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, w, H[v]}; H[v] = cntE;}ll F[MAXN][MAXN];int Sz[MAXN];void dfs(int x, int fa) { Sz[x] = 1; memset(F[x], -1, sizeof F[x]); F[x][0] = F[x][1] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v == fa) { continue; } dfs(v, x); Sz[x] += Sz[v]; } for (int e = H[x]; e; e = E[e].nxt) { int &amp;v = E[e].v, &amp;w = E[e].w; if (v == fa) { continue; } rof(i, std::min(Sz[x], K) + 1, 0) { rep(j, 0, std::min(Sz[v], i) + 1) { if (F[x][i - j] != -1) { ll val = 1ll * w * (j * (K - j) + (Sz[v] - j) * (N - Sz[v] - K + j)); F[x][i] = std::max(F[x][i], F[x][i - j] + F[v][j] + val); } } } }}int main() { int u, v, w; scanf(\"%d%d\", &amp;N, &amp;K); rep(i, 1, N) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } dfs(1, 0); printf(\"%lld\\n\", F[1][K]); return 0;}","link":"/BZOJ-4033/"},{"title":"BZOJ 4260 Codechef REBXOR","text":"对于长为 $N$ 的序列 $A[1\\cdots N]$，求两个不相交区间的异或和之和的最大值。 $2\\leq N\\leq 4\\times 10^5,A[i]\\leq 10^9$ 分析根据异或的性质， 令 $S[i]=A[1]\\oplus A[2]\\cdots \\oplus A[i]$，则$A[l]\\oplus\\cdots \\oplus A[r]=S[r]\\oplus S[l-1]$。 令 $L[i]$ 为 $A[1\\cdots i]$ 中的最大区间异或和， $R[i]$ 为 $A[i\\cdots N]$ 中的最大区间异或和，如此 $L[i],R[i+1]$ 一定不相交，答案为 $max(L[i]+R[i+1])$。 从前往后在01字典树中查询当前前缀异或和 $cur$ 能异或得到的最大值，并将 $cur$插入，则$L[i]=\\max(L[i-1],query(cur))$。 再从后往前插入后缀异或和，则 $R[i]=\\max(R[i+1],query(cur))$。 复杂度 $O(n\\log{n})$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;const int MAXN = 4e5 + 5;const int MAXM = 40;struct Node { int sz, num; int ch[2];} T[MAXN * MAXM];int cntT;int N, A[MAXN];int L[MAXN], R[MAXN];void insert(int rt, int x) { for (int i = 32; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (!T[rt].ch[c]) { T[rt].ch[c] = ++cntT; T[cntT].ch[0] = T[cntT].ch[1] = 0; T[cntT].sz = 0; } ++T[rt].sz; rt = T[rt].ch[c]; } T[rt].num = x;}int query(int rt, int x) { for (int i = 32; i &gt;= 0; --i) { int c = (x &gt;&gt; i) &amp; 1; if (!T[rt].ch[c ^ 1]) { rt = T[rt].ch[c]; } else { rt = T[rt].ch[c ^ 1]; } } return x ^ T[rt].num;}void init() { cntT = 1; T[1].ch[0] = T[1].ch[1] = 0; T[1].sz = T[1].num = 0;}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); } int lst = 0; insert(1, 0); for (int i = 1; i &lt;= N; ++i) { lst ^= A[i]; L[i] = std::max(L[i - 1], query(1, lst)); insert(1, lst); } init(); lst = 0; insert(1, 0); for (int i = N; i &gt;= 1; --i) { lst ^= A[i]; R[i] = std::max(R[i + 1], query(1, lst)); insert(1, lst); } int ans = 0; for (int i = 1; i &lt; N; ++i) { ans = std::max(ans, L[i] + R[i + 1]); } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-4260/"},{"title":"「CQOI 2016」BZOJ 4519 不同的最小割","text":"题目大意在无向图 $G$ 中，对于任意点对 $(i,j)$ 有最小割 $cut(i,j)$，求有多少个数值不同的最小割。 $N\\leq 850,M\\leq 8500$ 分析最小割树模板题，求出最小割树后将所有边unique得到答案。 复杂度 $O(n\\times f)$，$f$ 为最大流复杂度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* * @Author: Skqliao * @Date: 2019-02-02 22:26:52 * @LastEditTime: 2019-02-02 22:54:36 * @Source: CQOI 2016 * @Problem: 4519: [Cqoi2016]不同的最小割 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=4519 */#include &lt;bits/stdc++.h&gt;const int MAXN = 850 + 5;const int MAXM = 8500 + 5;namespace GH_Tree {struct Edge { int v, f, cap, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Idx[MAXN], Tmp[MAXN];int S, T;int Dis[MAXN], Cur[MAXN];int Col[MAXN];void init(int n) { cntE = -1; memset(H, -1, sizeof H); for (int i = 1; i &lt;= n; ++i) { Idx[i] = i; }}void addEdge(int u, int v, int f) { E[++cntE] = (Edge){v, f, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge){u, f, f, H[v]}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; while (!Que.empty()) Que.pop(); memcpy(Cur, H, sizeof H); memset(Dis, -1, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == -1 &amp;&amp; E[i].f) { Dis[v] = Dis[x] + 1; Que.push(v); if (v == T) return true; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) return maxf; int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (flow) { left -= flow; E[i].f -= flow; E[i ^ 1].f += flow; } else Dis[v] = -1; } } return maxf - left;}int dinic() { int flow = 0; while (bfs()) flow += dfs(S, INT_MAX); return flow;}void dfs(int x) { Col[x] = 1; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; !Col[v]) dfs(v); }}std::vector&lt;int&gt; V;void build(int l, int r) { if (l == r) return; S = Idx[l], T = Idx[r]; for (int i = 0; i &lt;= cntE; ++i) { E[i].f = E[i].cap; } int f = dinic(); V.push_back(f); memset(Col, 0, sizeof Col); dfs(S); int L = l, R = r; for (int i = l; i &lt;= r; ++i) { if (Col[Idx[i]]) Tmp[L++] = Idx[i]; else Tmp[R--] = Idx[i]; } memcpy(Idx, Tmp, sizeof Tmp); build(l, R); build(L, r);}int solve(int n, int m) { init(n); int u, v, f; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;f); addEdge(u, v, f); } build(1, n); std::sort(V.begin(), V.end()); V.erase(std::unique(V.begin(), V.end()), V.end()); return V.size();}} // namespace GH_Treeint N, M;int main() { scanf(\"%d%d\", &amp;N, &amp;M); printf(\"%d\\n\", GH_Tree::solve(N, M)); return 0;}","link":"/BZOJ-4519/"},{"title":"「[BJOI 2014」BZOJ 4530 大融合","text":"开始有 $N$ 个点，$M$ 个操作。每次插入一条边（保证不成环），或者查询一条边的负载值。负载值的定义为当前树上经过它的简单路径条数。 $N,Q\\leq 100000$ 分析边的负载值等价于删去它后该边两点所在联通块大小的乘积。 现在问题在于如何计算联通块的大小。 在线做需要LCT，我不会，于是考虑将森林建好后离线做。 那么现在一条边所涉及的两个联通块大小，分别就是父亲所在的联通块大小 $Sz[x]$ 和儿子所在的子树大小 $Sz[y]$ ，负载值为 $(Sz[x]-Sz[y])\\times Sz[y]$ （因为父亲所在联通块一定包含儿子所在的子树）。 插入一条边的影响就是，父亲节点到「它所在并查集中深度最小的点（即当前树的根节点）」的那条链上所有节点的子树大小增加 $Sz[y]$ 。 如何找到这个根节点，显然是并查集维护联通块，让联通块内深度最小的点作祖先。 而对一条链进行区间加法和单点查询，显然是树链剖分+线段树/树状数组。 复杂度为 $O(N+Q\\log^2{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 100000 + 5;struct Edge { int v, nxt;} E[MAXN &lt;&lt; 1];int N, Q;int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE;}int Fa[MAXN], Son[MAXN], Sz[MAXN], Depth[MAXN];int Top[MAXN], Dfn[MAXN], cntD;void dfs(int x) { Depth[x] = Depth[Fa[x]] + 1; Sz[x] = 1; for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { Fa[v] = x; dfs(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } }}void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; if(Son[x]) { dfs2(Son[x], top); } for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x] &amp;&amp; v != Son[x]) { dfs2(v, v); } }}#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Sum[MAXN &lt;&lt; 2], Add[MAXN &lt;&lt; 2];void pushUp(int rt) { Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1];}void pushDown(int rt, int L) { int &amp;add = Add[rt]; if(add) { Add[rt &lt;&lt; 1] += add; Add[rt &lt;&lt; 1 | 1] += add; Sum[rt &lt;&lt; 1] += add * (L - (L &gt;&gt; 1)); Sum[rt &lt;&lt; 1 | 1] += add * (L &gt;&gt; 1); add = 0; }}void build(int rt, int l, int r) { if(l == r) { Sum[rt] = 1; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void add(int rt, int l, int r, int a, int b, int x) { if(a &lt;= l &amp;&amp; r &lt;= b) { Sum[rt] += (r - l + 1) * x; Add[rt] += x; return ; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { add(LT, a, b, x); } if(m &lt; b) { add(RT, a, b, x); } pushUp(rt);}int query(int rt, int l, int r, int p) { if(l == r) { return Sum[rt]; } pushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { return query(LT, p); } else { return query(RT, p); }}int Anc[MAXN];void init(int n) { rep(i, 1, n + 1) { Anc[i] = i; }}int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}void merge(int x, int y) { x = findAnc(x), y = findAnc(y); if(Depth[x] &gt; Depth[y]) { Anc[x] = y; } else { Anc[y] = x; }}void modify(int x, int sz) { int y = findAnc(x); while(x &amp;&amp; Depth[Top[x]] &gt;= Depth[y]) { add(1, 1, N, Dfn[Top[x]], Dfn[x], sz); x = Fa[Top[x]]; } if(x) { add(1, 1, N, Dfn[y], Dfn[x], sz); }}int Type[MAXN], U[MAXN], V[MAXN];int main() { char opt[5]; scanf(\"%d%d\", &amp;N, &amp;Q); init(N); rep(i, 0, Q) { scanf(\"%s%d%d\", opt, &amp;U[i], &amp;V[i]); Type[i] = opt[0] == 'A'; if(Type[i]) { addEdge(U[i], V[i]); } } rep(i, 1, N + 1) { if(!Fa[i]) { dfs(i); dfs2(i, i); } } init(N); build(1, 1, N); rep(i, 0, Q) { if(Type[i]) { merge(U[i], V[i]); if(Depth[U[i]] &lt; Depth[V[i]]) { modify(U[i], query(1, 1, N, Dfn[V[i]])); } else { modify(V[i], query(1, 1, N, Dfn[U[i]])); } } else { if(Depth[U[i]] &lt; Depth[V[i]]) { std::swap(U[i], V[i]); } V[i] = findAnc(V[i]); int num = query(1, 1, N, Dfn[V[i]]); int num2 = query(1, 1, N, Dfn[U[i]]); printf(\"%d\\n\", num2 * (num - num2)); } } return 0;}","link":"/BZOJ-4530/"},{"title":"「JSOI 2016」BZOJ 4753 最佳团体","text":"每个点有一个父亲，它能被选择当且仅当它父亲被选择，0号节点默认被选择。每个点有收益 $X[i]$，代价 $Y[i]$。选择恰好 $K$ 个点（不算0号），使得其对应的 $\\sum{X[i]}/\\sum{Y[i]}$ 最大。 $N\\leq 2500$ 分析通过分数规划，二分答案来避免除法。 选择关系是一棵树，被选择的点处于一个联通分量。树形背包，转移时父亲被强制选择。 复杂度 $O(NK\\log{X[i]})$ 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;const int MAXN = 2500 + 5;const double eps = 1e-4;int N, K;int A[MAXN], B[MAXN], P[MAXN];std::vector&lt;int&gt; G[MAXN];double F[MAXN][MAXN], Tmp[MAXN];int Sz[MAXN];void dfs(int x, double m) { F[x][0] = 0; F[x][1] = B[x] - A[x] * m; Sz[x] = 1; for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; dfs(v, m); memset(Tmp, 0xc2, sizeof Tmp); Tmp[0] = 0; for (int j = 1; j &lt;= Sz[x]; ++j) { for (int k = 0; k &lt;= Sz[v] &amp;&amp; j + k &lt;= K; ++k) { Tmp[j + k] = std::max(Tmp[j + k], F[x][j] + F[v][k]); } } Sz[x] += Sz[v]; memcpy(F[x], Tmp, sizeof Tmp); }}bool check(double m) { memset(F, 0xc2, sizeof F); dfs(0, m); return F[0][K] &gt;= 0;}int main() { scanf(\"%d%d\", &amp;K, &amp;N); ++K; for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d%d\", &amp;A[i], &amp;B[i], &amp;P[i]); G[P[i]].push_back(i); } double l = 0, r = 1e4, ans; while (r - l &gt; eps) { double m = (l + r) / 2; if (check(m)) { l = ans = m; } else { r = m; } } printf(\"%.3lf\\n\", ans); return 0;}","link":"/BZOJ-4753/"},{"title":"「SDOI 2017」BZOJ 4819 新生舞会","text":"双方各有 $N$ 个人进行两两配对，$i$ 和 $j$ 配对会获得 $x=A[i][j]$ 的收益和 $y=B[i][j]$ 的代价。最小化 $\\sum{x}/\\sum{y}$。 $N\\leq 100,x,y\\leq 10^4$ 分析若 $\\sum{x}/\\sum{y}\\geq a$，则 $\\sum{x}-a\\cdot\\sum{y} \\geq 0$，再转化变成 $\\sum{x-a\\cdot y}\\geq 0$。 $a$ 显然是可以二分的，然后建图跑最小费用最大流，边权为 $a\\cdot B[i][j]-A[i][j]$，判定合法即总费用是否小于0。 有更快的Dinkelbach算法，考虑用迭代的方式求 $a$。初始化 $a=0$，得到一组合法解后，更新 $a$ 为当前情况下的 $\\sum{x}/\\sum{y}$，直到求得答案。此方法实测比二分快了10倍。 费用流的过程本质就是一个二分图最大权匹配，因此跑KM也是可行的，复杂度上界 $O(\\log{(10^6\\cdot x)}\\cdot n^3)$，实则远远跑不满。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;const int MAXN = 200 + 5;const int MAXM = MAXN * MAXN;const double eps = 1e-7;const double INF = 1e7;int N, A[MAXN][MAXN], B[MAXN][MAXN];struct Edge { int v; double w; int f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, double w, int f) { E[++cntE] = (Edge) {v, w, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -w, 0, H[v]}; H[v] = cntE;}int S, T;void buildGraph(double x) { memset(H, 0, sizeof H); cntE = 1; S = 0; T = N * 2 + 1; for (int i = 1; i &lt;= N; ++i) { addEdge(S, i, 0, 1); addEdge(i + N, T, 0, 1); for (int j = 1; j &lt;= N; ++j) { addEdge(i, j + N, x * B[i][j] - A[i][j], 1); } }}int Pe[MAXN], Pv[MAXN];double Dis[MAXN];bool Vis[MAXN];struct cmp { inline bool operator () (const int &amp;x, const int &amp;y) const { return Dis[x] &gt; Dis[y]; }};std::priority_queue&lt;int, std::vector&lt;int&gt;, cmp&gt; pq;int spfa(int s, int t) { for (int i = s; i &lt;= t; ++i) { Dis[i] = INF; } memset(Vis, 0, sizeof Vis); Dis[s] = 0, pq.push(s); while (!pq.empty()) { int x = pq.top(); Vis[x] = 0, pq.pop(); for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &gt; 0 &amp;&amp; Dis[v] &gt; Dis[x] + E[i].w) { Dis[v] = Dis[x] + E[i].w; Pe[v] = i, Pv[v] = x; if (!Vis[v]) { Vis[v] = 1; pq.push(v); } } } } return Dis[t] &lt; INF;}double cost;int flow;double ai, bi;void mcmf(int s, int t) { cost = flow = 0; while (spfa(s, t)) { int f = INF; for (int i = t; i != s; i = Pv[i]) { f = std::min(f, E[Pe[i]].f); } cost += f * Dis[t]; flow += f; for (int i = t; i != s; i = Pv[i]) { E[Pe[i]].f -= f, E[Pe[i] ^ 1].f += f; } } ai = bi = 0; for (int x = 1; x &lt;= N; ++x) { for (int i = H[x]; i; i = E[i].nxt) { if (E[i].f == 0 &amp;&amp; E[i].v &gt; N) { ai += A[x][E[i].v - N]; bi += B[x][E[i].v - N]; break; } } }}bool check(double lim) { buildGraph(lim); mcmf(S, T); return flow == N &amp;&amp; cost &lt; -eps;}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { scanf(\"%d\", &amp;A[i][j]); } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { scanf(\"%d\", &amp;B[i][j]); } } double ans = 0; while (check(ans)) { ans = ai / bi; } printf(\"%.6lf\\n\", ans); return 0;}","link":"/BZOJ-4819/"},{"title":"「TJOI/HEOI2016」BZOJ 4551 树","text":"在有根树 $T$ 中，有两种操作：给某点 $x$ 打标记、查询离某点 $x$ 最近被打标记的祖先，数据范围 $10^6$ 。 $1\\leq N, Q\\leq 100000$ 分析跟【dfs序+线段树】[USACO10FEB]「luogu P2982 Slowing down」 思路相同，反着考虑标记一个点对其他点的影响。 显然标记一个点后会影响以它为根的整棵子树。 那么用线段树维护每个点DFS序后，离它最近的被打标记的祖先。 比较原值和新值的大小关系进行更新操作，易得标号大的点更深（在同一棵子树中）。 复杂度 $O(Q\\log{N})$ 。 P.S 不得不说的是，此题数据水到感人，直接暴力树上走路比线段树快的多。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 100000 + 5;struct Edge { int v, nxt;} E[MAXN];int H[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE;}int Dfn[MAXN], Nfd[MAXN], Sz[MAXN], cntD;void dfs(int x) { Dfn[x] = ++cntD; Nfd[cntD] = x; Sz[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; dfs(v); Sz[x] += Sz[v]; }}int Max[MAXN &lt;&lt; 2], Mrk[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rvoid pushUp(int rt) { if(Max[rt &lt;&lt; 1] == Max[rt &lt;&lt; 1 | 1]) { Max[rt] = Max[rt &lt;&lt; 1]; } else { Max[rt] = -1; }}void pushDown(int rt) { int &amp;mrk = Mrk[rt]; if(mrk) { Mrk[rt &lt;&lt; 1] = std::max(Mrk[rt &lt;&lt; 1], mrk); Mrk[rt &lt;&lt; 1 | 1] = std::max(Mrk[rt &lt;&lt; 1 | 1], mrk); Max[rt &lt;&lt; 1] = std::max(Max[rt &lt;&lt; 1], Max[rt]); Max[rt &lt;&lt; 1 | 1] = std::max(Max[rt &lt;&lt; 1 | 1], Max[rt]); mrk = 0; }}void build(int rt, int l, int r) { if (l == r) { Max[rt] = 1; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void change(int rt, int l, int r, int a, int b, int x) { if(a &lt;= l &amp;&amp; r &lt;= b) { if(Max[rt] &lt;= x) { Max[rt] = x; Mrk[rt] = std::max(x, Max[rt]); } return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { change(LT, a, b, x); } if(m &lt; b) { change(RT, a, b, x); } pushUp(rt);}int query(int rt, int l, int r, int p) { if(l == r) { return Max[rt]; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { return query(LT, p); } else { return query(RT, p); }}int main() { int N = io::gt&lt;int&gt;(), Q = io::gt&lt;int&gt;(); rep(i, 1, N) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); addEdge(u, v); } dfs(1); build(1, 1, N); while(Q--) { char opt = io::gc(); while(!isalpha(opt)) { opt = io::gc(); } int x = io::gt&lt;int&gt;(); if(opt == 'C') { change(1, 1, N, Dfn[x], Dfn[x] + Sz[x] - 1, Dfn[x]); } else { io::pt(Nfd[query(1, 1, N, Dfn[x])]); } } io::flush(); return 0;}","link":"/BZOJ-4551/"},{"title":"「USACO2018 OPEN」BZOJ 5281 Talent Show","text":"$N$ 个点各有权值 $W_i$ 和 $T_i$，在其中选择任意多个点，在满足 $\\sum{W_i} \\geq A$ 的条件下求 $\\sum{T_i}/\\sum{W_i}$ 的最大值。 $1\\leq N\\leq 250,1\\leq W\\leq 1000,1\\leq W_i\\leq 10^6,1\\leq T_i\\leq 10^3$ 分析套路二分答案 $x$，然后背包求在 $\\sum{W_i}\\geq A$ 的情况下判定 $\\sum{T_i-W_i\\times x}\\geq 0$ 是否成立。 由于答案是 $\\times 1000$ 取整，为了避免浮点数运算，可以直接将 $T_i$ 放大 $1000$ 倍。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;const int MAXN = 250 + 5;const int MAXM = 1000 + 5;int N, M;int A[MAXN], B[MAXN];long long F[MAXM];bool check(int a) { memset(F, 0xc2, sizeof F); long long tmp = F[0]; F[0] = 0; for (int i = 1; i &lt;= N; ++i) { for (int j = M; j &gt;= 0; --j) { if (F[j] != tmp) { int v = std::min(M, j + A[i]); F[v] = std::max(F[v], F[j] - (long long)A[i] * a + B[i]); } } } return F[M] &gt;= 0;}int main() { scanf(\"%d%d\", &amp;N, &amp;M); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;A[i], &amp;B[i]); B[i] *= 1000; } int l = 0, r = 2e8, ans = 0; while (l &lt;= r) { int m = (l + r) / 2; if (check(m)) { ans = m; l = m + 1; } else { r = m - 1; } } printf(\"%d\\n\", ans); return 0;}","link":"/BZOJ-5281/"},{"title":"「BJOI 2018」BZOJ 5293 求和","text":"在一棵有 $n$ 个节点，根节点为 $1$ 的树上进行 $m$ 次询问。 每次查询 $(u,v)$ 之间的简单路径的“ $k$ 次深度和”。 $k$ 次深度和即 $\\sum_{i\\in(u,v)}Depth(i)^k$，$Depth(1)=0$。 询问的结果对 $998244353$ 取模。 $1\\leq n,m\\leq 300000,1\\leq k\\leq 50$ 分析首先注意到没有修改操作，只有查询。 其次注意到 $k$ 很小，$k$ 次方可以预处理。 最后注意到每次查询就是一个 $k$ 次的两段连续区间的求和。 记 $lca$ 为 $(u,v)$ 的最近公共祖先。 那么查询的结果即为 $\\sum_{i=Depth(lca)}^{Depth(u)}i^k+\\sum_{i=Depth(lca)+1}^{Depth(v)}i^k$ 预处理 $F_{i,j} = \\sum_{u=0}^{j}u^i$ 则查询的结果为 $F_{k,Depth(v)}-F_{k,Depth(lca)}+F_{k,Depth(u)}-F_{k,Depth(lca)}+Depth(lca)^k$ 对于 $m$ 组 $(u,v)$ 求LCA，树剖、倍增、Tarjan都可以。 如果选择树剖、倍增，复杂度 $O(n\\times k+m\\times \\log{n})$； 如果选择Tarjan，复杂度 $O(n\\times k+m)$。 实测Tarjan常数较大，运行时间相对更长（可能是写渣了）。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEinline char gc() { return getchar();}template &lt;class T&gt; inline T gt() { register T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') {std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst static int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { register char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-'); register bool f = c == '-'; register T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif}const int MAXN = 300000 + 5;const int MOD = 998244353;std::vector&lt;int&gt; G[MAXN];int maxDep;int Fa[MAXN], Sz[MAXN], Depth[MAXN];int Son[MAXN], Top[MAXN];void dfs1(int x) { Sz[x] = 1; if(x == 1) { Depth[x] = 0; } else { Depth[x] = Depth[Fa[x]] + 1; } maxDep = std::max(maxDep, Depth[x]); rep(i, 0, SZ(G[x])) { int &amp;v = G[x][i]; if(Fa[x] != v) { Fa[v] = x; dfs1(v); Sz[x] += Sz[v]; if(Sz[v] &gt; Sz[Son[x]] || !Son[x]) { Son[x] = v; } } }}void dfs2(int x, int fa) { Top[x] = fa; if(Son[x]) { dfs2(Son[x], fa); } rep(i, 0, SZ(G[x])) { int &amp;v = G[x][i]; if(v != Fa[x] &amp;&amp; v != Son[x]) { dfs2(v, v); } }}int query(int u, int v) { while(Top[u] ^ Top[v]) { if(Depth[Top[u]] &gt; Depth[Top[v]]) { u = Fa[Top[u]]; } else { v = Fa[Top[v]]; } } return Depth[u] &lt; Depth[v] ? u : v;}std::vector&lt;int&gt; Sum[MAXN];ll poww(ll x, ll t) { ll ans = 1; for(; t; t &gt;&gt;= 1, x = x * x % MOD) { if(t &amp; 1) { ans = ans * x % MOD; } } return ans;}void pre() { rep(i, 1, 51) { Sum[i].push_back(0); rep(j, 1, maxDep + 1) { ll cur = (poww(j, i) + Sum[i].back()) % MOD; Sum[i].push_back(cur); } }}int main() { rep(i, 1, io::gt&lt;int&gt;()) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(); G[u].push_back(v); G[v].push_back(u); } dfs1(1); dfs2(1, 1); pre(); rep(i, 0, io::gt&lt;int&gt;()) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(), k = io::gt&lt;int&gt;(); int lca = query(u, v); int &amp;depx = Depth[u], &amp;depy = Depth[v]; int &amp;depl = Depth[lca]; int ans = ((Sum[k][depy] - Sum[k][depl] + Sum[k][depx] - Sum[k][depl] + poww(depl, k)) % MOD + MOD) % MOD; io::pt(ans); } io::fflush(); return 0;}","link":"/BZOJ-5293/"},{"title":"「TJOI 2017」BZOJ 4890 城市","text":"在一棵无向树上修改一条边的起点终点，使得新图依然是树，并最小化新树的直径。 $N\\leq 5000$ 分析由于最多只有 $5000-1$ 条边，因此可以直接枚举要删除的边。 如果可以在 $O(N)$ 的时间求出修改该边后的直径，就可以在 $O(N^2)$ 的时间求解本题，$3$ s 的时间是可以接受的。 删去一条边后，原树被拆成了两棵新树 $A,B$，那么新直径的端点位置有两类情况： 两个端点在同一棵树中 一个端点在 $A$ 一个端点在 $B$ 对于第一类，直接 $O(N)$ 求树的直径，链的长度分别为 $d1,d2$，但是对于第二种，其实就是分别在两棵树中找到「最长距离最小」的点，并将它们连接，那么这条链的长度为 $r1+r2+w$ ，其中 $r$ 为树中的距离， $w$ 为修改边的变长。 因此答案为 $\\min{\\max{d1,d2,r1+r2+w}}$ 。 求 $r$ 只需要从任意一点遍历该树，距离某点最远距离的点要么为根节点，要么为其子树中某点，所以树形dp就能得到这个「最小的最长距离」。 还可以强力剪枝（当然上面的做法已经可以AC了）。 易得如果修改的边不在原树的直径上，是没有意义的（因为新树的中该直径依然存在），因此先得到原树的直径，再去枚举直径上的边完成前面的操作，会大大减少枚举量。实测由8876ms降至777ms。 复杂度依然是 $O(N^2)$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 5000 + 5;struct Edge { int u, v, w, nxt;} E[MAXN &lt;&lt; 1];int H[MAXN], cntE;void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u]}; H[u] = cntE;}int Nxt[MAXN], Vis[MAXN], F[MAXN], G[MAXN];int dis, rad;int Dis[MAXN], Lst[MAXN], W[MAXN];void dfs(int x) { for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(!Dis[v]) { Dis[v] = Dis[x] + E[i].w; Lst[v] = x; W[v] = E[i].w; dfs(v); } }}void getD(int x) { Vis[x] = 1; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Vis[v]) { continue; } getD(v); int d = F[v] + E[i].w; if (d &gt; F[x]) { G[x] = F[x]; F[x] = d; Nxt[x] = v; } else { chkMax(G[x], d); } } chkMax(dis, F[x] + G[x]);}void getR(int x, int r) { chkMin(rad, std::max(r, F[x])); Vis[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (Vis[v]) { if (v == Nxt[x]) { getR(v, std::max(G[x] + E[i].w, r + E[i].w)); } else { getR(v, std::max(F[x] + E[i].w, r + E[i].w)); } } }}void clear() { dis = 0, rad = INT_MAX; memset(Vis, 0, sizeof Vis); memset(F, 0, sizeof F); memset(G, 0, sizeof G);}int res = INT_MAX;void cal(int u, int v, int w) { int d1, d2, r1, r2; clear(); Vis[v] = 1; dis = 0; getD(u); d1 = dis; dis = 0; getD(v); d2 = dis; dis = Vis[v] = 0; getR(u, 0); r1 = rad; rad = INT_MAX; getR(v, 0); r2 = rad; rad = INT_MAX; chkMin(res, std::max(r1 + r2 + w, std::max(d1, d2)));}int main() { int u, v, w, N; scanf(\"%d\", &amp;N); rep(i, 1, N) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); addEdge(v, u, w); } int d = 0, st, st2; dfs(1); rep(i, 2, N + 1) { if(chkMax(d, Dis[i])) { st = i; } } memset(Dis, 0, sizeof Dis); dfs(st); d = 0; rep(i, 2, N + 1) { if(chkMax(d, Dis[i])) { st2 = i; } } for(int i = st2; i != st; i = Lst[i]) { cal(i, Lst[i], W[i]); } printf(\"%d\\n\", res); return 0;}","link":"/BZOJ-4890/"},{"title":"「CQOI 2018」BZOJ 5301 异或序列","text":"在序列 $A[1…N]$ 中查询 $M$ 次，每次查询 $A[L_i,R_i]$ 中异或和为 $K$ 的子序列的个数。 $1\\leq N,M\\leq 10^5,0\\leq K, A_i\\leq 105,1\\leq L_i\\leq R_i\\leq N$ 分析记 $A[l…r] = A[l]\\bigoplus A[l+1]\\bigoplus…A[r]$ ，若 $A[1…L-1] = x，A[1….R] = y$ 那么 $A[L…R] = x\\bigoplus y$。 也就是说如果满足 $x\\bigoplus y=k$，那么 $A[L,R]$ 就是一个合法子序列。 考虑增加一个数 $A[x]$ 产生的影响。 记 $Cnt[x]$ 为满足 $A[1…r] = x$ 的 $r$ 的个数，那么区间个数会因此增加 $Cnt[x\\bigoplus K]$ 个，增加的区间分别为 $A[\\min(x,r)+1,\\max(x,r)]$。 删除一个数同理，都是 $O(1)$ 的。 想到莫队算法。 复杂度 $O(M\\log{M} + N\\sqrt{N+M})$ 。 P.S 注意细节，$[l,r]$ 是通过 $[1,r]\\bigoplus[1,l-1]$ 异或得到的，而不是 $[1,l]$ ；想清楚增加/删除一个数时，是先改统计数，还是先改答案。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 1e5 + 5;int Pos[MAXN];struct Query { int l, r, id; bool operator &lt; (const Query &amp;x) const { return Pos[l] == Pos[x.l] ? Pos[x.l] &amp; 1 ? r &gt; x.r : r &lt; x.r : Pos[l] &lt; Pos[x.l]; }} Q[MAXN];int N, M, K;int A[MAXN], Num[MAXN &lt;&lt; 1];int l = 1, r;ll Ans[MAXN], ans;void del(int x) { --Num[A[x]]; ans -= Num[A[x] ^ K];}void add(int x) { ans += Num[A[x] ^ K]; Num[A[x]]++;}int main() { N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(), K = io::gt&lt;int&gt;(); int sz = sqrt(N); rep(i, 1, N + 1) { Pos[i] = i / sz; A[i] = io::gt&lt;int&gt;(); A[i] ^= A[i - 1]; } rep(i, 1, M + 1) { Q[i].l = io::gt&lt;int&gt;(), Q[i].r = io::gt&lt;int&gt;(); Q[i].id = i; } std::sort(Q + 1, Q + M + 1); Num[0] = 1; rep(i, 1, M + 1) { while (l &lt; Q[i].l) { del(l++ - 1); } while (l &gt; Q[i].l) { add(--l - 1); } while (r &lt; Q[i].r) { add(++r); } while (r &gt; Q[i].r) { del(r--); } Ans[Q[i].id] = ans; } rep(i, 1, M + 1) { io::pt(Ans[i]); } io::flush(); return 0;}","link":"/BZOJ-5301/"},{"title":"「TJOI 2018」BZOJ 5335 智力竞赛","text":"用 $n+1$ 条链覆盖一个点权有向无环图，若可以全部覆盖输出AK，否则求不能被覆盖的点的点权最小值的最大值。 $n\\leq 50,m\\leq 500$ 分析首先判断是否能全部覆盖，即求可重点DAG的最小路径覆盖，传递闭包后求二分图最大匹配。 否则二分答案，判断边权小于当前二分值 $w$ 的子图是否能被完全覆盖。 复杂度 $O(n^2\\log{n})$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* * @Author: Skqliao * @Source: TJOI 2018 * @Problem: 5335: [TJOI2018]智力竞赛 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=5335 * @Date: 2019-03-05 20:00:52 * @LastEditTime: 2019-03-06 12:29:01 */#include &lt;bits/stdc++.h&gt;const int MAXN = 500 + 5;int N, M;std::bitset&lt;MAXN&gt; G[MAXN], g[MAXN];int W[MAXN];int Match[MAXN], Vis[MAXN];int dfs(int x) { if (Vis[x]) return 0; Vis[x] = 1; for (int i = 1; i &lt;= N; ++i) { if (g[x][i] &amp;&amp; (!Match[i] || dfs(Match[i]))) { Match[i] = x; return 1; } } return 0;}bool check(int w) { int tot = 0; for (int i = 1; i &lt;= N; ++i) tot += W[i] &lt; w; for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { if (W[i] &lt; w &amp;&amp; W[j] &lt; w) g[i][j] = G[i][j]; else g[i][j] = 0; } } memset(Match, 0, sizeof Match); for (int i = 1; i &lt;= N; ++i) { memset(Vis, 0, sizeof Vis); tot -= dfs(i); } return tot &lt;= M + 1;}int main() { int num, x, mx = 0; scanf(\"%d%d\", &amp;M, &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d%d\", &amp;W[i], &amp;num); mx = std::max(mx, W[i]); while (num--) { scanf(\"%d\", &amp;x); G[i][x] = 1; } } for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { if (G[i][j]) G[i] |= G[j]; } } if (check(mx + 1)) { puts(\"AK\"); } else { int l = 0, r = mx, ans = 0; while (l &lt;= r) { int m = (l + r) / 2; if (check(m)) { ans = m; l = m + 1; } else { r = m - 1; } } printf(\"%d\\n\", ans); } return 0;}","link":"/BZOJ-5335/"},{"title":"「TJOI 2018」BZOJ 5334 数学计算","text":"维护 $x\\% mod$，初值 $x=1$，有 $Q$ 个操作。 1 a $x=x\\times a$ 2 a $x=x / A[a]$，其中 $A[a]$ 为第 $a$ 次操作乘的数，保证第 $i$ 次是操作1，且每个位置最多被除一次 $T$ 组数据。 $T\\leq 5,Q\\leq 100000,mod\\leq 10^9$ 分析这是一类常见套路，根据时间分治。 具体而言，以时间为区间建线段树，维护区间乘积。 复杂度 $T\\times Q\\log{Q}$。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* * @Author: Skqliao * @Source: BZOJ 5334 * @Problem: 5334: [Tjoi2018]数学计算 * @Url: https://lydsy.com/JudgeOnline/problem.php?id=5334 * @Date: 2019-03-05 17:36:17 * @LastEditTime: 2019-03-05 19:10:49 */#include &lt;bits/stdc++.h&gt;const int MAXN = 100000 + 5;int Q, MOD;long long Mul[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rvoid pushUp(int rt) { Mul[rt] = Mul[rt &lt;&lt; 1] * Mul[rt &lt;&lt; 1 | 1] % MOD; }void build(int rt, int l, int r) { if (l == r) { Mul[rt] = 1; return; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void update(int rt, int l, int r, int p, int x) { if (l == r) { Mul[rt] = x; return; } int m = (l + r) &gt;&gt; 1; if (p &lt;= m) { update(LT, p, x); } else { update(RT, p, x); } pushUp(rt);}void solve() { scanf(\"%d%d\", &amp;Q, &amp;MOD); build(1, 1, Q); int opt, x; for (int i = 1; i &lt;= Q; ++i) { scanf(\"%d%d\", &amp;opt, &amp;x); if (opt == 1) { update(1, 1, Q, i, x); } else { update(1, 1, Q, x, 1); } printf(\"%lld\\n\", Mul[1]); }}int main() { int T; scanf(\"%d\", &amp;T); while (T--) { solve(); } return 0;}","link":"/BZOJ-5334/"},{"title":"最小割树学习笔记（Gomory-Hu Tree）","text":"总论在无向图中，最小割树等价于所有点对间的最小割。 对于任意点对 $(s,t)$，它们之间的最小割为最小割树上 $(s,t)$ 路径间的最小边权值。 过程可以通过求 $n-1$ 次最大流构建出具有 $n$ 个点的无向图 $G$ 的最小割树。 具体步骤如下： 任意选择两点 $s,t$ 求两点间最大流 $f$ 得到最小割隔开的两个集合 最小割树上连接 $(s,t)$，边权为 $f$ 将图恢复成最初形态（还原边权） 递归到这两个新集合中，重复操作1，直到集合中只有 $1$ 个点为止 由于每次集合总数增加 $1$，因此一共做 $n-1$ 次以上流程。 Q &amp; AQ1：如何求最小割隔开的两个集合？ A1：由于最小割上的边一定将流量限制流满了，因此从 $s$ 开始，通过未流满流量限制的边遍历到的且在当前集合中的点为与 $s$ 联通的点集合，剩下的点与 $t$ 联通的点集合。 Q2：用什么算法求最大流啊？会被卡吗？ A2：根据相关法律法规，ISAP和Dinic受到保护，应该不会被卡，EK死就死了。当然你愿意写HLPP也不拦着。 用途可以得到任意点对间的最小割，通常用于预处理。 例题 luogu P4897 【模板】最小割树（Gomory-Hu Tree） 【最小割树】[CQOI 2016] BZOJ 4519 不同的最小割 【最小割树】[ZJOI 2011] BZOJ 2229 最小割","link":"/Gomory-Hu-Tree/"},{"title":"「FJWC 2019」FZOJ 184 签到题","text":"给定序列 $A[1 \\cdots N]$，有 $M$ 次操作。每次修改 $A[p]=x$，修改后询问最小的 $y$ 满足新序列 $B[i]=A[i] \\oplus y$ 单调递增，无解输出 -1。 $N,M\\leq 10^6,A_i,x\\leq 2^{30}$ 分析记 $F(x,i)$ 表示 $x$ 二进制分解后第 $i$ 位的值，$S_{a,b}$ 为满足 $[F(a,x)\\not=F(b,x)]$ 的 $x$ 的集合，$G(a,b)=\\max{S_{a,b}}$。那么通过第 $G(a,b)$ 位的大小关系即可判定$a,b$ 的大小关系。 统计 $Cnt[x][0]$ 为所有满足 $G(A[i],A[i+1])=x$，且 $F(A[i],x)&lt;F(A[i+1],x)$ 的个数。同理 $Cnt[x][1]$ 为满足 $F(A[i],x)&gt;F(A[i+1],x)$ 的个数。 那么求最小的 $y$ 只需要从最高位向下贪心。对于当前位 $i$，若存在 $Cnt[i][0]&gt;0$ 且 $Cnt[i][1]&gt;0$，则无解，因为无论这一位是否异或，都会存在若干个 $A[i]&gt;A[i+1]$。若 $Cnt[i][1]&gt;0$ 且 $Cnt[i][0]=0$，则这一位必须异或， $y$ 增加 $2^i$。 修改 $A[p]=x$，只影响 $(p-1,p)$ 和 $(p,p+1)$，那么先删去这两对原先对 $Cnt$ 的贡献，再重新加入即可。 复杂度 $O((N+M)\\log{N})$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* * @Author: Skqliao * @Source: FJWC 2019 * @Problem: #184. 「2019冬令营提高组」签到题 * @Url: http://218.5.5.242:9021/problem/184 * @Date: 2019-03-03 09:33:27 * @LastEditTime: 2019-03-03 10:03:11 */#include &lt;bits/stdc++.h&gt;void open() { freopen(\"sort.in\", \"r\", stdin); freopen(\"sort.out\", \"w\", stdout);}char gc() { static char In[1 &lt;&lt; 23], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, 1 &lt;&lt; 23, stdin); } return at == en ? EOF : *at++;}int gt() { char c = gc(); while (!isdigit(c)) c = gc(); int x = 0; for (; isdigit(c); c = gc()) x = x * 10 + c - '0'; return x;}const int MAXN = 1e6 + 5;const int LOG = 30 + 1;int N;std::bitset&lt;LOG&gt; A[MAXN];int Cnt[LOG][2];int solve() { int x = 0; for (int d = 0; d &lt; LOG; d++) { if (Cnt[d][1]) { if (Cnt[d][0]) { return -1; } else { x += (1 &lt;&lt; d); } } } return x;}void update(int l, int r, int x) { for (int i = l + 1; i &lt;= r; i++) { int d = LOG - 1; while (d &gt;= 0 &amp;&amp; A[i - 1][d] == A[i][d]) d--; if (d &gt;= 0) Cnt[d][A[i - 1][d]] += x; }}int main() { open(); N = gt(); for (int i = 1; i &lt;= N; i++) A[i] = gt(); update(1, N, 1); printf(\"%d\\n\", solve()); int Q = gt(); while (Q--) { int x = gt(), y = gt(); int l = std::max(1, x - 1), r = std::min(N, x + 1); update(l, r, -1); A[x] = y; update(l, r, 1); printf(\"%d\\n\", solve()); } return 0;}","link":"/FZOJ-184/"},{"title":"「IOI2003」Trail Maintenance","text":"起初图有 $N$ 个点，没有边。共进行 $M$ 次操作，每次增加一条有边权的无向边，并查询图的连通情况。若图连通，求最小生成树的权值和，若不联通，输出 $-1$ 。 $N\\leq 200,M\\leq 6000$ 。 分析如果每次求一遍最小生成树，复杂度为 $O(M^2\\log{N})$ ，按照当时评测机的运行能力显然是不能通过的。 首先判断图的连通情况，只需要通过并查集维护集合的元素个数，如果小于 $N$，直接输出 $-1$ 。 当第一次得到连通图的时候，利用MST的一种算法计算得到权值和， 复杂度 $O(M\\log{N})$ 。 树上再增加一条边，就一定会出现环，那么删去该环上的任意一条边就能得到一棵新的生成树。由于我们要得到的是最小生成树，所以删去环上权值最大的边即可满足要求。 也就说后面的操作即“破环”法，通过DFS实现。即通过无向图中环上两点，遍历该环上所有边，并找到权值最大的边，完成替换，复杂度为 $O(M)$。 那么总复杂度为 $O(M\\log{N}+M^2)$ 。 题库链接由于暂时没有找到国内OJ可以测这道题，听说LOJ暑假结束前要增加往年IOI试题，我对此表示期待。 俄罗斯的yandex OJ有历年的IOI原题，本题的链接为https://contest.yandex.ru/ioi/contest/558/problems/， 请注意一定要使用std::cout和std::endl，否则会出现Idleness limit exceeded的情况。 当然也可以选择自行下载官方数据并使用lemon等工具评测，IOI2003的数据链接为http://www.ioinformatics.org/locations/ioi03/contest/， 将ioi03替换成其它时间可以得到其它年IOI的数据，如ioi05。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;typedef std::pair&lt;int, int&gt; pii;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }const int MAXN = 6000 + 5;struct Edge { int u, v, w, mrk, nxt;} E[MAXN &lt;&lt; 1];int N, M;int sum, tot;int H[MAXN], cntE = -1;int Anc[MAXN], Rnk[MAXN];void init() { rep(i, 1, N + 1) { Anc[i] = i; Rnk[i] = 1; }}int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) { x = findAnc(x), y = findAnc(y); if (x == y) { return false; } if (Rnk[x] &lt; Rnk[y]) { Anc[x] = y; } else { Anc[y] = x; if (Rnk[x] == Rnk[y]) { ++Rnk[x]; } } return true;}void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, 0, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {v, u, w, 0, H[v]}; H[v] = cntE; tot += merge(u, v);}int Prim() { static std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt; &gt; Pq; static int Vis[MAXN], Dis[MAXN], Id[MAXN]; memset(Vis, 0, sizeof Vis); memset(Dis, 0x3f, sizeof Dis); Dis[1] = 0; Pq.push(std::make_pair(0, 1)); int cnt = 0, sum = 0; while (!Pq.empty() &amp;&amp; cnt &lt; N) { pii x = Pq.top(); Pq.pop(); if (!chkMax(Vis[x.second], 1)) { continue; } if (E[Id[x.second]].w == x.first) { E[Id[x.second]].mrk = 1; E[Id[x.second] ^ 1].mrk = 1; } sum += x.first; ++cnt; for (int i = H[x.second]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (chkMin(Dis[v], E[i].w)) { Id[v] = i; Pq.push(std::make_pair(Dis[v], v)); } } } return sum;}int Vis[MAXN];int dfs(int id, int x, int v) { Vis[x] = 1; if (id &gt;=0 &amp;&amp; E[id].v == v) { return id; } else { for (int i = H[x]; ~i; i = E[i].nxt) { if (E[i].mrk &amp;&amp; !Vis[E[i].v]) { int res = dfs(i, E[i].v, v); if (res != -1) { if (E[res].w &lt; E[i].w) { return i; } else { return res; } } } } } return -1;}int cal(int u, int v, int w) { if (!sum) { sum = Prim(); } else { memset(Vis, 0, sizeof Vis); Vis[u] = 1; int id = dfs(-1, u, v); if (E[id].w &gt; w) { addEdge(u, v, w); sum = sum - E[id].w + w; E[id].mrk = E[id ^ 1].mrk = 0; E[cntE].mrk = E[cntE ^ 1].mrk = 1; } } return sum;}int main() { int u, v, w; memset(H, -1, sizeof H); scanf(\"%d%d\", &amp;N, &amp;M); init(); rep(i, 0, M) { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); if (tot != N - 1) { addEdge(u, v, w); } if (tot != N - 1) { puts(\"-1\"); } else { printf(\"%d\\n\", cal(u, v, w)); } } return 0;}","link":"/IOI2003-Trail Mainrenance/"},{"title":"「CEOI 2004」JZOJ 1131 锯木场选址","text":"数轴从左到右有 $n + 1$ 点，每个点有 $A_i$ 个人，相邻两点距离为 $B_i$。一个人移动 $1$ 的花费为 $1$。第 $n + 1$ 个点为集合点，现可以在前 $n$ 个点中再选择两个点作为集合点，如此一共有三个集合点。所有人必须向右移动到某一个集合点中，求所有人移动花费总和的最小值。 $n\\leq 20000$ 分析记 $D(i)$ 为点 $1$ 和点 $i$ 间的距离，$G(i,j)$ 为将点 $[i,j]$ 的人移动到 $j$ 的花费，则 $G(x,y)=\\sum\\limits_{x\\leq i\\leq y}{(D(y)-D(i))\\cdot A(i)}$。 若当前选择点 $i$ 为第二个集合点，点 $j(1\\leq j &lt; i)$ 为第一个集合点，则总花费为 $\\min\\limits_{1\\leq i &lt; j}(G(1,j)+G(j+1,i)+G(i+1,n+1))$。 设 $X(i)=\\sum\\limits_{j=1}^{i}{A(j)\\cdot D(j)}$，$Y(i)=\\sum\\limits_{j=1}^{i}{A(j)}$，则 $G(x,y)=D(y)(Y(y)-Y(x-1))-X(y)+X(x-1)$。 若从点 $j$ 转移比从点 $k(1\\leq j &lt; k &lt; i)$ 转移更优，则需要满足：$G(1,j)+G(j+1,i)+G(i+1,n+1) &lt; G(1,k)+G(k+1,i)+G(i+1,n+1)$，移项整理可得 $\\frac{D(j)Y(j)-D(k)Y(k)}{Y(j)-Y(k)} &gt; D(i)$。 $D(i)$ 单调递增，左式与 $i$ 无关，称之为 $j,k$ 点间的斜率。因此可以斜率优化DP。 维护单调队列，求当前点 $i$ 时，队内元素 $q_1 &lt; q_2 &lt; \\cdots q_m$ 满足相邻两点 $q_i,q_j$ 的斜率大于 $D(i)$，且斜率单调递增。 复杂度 $O(n)$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041/* * @Author: Skqliao * @Source: CEOI 2004 * @Problem: 1131. 【CEOI2004】锯木场选址Two(踢我) * @Url: https://jzoj.net/senior/#main/show/1131 * @Date: 2019-02-23 11:47:58 * @LastEditTime: 2019-02-23 16:36:42 */#include &lt;bits/stdc++.h&gt;const int MAXN = 20000 + 5;int N;long long A[MAXN], B[MAXN], D[MAXN], X[MAXN], Y[MAXN];int Que[MAXN], qh, qt;long long cost(int l, int r) { return D[r] * (Y[r] - Y[l - 1]) - (X[r] - X[l - 1]); }double cal(int x, int y) { return (double)(D[x] * Y[x] - D[y] * Y[y]) / (Y[x] - Y[y]); }int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%lld%lld\", &amp;A[i], &amp;B[i]); } for (int i = 1; i &lt;= N + 1; ++i) { Y[i] = Y[i - 1] + A[i]; D[i] = D[i - 1] + B[i - 1]; X[i] = X[i - 1] + D[i] * A[i]; } Que[qt++] = 0; long long ans = LLONG_MAX; for (int i = 1; i &lt;= N; ++i) { while (qt - qh &gt; 1 &amp;&amp; cal(Que[qh], Que[qh + 1]) &lt;= D[i]) ++qh; ans = std::min(ans, cost(1, Que[qh]) + cost(Que[qh] + 1, i) + cost(i + 1, N + 1)); while (qt - qh &gt; 1 &amp;&amp; cal(Que[qt - 2], Que[qt - 1]) &gt;= cal(Que[qt - 1], i)) --qt; Que[qt++] = i; } printf(\"%lld\\n\", ans); return 0;}","link":"/JZOJ-1131/"},{"title":"JZOJ 5060 公路建设","text":"有 $n$ 个点， $m$ 条边， $q$ 个询问。每次给定一个区间 $[l_i,r_i]$，求这些边构成的图在保证联通块个数最小的情况下所需最小花费。 $n\\leq 100,m\\leq 100000,q\\leq 15000$ 分析将题意翻译一下就是求区间最小生成树的权值。 假设已知 $[l,m]$ 和 $[m+1,r]$ 的最小生成树，那么 $[l,r]$ 的mst显然是由这两棵mst中的边构成的。 具体地说，在线段树中，通过Kruskal保存子区间mst上的所有边，然后用归并排序合并两个子区间的边，并再做kruskal求出父亲节点的mst上的所有边。查询时按照同样方法合并答案。 复杂度 $O(n\\alpha(n)(m\\log{m}+q\\log{m}))$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 16:40:30 * @LastEditTime: 2019-01-26 17:12:13 * @Source: GDOI2017第二轮模拟day1 * @Problem: JZOJ 5060 公路建设 * @Url: https://jzoj.net/senior/#main/show/5060 */#include &lt;bits/stdc++.h&gt;void open() { freopen(\"highway.in\", \"r\", stdin); freopen(\"highway.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int MAXM = 100000 + 5;int N, M, Q;struct Node { int u, v, w; bool operator &lt; (const Node &amp;x) const { return w &lt; x.w; }} A[MAXM], T[MAXM &lt;&lt; 2][MAXN], Tmp[MAXN &lt;&lt; 1];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Len[MAXM &lt;&lt; 2];int Anc[MAXN];int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) { x = findAnc(x), y = findAnc(y); if (x != y) { Anc[y] = x; return true; } return false;}void pushUp(int x, int l, int r) { int len = std::merge(T[l], T[l] + Len[l], T[r], T[r] + Len[r], Tmp) - Tmp; for (int i = 1; i &lt;= N; ++i) { Anc[i] = i; } Len[x] = 0; for (int i = 0; i &lt; len; ++i) { if (merge(Tmp[i].u, Tmp[i].v)) { T[x][Len[x]++] = Tmp[i]; } }}void build(int rt, int l, int r) { if (l == r) { Len[rt] = 1; T[rt][0] = A[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt, rt &lt;&lt; 1, rt &lt;&lt; 1 | 1);}void query(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { pushUp(0, rt, 0); return ; } int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { query(LT, a, b); } if (m &lt; b) { query(RT, a, b); }}int main() { open(); scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;Q); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;A[i].u, &amp;A[i].v, &amp;A[i].w); } build(1, 1, M); int l, r; while (Q--) { long long sum = 0; scanf(\"%d%d\", &amp;l, &amp;r); Len[0] = 0; query(1, 1, M, l, r); for (int i = 0; i &lt; Len[0]; ++i) { sum += T[0][i].w; } printf(\"%lld\\n\", sum); } return 0;}","link":"/JZOJ-5060/"},{"title":"LOJ 6000 搭配飞行员","text":"有$N$ 个点，其中编号为$1-M$ 的点可以和编号为 $M+1-N$ 的点匹配。 已知所有允许的匹配点对 $(a,b)$ ，求最大匹配数，并输出配对方案。 如果不存在，输出No Solution! 。 $1\\leq M\\leq N\\leq 100$ 分析裸的二分图最大匹配。 考虑匈牙利算法，复杂度 $O(n\\times m)$ ，复杂度有点高（虽然也能跑过）。 考虑Hopcroft-Karp算法，复杂度 $O(\\sqrt{n}\\times m)$ ，但是我不会写。 考虑最大流算法。 根据陈胤伯的集训队论文《浅谈图的匹配算法及其应用》，得知利用Dinic算法进行二分图最大匹配的复杂度亦为 $O(\\sqrt{n}\\times m)$ ，遂选择之。 建图方法很简单，新建源点 $S$ 和汇点 $T$ ，$S$ 、 $T$ 分别与二分图的两部分的每个点连接流量限度为 $1$ 的边， 可以匹配的点对 $(a,b)$ 亦连接流量限制为 $1$ 的边。跑得 $S-T$ 最大流即原二分图最大匹配数。 至于匹配方案，根据残余网络，输出所有剩余流量为 $0$ 且不与 $S、T$ 相连的边的点对即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { register T x; std::cin &gt;&gt; x; return x;}#elseconst int MAXSIZE = 1 &lt;&lt; 22;int EN = 1;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EN = EOF : *at++;}template &lt;class T&gt; inline T gt() { register char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} register bool f = c == '-'; register T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}#endif} // namespace ionamespace dinic {const int MAXN = 100 + 5;const int MAXM = 10000 + 5;const int INF = INT_MAX;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int N, M, S, T, flow, ffffc, tim;int H[MAXN], cntE;int Dis[MAXN], Cur[MAXN], Lv[MAXN];int Flow[MAXM &lt;&lt; 1];bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for (Que[qt++] = S; qh &lt; qt;) { int &amp;u = Que[qh++]; if (u == T) { return true; } else { for (int i = H[u]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; Lv[v] != tim) { Dis[v] = Dis[u] + 1; Lv[v] = tim; Que[qt++] = v; } } } } return false;}void addEdge(int u, int v, int f = 1) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}void init() { M = io::gt&lt;int&gt;(), N = io::gt&lt;int&gt;(); S = 0, T = N + 1; cntE = -1; memset(H, -1, sizeof H); while (io::EN == 1) { int x = io::gt&lt;int&gt;(), y = io::gt&lt;int&gt;(); if (x &gt; y) std::swap(x, y); addEdge(x, y); } rep(i, 1, M + 1) { addEdge(S, i); } rep(i, M + 1, N + 1) { addEdge(i, T); }}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f &amp;&amp; Lv[v] == tim) { int flow = dfs(v, std::min(E[i].f, left)); if (!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}int dinic() { int ans = 0; while (true) { while (bfs()) { memcpy(Cur, H, sizeof(int) * (N + 1)); int res = dfs(S, INF); ans += res; } if (!ffffc) { break; } rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof(int) * (cntE + 1)); ffffc = 0; } return ans;}void match() { init(); printf(\"%d\\n\", dinic());}} // namespace dinicint main() { dinic::match(); return 0;}","link":"/LOJ-6000/"},{"title":"LOJ 6001 太空飞行计划","text":"有 $n$ 个集合，选择第 $i$ 个集合可以获得 $C_i$ 的收益，但是必须购买其中包含的所有元素（不同集合中出现的相同元素只需要购买一次），购买 第 $j$ 个元素的花费为 $A_j$ 。 求最大收益，以及选择的集合及其包含的所有元素。 $1\\leq n\\leq 50$、$1\\leq m\\leq 100$。 分析将 $n$ 个集合看作二分图的 $X$ 集合中的顶点，所有元素作为二分图的 $Y$ 集合中的结点。 - $S$ 向 $X_i$ 连接一条边权为 $C_i$ 的有向边 - $Y_i$ 向 $T$ 连接一条边权为 $A_i$ 的有向边 - 对所有集合包含元素的点对 $(X_i, Y_j)$ （元素 $j$ 在集合 $i$ 中） 连接一条边权为无限的有向边求原图的最大流 $MaxFlow$ ，以及总收益 $Total = \\sum{C_i}$。那么最大收益为 $MaxFlow - Total$。 那么找到选择的集合与所有元素，即找到跑满流的边所连接的顶点。 即最后一次增广经过的所有结点。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace dinic {const int MAXN = 200 + 5;const int MAXM = MAXN * MAXN;struct Edge { int v, f, nxt;}E[MAXM &lt;&lt; 1];int n, m, S, T, ffffc, tim;int Dis[MAXN], Lv[MAXN];int H[MAXN], cntE;int Cur[MAXN], Flow[MAXM &lt;&lt; 1];int B[MAXN], tot;void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}std::string str;int cur;int gt() { int x = 0, flag = false; while(cur &lt; SZ(str) &amp;&amp; !isdigit(str[cur])) { ++cur; } rep(i, cur, SZ(str)) { if(!isdigit(str[i])) { break; } x = x * 10 + str[i] - '0'; flag = true; cur = i + 1; } return flag ? x : -1;}void init() { cntE = -1; memset(H, -1, sizeof H); std::getline(std::cin, str); m = gt(), n = gt(); S = 0, T = n + m + 1; int x; rep(i, 1, m + 1) { cur = 0; std::getline(std::cin, str); addEdge(S, i, B[i] = gt()); tot += B[i]; while(true) { if((x = gt()) == -1) { break; } addEdge(i, m + x, INT_MAX); } } rep(i, 1, n + 1) { std::cin &gt;&gt; x; addEdge(m + i, T, x); }}bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for(Que[qt++] = S; qh &lt; qt;) { int &amp;x = Que[qh++]; if(x == T) { return true; } for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(Lv[v] != tim &amp;&amp; E[i].f) { Lv[v] = tim; Dis[v] = Dis[x] + 1; Que[qt++] = v; } } } return false;}int dfs(int x, int maxf) { if(x == T || !maxf) { return maxf; } int left = maxf; for(int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if(!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if(!left) { return maxf; } } } } return maxf - left;}int dinic() { int flow = 0; while(true) { while(bfs()) { memcpy(Cur, H, sizeof H); int f = dfs(S, INT_MAX); flow += f; } if(!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof(int) * (cntE + 1)); } rep(i, 1, m + 1) { if(Lv[i] == tim) { std::cout &lt;&lt; i &lt;&lt; \" \"; } } std::cout &lt;&lt; std::endl; rep(i, m + 1, n + m + 1) { if(Lv[i] == tim) { std::cout &lt;&lt; i - m &lt;&lt; \" \"; } } std::cout &lt;&lt; std::endl; return tot - flow;}int maxflow() { init(); return dinic();}}int main() { std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cout &lt;&lt; dinic::maxflow() &lt;&lt; std::endl; return 0;}","link":"/LOJ-6001/"},{"title":"LOJ 6004 圆桌聚餐","text":"有 $N$ 个单位分别有 $A_i$ 个代表，有 $M$ 张餐桌，分别可容纳 $B_i$ 个人。 不存在同一个单位的两名代表再同一张餐桌上，求是否存在分配方案可以满足该要求。 如果有，输出每个单位各个代表的餐桌编号。 $1\\leq m\\leq150, 1\\leq n\\leq 270$ 分析比较明显转化成最大流问题。 $S,T$ 分别和各个单位和餐桌连边，流量限制为$A_i,B_i$ 。 单位和餐桌之间连接流量限制为 $1$ 的边。 如果$S-T$ 最大流和 $\\sum{A_i}$ 相等，则说明存在分配方案，反之不存在。 至于具体编号，考虑第 $i$ 个单位，如果与它相连的边流量限制剩余 $0$ 且不是 $S$ ，则说明存在流量增广，输出边对应点即为餐桌编号。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace dinic {const int MAXN = 500 * 2 + 5;const int MAXM = MAXN * MAXN;struct Edge { int v, nxt, f;} E[MAXM &lt;&lt; 1];int M, N, S, T, F, ffffc, tim, total;int H[MAXN], cntE;int Flow[MAXM], Dis[MAXN], Cur[MAXN], Lv[MAXN];void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, H[u], f}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v], 0}; H[v] = cntE;}bool bfs() { static std::queue&lt;int&gt; Que; Que.push(S); Dis[S] = 0; Lv[S] = ++tim; while (!Que.empty()) { int x = Que.front(); Que.pop(); if (x == T) { return true; } for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] != Lv[x] &amp;&amp; E[i].f) { Lv[v] = Lv[x]; Dis[v] = Dis[x] + 1; Que.push(v); } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int f = dfs(v, std::min(E[i].f, left)); if (!f) { Dis[v] = -1; } else { left -= f; E[i].f -= f; Flow[i ^ 1] += f; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}void init() { int x; memset(H, -1, sizeof H); cntE = -1; std::cin &gt;&gt; M &gt;&gt; N; S = N + M, T = N + M + 1; rep(i, 0, M) { std::cin &gt;&gt; x; total += x; addEdge(S, i, x); rep(j, 0, N) { addEdge(i, j + M, 1); } } rep(i, 0, N) { std::cin &gt;&gt; x; addEdge(M + i, T, x); }}void dinic() { init(); while (true) { while (bfs()) { memcpy(Cur, H, sizeof H); F += dfs(S, INT_MAX); } if (!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof Flow); } if(total != F) { std::cout &lt;&lt; 0 &lt;&lt; std::endl; } else { std::cout &lt;&lt; 1 &lt;&lt; std::endl; rep(i, 0, M) { for(int j = H[i]; ~j; j = E[j].nxt) { if(!E[j].f &amp;&amp; E[j].v &gt;= M) { std::cout &lt;&lt; E[j].v + 1 - M &lt;&lt; \" \"; } } std::cout &lt;&lt; std::endl; } }}}int main() { dinic::dinic(); return 0;}","link":"/LOJ-6004/"},{"title":"LOJ 6002 最小路径覆盖问题","text":"给一个 $N$ 个点， $M$ 条边的DAG，求最小路径覆盖数及其方案。 $1\\leq N\\leq 150,1\\leq M\\leq 6000$ 分析弱化版【P2765 魔术球问题】 随便搞即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace dinic {const int MAXN = 500 + 5;const int MAXM = 6000 + 5;struct Edge { int v, f, nxt;}E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Flow[MAXM &lt;&lt; 1], Cur[MAXN], Lv[MAXN], Dis[MAXN];int N, M, S, T, K = 100, ffffc, tim;void addEdge(int u, int v, int f = 1) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for (Que[qt++] = S; qh &lt; qt;) { int &amp;x = Que[qh++]; if (x == T) { return true; } for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] != tim &amp;&amp; E[i].f) { Lv[v] = tim; Dis[v] = Dis[x] + 1; Que[qt++] = v; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}int dinic() { int F = 0; while (true) { while (bfs()) { memcpy(Cur, H, sizeof H); F += dfs(S, INT_MAX); } if (!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof(int) * (cntE + 1)); } return F;}void init() { cntE = -1; memset(H, -1, sizeof H); scanf(\"%d%d\", &amp;N, &amp;M); S = 0, T = 500; int u, v; rep(i, 1, N + 1) { addEdge(S, i); addEdge(i + K, T); } rep(i, 0, M) { scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v + K); }}std::bitset&lt;MAXN&gt; Vis;int Match[MAXN];void maxFlow() { init(); int ans = N - dinic(); rep(i, K + 1, K + N + 1) { for(int j = H[i]; ~j; j = E[j].nxt) { if(E[j].f &amp;&amp; E[j].v != T) { Match[E[j].v] = i - K; break; } } } rep(i, 1, N + 1) { if(Vis[i]) { continue; } for(int j = i; j; j = Match[j]) { printf(\"%d \", j); Vis[j] = true; } printf(\"\\n\"); } printf(\"%d\\n\", ans);}}int main() { dinic::maxFlow(); return 0;}","link":"/LOJ-6002/"},{"title":"LOJ 6005 最长递增子序列","text":"有一个长度为 $N$ 的序列 $A$，求解以下询问： 最长不下降子序列的长度 $K$ 原序列最多可以取出长度为 $K$ 的不下降子序列的个数 （每个数只能用一次） 如果 $A_1$ 和 $A_N$ 可以取无数次，再求第二问 $1\\leq N\\leq 500$ 分析第一问，随便 $O(N ^2)$ dp一下即可。 第二问，由于每个数只能用一次，那么基本思想还是拆点。将每个点拆成 $B_i$ 和 $C_i$ ，即结点 $i$ 选择前和选择后的两种状态。 记 $F_i$ 为以 $A_i$ 为结尾的最长不下降子序列的长度。 首先，源点 $S$ 和所有 $B_i$ 满足 $F_i = 1$ 的结点相连。同理，所有 $C_i$ 满足 $F_i = K$ 的结点和 $T$ 相连。流量限制为 $1$ 。 对于一个合法的子序列，相邻元素一定满足 $A_i \\geq A_j$ 且 $F_i = F_j + 1(j&lt; i)$ 。 那么对满足这种条件的点对 $(i,j)$ 便需要连一条 $(C_j, B_i)$ 的边，流量限制为 $1$ ，意为选择 $j$ 后可以再选择 $i$ 作为后继。 当然， $B_i$ 和 $C_i$ 也有一条流量限制为 $1$ 的边，因为选择结点 $i$ 之后，状态便由未选择转移到了选择完。 跑 $S-T$ 最大流即为第二问结果。 对于第三问，很显然的做法便是放开对结点 $1$ 和结点 $N$ 的限制。将原来流量限制为 $1$ 的边修改为 $INF$ 即可（或者直接加新边）。 需要注意的几点细节： 对于单调下降的序列 $A$， $K = 1$。因此所有结点既满足 $F_i = 1$ 也满足 $F_i = K$，判断和源汇点连边的时候是，注意是if()if()而不是if()else if() 对于第三问的修改操作，直接加边更方便。但是要注意的是，$F_1 = 1$ 是一定成立的，但是 $F_N = K$ 是不一定成立的。所以加边之前需要检查一下是否原图存在边。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 1200 + 5;const int MAXM = MAXN * MAXN;namespace dinic {struct Edge { int v, f, nxt;}E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Flow[MAXM], Dis[MAXN], Lv[MAXN], Cur[MAXN];int N, M, S, T, tim, ffffc, F;void addEdge(int u, int v, int f = 1) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for (Que[qt++] = S; qh &lt; qt;) { int &amp;x = Que[qh++]; if (x == T) { return true; } for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] != tim &amp;&amp; E[i].f) { Lv[v] = tim; Dis[v] = Dis[x] + 1; Que[qt++] = v; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}int dinic() { while (true) { while (bfs()) { memcpy(Cur, H, sizeof H); F += dfs(S, INT_MAX); } if (!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof(int) * (cntE + 1)); } return F;}void init() { memset(H, -1, sizeof H); cntE = -1;}}int A[MAXN], F[MAXN];int main() { int n, ans = 0; scanf(\"%d\", &amp;n); dinic::S = 0, dinic::T = n * 2 + 1; dinic::init(); rep(i, 1, n + 1) { dinic::addEdge(i, i + n); scanf(\"%d\", &amp;A[i]); F[i] = 1; rep(j, 1, i) { if(A[j] &lt;= A[i]) { F[i] = std::max(F[i], F[j] + 1); } } ans = std::max(ans, F[i]); } rep(i, 1, n + 1) { rep(j, 1, i) { if(A[i] &gt;= A[j] &amp;&amp; F[i] == F[j] + 1) { dinic::addEdge(j + n, i); } } } rep(i, 1, n + 1) { if(F[i] == 1) { dinic::addEdge(dinic::S, i); } if(F[i] == ans) { dinic::addEdge(i + n, dinic::T); } } printf(\"%d\\n\", ans); printf(\"%d\\n\", dinic::dinic()); dinic::addEdge(dinic::S, 1, INT_MAX); dinic::addEdge(1, 1 + n, INT_MAX); dinic::addEdge(n, n + n, INT_MAX); if(F[n] == ans) { dinic::addEdge(n + n, dinic::T, INT_MAX); } printf(\"%d\\n\", dinic::dinic()); return 0;}","link":"/LOJ-6005/"},{"title":"LOJ 6007 方格取数","text":"有一个 $N\\times M$ 的矩阵，第 $i$ 行 第 $j$ 列的元素值为 $A_{i,j}$。 现想从中选择任意多个数，使得权值和最大，要求选择的任意两个数在原矩阵中不相邻。 输出最大的权值和即可，无需具体方案。 $1\\leq N,M\\leq 100$ 分析首先将原图进行黑白染色，显然任意一个格子被选择后，都不能选择相邻的异色格子。这是一个二分图。 将每个格子与周围的异色格子连一条边，原问题转化为求二分图的最大点权独立集，即选择的任意两点没有边相连，且要求集合中的点权和最大。 对于这种问题，解法为： - 构造源点 $S$，连接 $S$ 和 $X_i$，流量限制置为 $A_{X_i}$ - 构造汇点 $T$，连接 $Y_i$ 和 $T$，流量限制置为 $A_{Y_i}$ - 原 $X_i$ 和 $Y_j$ 相连的边，流量限制置为 $INF$ 那么最大点权独立集（maximum weight vertex independent set,MaxWVIS），即为点权和与最大流的差。 简单的理解就是说边 $S-X_i$ 和 $Y_j-T$ ，视作选择 $X_i/Y_j$ 的代价。那么在总收益一定的前提下（即总边权和），总代价最小即最后收益最大。 根据最大流最小割定理，最大流即为最小割。对于任意一条$S-X_i-Y_j-T$ 的增广路径，被割掉的边要么为 $S-X_i$，要么为 $Y_i-T$ 。 割最小，即总代价最小，即总收益最大。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 100 * 100 + 5;const int MAXM = MAXN * 10 + 5;namespace dinic {struct Edge { int v, f, nxt;}E[MAXM &lt;&lt; 1];int N, M, S, T, tim, ffffc;int Flow[MAXM &lt;&lt; 1], Cur[MAXN], Lv[MAXN], Dis[MAXN];int H[MAXN], cntE;void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for (Que[qt++] = S; qh &lt; qt;) { int &amp;x = Que[qh++]; if (x == T) { return true; } for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] != tim &amp;&amp; E[i].f) { Lv[v] = tim; Dis[v] = Dis[x] + 1; Que[qt++] = v; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}int dinic() { int F = 0; while (true) { while (bfs()) { memcpy(Cur, H, sizeof H); F += dfs(S, INT_MAX); } if (!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof(int) * (cntE + 1)); } return F;}int init() { cntE = -1; memset(H, -1, sizeof H); std::cin &gt;&gt; N &gt;&gt; M; S = 0, T = N * M + 1; int x, sum = 0; rep(i, 1, N + 1) { rep(j, 1, M + 1) { std::cin &gt;&gt; x; sum += x; int cur = (i - 1) * M + j; if((i + j) &amp; 1) { addEdge(S, cur, x); if(j != 1) { addEdge(cur, cur - 1, INT_MAX); } if(j != M) { addEdge(cur, cur + 1, INT_MAX); } if(i != 1) { addEdge(cur, cur - M, INT_MAX); } if(i != N) { addEdge(cur, cur + M, INT_MAX); } } else { addEdge(cur, T, x); } } } return sum;}int maxFlow() { int sum = init(); return sum - dinic();}}int main() { std::cout &lt;&lt; dinic::maxFlow() &lt;&lt; std::endl; return 0;}","link":"/LOJ-6007/"},{"title":"LOJ 6008 餐巾计划","text":"共 $n$ 天，每天需要 $R_i$ 块干净的纸巾。纸巾用完一次就脏了，可以选择清洗后使用或不再使用。 已知新买纸巾的价格为 $p$ ，花 $m$ 天快洗纸巾的价格为 $f$ ，花 $n$ 天慢洗纸巾的价格为 $s$ 。 求最小花费。 $n \\leq 2000$，$R_i \\leq 10^7$，$p,f,s \\leq 10^4$ 。 分析考虑网络流算法。 第一天为源点 $S$ ，最后一天为汇点 $T$ ，纸巾为流量，价格为费用。 通过简单贪心可以得到每天的干净纸巾刚好为所需要的数量时，总花费一定最小。 由此问题转化为求建图后跑满流的情况下的最小费用。 最小费用最大流。 考虑如何使得满足每天恰好使用 $R_i$ 块纸巾。 将每天拆成两个点，即使用前 $X_i$ 和使用后 $Y_i$。 建图方法如下（$(c, f)$ 即费用为 $c$、流量为 $f$ 的边）： $S$ 与$X_i$ 连接一条$(0, V_i)$ 的边，即第 $i$ 天纸巾需要的数量； $Y_i$ 与 $T$ 连接一条 $(0, V_i)$ 的边，即第 $i$ 天使用的纸巾的数量； $S$ 与 $Y_i$ 连接一条 $(p, inf)$ 的边，即第 $i$ 天购买新纸巾，花费为 $p$ ； $X_i$ 与 $X_{i+1}$ 连接一条 $(0, inf)$ 的边，即第 $i$ 天没用完的纸巾留给第 $i + 1$ 天，没有费用； $X_i$ 与 $Y_{i+m}$ 连接一条 $(f, inf)$ 的边，即第 $i$ 天快洗后的纸巾第 $i+m$ 天拿到干净纸巾，花费为 $f$； $X_i$ 与 $Y_{i+n}$ 连接一条 $(s, inf)$ 的边，即第 $i$ 天慢洗后的纸巾第 $i+n$ 天拿到干净纸巾，花费为 $s$。 由于所有与源点 $S$ 的所有边都与每一个 $X_i$ 相连，由此保证了每天都有 $R_i$ 的流量流入，即 $R_i$ 块新纸巾。 由于所有与汇点 $T$ 的所有边都与 $Y_i$ 相连，由此限制了每天必须有 $R_i$ 的流量流出（因为是跑最大流）。 可以发现所有所有与 $T$ 相连的边 $e$ ，边权和 $\\sum{e_f}=\\sum{R_i}$，保证了最大流为所需纸巾数之和，即上文说道的通过贪心得到最小费用的情况。 至于购买新纸巾，快洗和慢洗就都不难理解了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// Copyright 2018, Skqliao// 最小费用最大流#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { register T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { register char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} register bool f = c == '-'; register T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif} // namespace ionamespace mcmf {const int MAXN = 4000 + 5;const int MAXM = MAXN * 3;const ll INF = LLONG_MAX;struct Edge { int v, nxt; ll c, f;} E[MAXM &lt;&lt; 1];int S, T;int Path[MAXN &lt;&lt; 1], Pre[MAXN &lt;&lt; 1];int H[MAXN &lt;&lt; 1], cntE;void addEdge(int u, int v, ll c, ll f) { E[++cntE] = (Edge) {v, H[u], c, f}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v], -c, 0}; H[v] = cntE;}void init() { cntE = -1; memset(H, -1, sizeof H); int N = io::gt&lt;int&gt;(); S = 0, T = N &lt;&lt; 1 | 1; rep(i, 1, N + 1) { ll f = io::gt&lt;ll&gt;(); addEdge(0, i, 0, f); addEdge(i + N, T, 0, f); } rep(i, 1, N) { addEdge(i, i + 1, 0, INF); } int p = io::gt&lt;int&gt;(); int m = io::gt&lt;int&gt;(), f = io::gt&lt;int&gt;(); int n = io::gt&lt;int&gt;(), s = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { addEdge(0, i + N, p, INF); } rep(i, 1, N - m + 1) { addEdge(i, i + m + N, f, INF); } rep(i, 1, N - n + 1) { addEdge(i, i + n + N, s, INF); }}bool Vis[MAXN];ll Dis[MAXN];bool dijkstra() { std::queue&lt;int&gt; pq; memset(Dis, 0x3f, sizeof Dis); memset(Vis, 0, sizeof Vis); Dis[S] = 0; pq.push(S); while (!pq.empty()) { int x = pq.front(); pq.pop(); Vis[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &gt; 0 &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Path[v] = i, Pre[v] = x; if (!Vis[v]) { pq.push(v); Vis[v] = true; } } } } return Dis[T] != Dis[T + 1];}ll mcmf() { ll cost = 0; init(); while (dijkstra()) { ll f = LLONG_MAX; for (int i = T; i != S; i = Pre[i]) { f = std::min(f, E[Path[i]].f); } cost += f * Dis[T]; for (int i = T; i != S; i = Pre[i]) { E[Path[i]].f -= f; E[Path[i]^1].f += f; } } return cost;}}int main() { printf(\"%lld\\n\", mcmf::mcmf()); return 0;} 体会与心得 选择spfa还是Dijkstra真是玄学，有时前者快得多，有时反之 问题主要在于转换模型，对本题而言核心在于拆点，从而将状态分成两部分 贪心那一步比较显然但是很重要，它使得求解的模型从有上下界的网络流变成了最大流","link":"/LOJ-6008/"},{"title":"LOJ 6009 软件补丁问题","text":"$A$ 是一个数的集合，包含 $n$ 种元素，存在 $m$ 种方法转移。 $A$ 能通过第 $i$ 种方法转移，当且仅当 $A$ 不包含 $C_i$ 中的任何元素且包含 $D_i$ 中的所有元素。 $A$ 通过第 $i$ 种方法转移的方法为：删去 $A$ 中所有与 $E_i$ 相同的元素， 增加所有 $F_i$ 中 $A$ 没有出现的元素。 通过第 $i$ 种方法转移的代价为 $P_i$，开始时 $A$ 包含所有元素，求转移到没有元素的最小代价。如果无解，输出-1。 $1\\leq n\\leq 20,1\\leq m\\leq 100$。 分析考虑暴力转移，每次转移是 $O(n\\times m)$ 的，至多有 $2^n$ 种状态，所以复杂度是 $2^n\\times n\\times m$ 的，发现这么小的数据范围是可以过的。 发现合并、检查集合时比较麻烦，根据 $n\\leq 20$ ，考虑转移状态压缩，用二进制下第 $i$ 位表示第 $i$ 个数是否存在。 位运算转移检查 $C_i$ 即按位与，看结果是否为 $C_i$ 本身。 检查 $D_i$ 还是按位与，看结果是否为 $0$。 通过 $E_i$ 转移，这个是最复杂度的，需要两步。首先按位与得到两方都有的元素，再与原数异或。 通过 $F_i$ 转移，按位或即可。 原理按位与，某一位为 $1$ 当且仅当两数该位同为 $1$ 。 按位或，某一位为 $1$ 当且仅当两数中至少一个数该位为 $1$ 。 异或，某一位为 $1$ 当且仅当两数中一个数该位为 $1$ ，另一个数该位为 $0$。 那么根据转移规则发现就是这三种运算而已，单独解释一下关于 $E_i$ 的转移。 该操作的目的即某一位若两位都是 $1$ ，则置为 $0$ ，其他不变。 那么按位与得到所有同时为 $1$ 的位，再根据 1 ^ 1 = 0 ^ 0 = 0、0 ^ 1 = 1 ^ 0 = 1，可以发现新数与原数异或即可满足要求。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast((x).size())typedef long long ll;const int MAXN = (1 &lt;&lt; 20) + 5;const int MAXM = 100 + 5;int F[MAXN];int n, m, Cost[MAXM];int A1[MAXM], A2[MAXM];int B1[MAXM], B2[MAXM];std::bitset Inq;int main() { std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cin &gt;&gt; n &gt;&gt; m; std::string str1, str2; rep(i, 0, m) { std::cin &gt;&gt; Cost[i] &gt;&gt; str1 &gt;&gt; str2; rep(j, 0, n) { if(str1[j] == '+') { A1[i] |= 1 &lt;&lt; j; } else if(str1[j] == '-') { A2[i] |= 1 &lt;&lt; j; } if(str2[j] == '-') { B1[i] |= 1 &lt;&lt; j; } else if(str2[j] == '+') { B2[i] |= 1 &lt;&lt; j; } } } std::queue Que; memset(F, 0x3f, sizeof F); F[(1 &lt;&lt; n) - 1] = 0; Que.push((1 &lt;&lt; n) - 1); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = 0; rep(i, 0, m) { if((x &amp; A1[i]) == A1[i] &amp;&amp; (x &amp; A2[i]) == 0) { int y = x &amp; B1[i]; y = y ^ x | B2[i]; if(F[y] &gt; Cost[i] + F[x]) { F[y] = Cost[i] + F[x]; if(!Inq[y]) { Inq[y] = 1; Que.push(y); } } } } } if(F[0] == F[1 &lt;&lt; n]) { F[0] = 0; } std::cout &lt;&lt; F[0] &lt;&lt; std::endl; return 0;}","link":"/LOJ-6009/"},{"title":"LOJ 6006 试题库","text":"有 $n$ 个数， $m$ 个属性。第 $i$ 个数有 $A_i$ 个属性，分别为 $B_{i,j}$ 。 从中选择 $k$ 个数，使得这 $m$ 个属性中，第 $i$ 个属性有 $C_i$ 个数。 输出任意一组解的每个属性对应的数，如果无解输出No Solution!。 $2\\leq k\\leq 20, k\\leq n\\leq 1000$ 分析二分图多重匹配。 二分图的 $X_i$ 为这 $n$ 个数， $Y_i$ 为这 $m$ 个属性，建立源点 $S$ 和汇点 $T$。 建图方案： - $S$ 和 $X_i$ 连接一条边权为 $1$ 的有向边 - $X_i$ 和 $Y_i$ 根据属性和数的关系连接边权为 $1$ 的有向边 - $Y_i$ 和 $T$ 连接边权为 $C_i$ 的有向边。 跑 $S-T$ 最大流，方案即为残余网络为 $0$ 的边对应的结点 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace dinic {const int MAXN = 2000 + 5;const int MAXM = 240000 + 5;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Cur[MAXN], Flow[MAXM &lt;&lt; 1];int Dis[MAXN], Lv[MAXN];int N, M, S, T, K, ffffc, tim;void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}void init() { memset(H, -1, sizeof H); cntE = -1; int x, y; std::cin &gt;&gt; K &gt;&gt; N; S = 0, T = N + K + 1; rep(i, 1, K + 1) { std::cin &gt;&gt; x; M += x; addEdge(i + N, T, x); } rep(i, 1, N + 1) { std::cin &gt;&gt; x; while (x--) { std::cin &gt;&gt; y; addEdge(i, y + N, 1); } addEdge(S, i, 1); }}bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for (Que[qt++] = S; qh &lt; qt;) { int &amp;x = Que[qh++]; if (x == T) { return true; } for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] != tim &amp;&amp; E[i].f) { Lv[v] = tim; Dis[v] = Dis[x] + 1; Que[qt++] = v; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}int dinic() { int flow = 0; while (true) { while (bfs()) { memcpy(Cur, H, sizeof H); int f = dfs(S, INT_MAX); flow += f; } if (!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof(int) * (cntE + 1)); } return flow;}void maxflow() { init(); int maxflow = dinic(); if (maxflow != M) { std::cout &lt;&lt; \"No Solution!\\n\"; } else { rep(i, 1, K + 1) { std::cout &lt;&lt; i &lt;&lt; \": \"; for (int j = H[i + N]; ~j; j = E[j].nxt) { if (E[j].f) { std::cout &lt;&lt; E[j].v &lt;&lt; \" \"; } } std::cout &lt;&lt; std::endl; } } return ;}}int main() { dinic::maxflow(); return 0;}","link":"/LOJ-6006/"},{"title":"LOJ 6011 运输问题","text":"有 $N$ 个仓库，库存为 $A_i$，$M$ 个商店，需求为 $B_i$，保证 $\\sum{A_i} =\\sum{B_i}$。 第 $i$ 个仓库每单位运送给第 $j$ 个商店的费用为 $C_{i,j}$。 求满足商店需求所需的最小运费。 $1\\leq n,m\\leq 100$ 分析仓库商店之间，费用建成 $-C_{i,j}$，限制为 $INF$。 $S$ 连接所有仓库，所有商店连接 $T$ ，限制分别为 $A_i$ 和 $B_i$，费用为 $0$。 跑 $S-T$ 最小费用最大流 $C$，答案即为 $-C$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 200 + 5;const int MAXM = 20000 + 5;namespace mcmf {struct Edge { int v, c, f, nxt;}E[MAXM &lt;&lt; 1];int N, M, S, T, C, F;int H[MAXN], cntE;int Lp[MAXN], Le[MAXN], Dis[MAXN];std::bitset&lt;MAXN&gt; Inq;void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE; }bool spfa() { static std::queue&lt;int&gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if(!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;}int X[MAXN], Y[MAXN], Z[MAXN][MAXN];void init() { int x; std::cin &gt;&gt; M &gt;&gt; N; cntE = -1; memset(H, -1, sizeof H); S = 0, T = N + M + 1; rep(i, 1, M + 1) { std::cin &gt;&gt; X[i]; addEdge(S, i, X[i], 0); } rep(i, 1, N + 1) { std::cin &gt;&gt; Y[i]; addEdge(i + M, T, Y[i], 0); } rep(i, 1, M + 1) { rep(j, 1, N + 1) { std::cin &gt;&gt; Z[i][j]; addEdge(i, j + M, INT_MAX, Z[i][j]); } }}void init2() { cntE = -1; memset(H, -1, sizeof H); S = 0, T = N + M + 1; rep(i, 1, M + 1) { addEdge(S, i, X[i], 0); } rep(i, 1, N + 1) { addEdge(i + M, T, Y[i], 0); } rep(i, 1, M + 1) { rep(j, 1, N + 1) { addEdge(i, j + M, INT_MAX, -Z[i][j]); } }}int mcmf() { C = F = 0; while(spfa()) { int f = INT_MAX; for(int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } C += f * Dis[T]; F += f; for(int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } } return C;}}int main() { mcmf::init(); std::cout &lt;&lt; mcmf::mcmf() &lt;&lt; std::endl; mcmf::init2(); std::cout &lt;&lt; -mcmf::mcmf() &lt;&lt; std::endl; return 0;}","link":"/LOJ-6011/"},{"title":"LOJ 6010 数字梯形","text":"一个梯形，第一行有 $m$ 个数，共 $n$ 行，每行比上一行多一个数，每个数有一个权值 $A_i$。 从第一行的 $m$ 个数开始，每次向左下或右下移动，到第 $n$ 层结束。 求以下三种情况的权值和最大值： $m$ 条路径不相交 $m$ 条路径可以在数字处相交 $m$ 条路径可以在数字和边处相交 $1\\leq n,m\\leq 20$ 分析一道三合一，主要考察建图如何去限制流量走向。 对于不相交的情况，很显然，还是拆点 $i\\rightarrow(X_i,Y_i)$，然后每个点的 $X_i$ 向下面的两个点 $Y_j$ 连一条限制为 $1$，费用为 $-A_i$。最后 $S$ 连接第一行，最后一行连接 $T$，跑费用流。 对于可以在数字处相交的情况就可以不用拆点了。直接连接 $(i, j)$，限制为 $1$，费用为 $-A_i$。注意最后一行连接 $T$ 的限制为 $INF$，因为可以多个数最后均到达该点。 对于没有限制的情况，将第二次建图的所有流量限制均改成 $INF$ 即可（$S$ 到第一行除外）。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 3000 + 5;const int MAXM = 40000 + 5;namespace mcmf {struct Edge { int v, c, f, nxt;}E[MAXM &lt;&lt; 1];int N, M, S, T, C, F;int H[MAXN], cntE;int Lp[MAXN], Le[MAXN], Dis[MAXN];std::bitset&lt;MAXN&gt; Inq;void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE; }bool spfa() { static std::queue&lt;int&gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if(!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;}int Z[MAXN][MAXN];int getId(int x, int y) { return (x - 1) * (N + M) + y;}void init() { int x; std::cin &gt;&gt; M &gt;&gt; N; cntE = -1; memset(H, -1, sizeof H); S = 0, T = (N + M) * N * 3; int up = (N + M) * N * 2; rep(i, 1, N + 1) { rep(j, 1, M + i) { std::cin &gt;&gt; Z[i][j]; addEdge(getId(i, j), getId(i, j) + up, 1, 0); } } rep(i, 1, N + 1) { rep(j, 1, M + i) { if(i == 1) { addEdge(S, getId(i, j), 1, 0); } if(i == N) { addEdge(getId(i, j) + up, T, 1, -Z[i][j]); } else { addEdge(getId(i, j) + up, getId(i + 1, j), 1, -Z[i][j]); addEdge(getId(i, j) + up, getId(i + 1, j + 1), 1, -Z[i][j]); } } }}void init2() { cntE = -1; memset(H, -1, sizeof H); rep(i, 1, N + 1) { rep(j, 1, M + i) { if(i == 1) { addEdge(S, getId(i, j), 1, 0); } if(i == N) { addEdge(getId(i, j), T, INT_MAX, -Z[i][j]); } else { addEdge(getId(i, j), getId(i + 1, j), 1, -Z[i][j]); addEdge(getId(i, j), getId(i + 1, j + 1), 1, -Z[i][j]); } } }}void init3() { cntE = -1; memset(H, -1, sizeof H); rep(i, 1, N + 1) { rep(j, 1, M + i) { if(i == 1) { addEdge(S, getId(i, j), 1, 0); } if(i == N) { addEdge(getId(i, j), T, INT_MAX, -Z[i][j]); } else { addEdge(getId(i, j), getId(i + 1, j), INT_MAX, -Z[i][j]); addEdge(getId(i, j), getId(i + 1, j + 1), INT_MAX, -Z[i][j]); } } }}int mcmf() { C = F = 0; while(spfa()) { int f = INT_MAX; for(int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } C += f * Dis[T]; F += f; for(int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } } return C;}}int main() { mcmf::init(); std::cout &lt;&lt; -mcmf::mcmf() &lt;&lt; std::endl; mcmf::init2(); std::cout &lt;&lt; -mcmf::mcmf() &lt;&lt; std::endl; mcmf::init3(); std::cout &lt;&lt; -mcmf::mcmf() &lt;&lt; std::endl; return 0;}","link":"/LOJ-6010/"},{"title":"LOJ 6013 负载平衡","text":"G公司有 $N$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量为 $A_i$。 如何用最少搬运量可以使 $N$ 个仓库的库存数量相同。 搬运货物时，只能在相邻的仓库之间搬运。 $1\\leq N\\leq 100$ 分析两个任务，一是要保证最后每个点的权值相同，二是在此基础上使得总转移量最低。 那么状态量显然也是二维的。 考虑费用流，用流量保证任务一能完成，用费用使得任务二的结果最小。 每个点的最后状态为 $T=\\frac{\\sum{A_i}}{N}$，需要额外流入/转出流量 $|T-A_i|$。 先考虑流量。 常规思路，拆点 $i\\rightarrow(X_i, Y_i)$，即开始和结束两个状态。 建立源点 $S$ 和汇点 $T$，如果 $A_i &lt; T$，连接 $S \\rightarrow X_i$，流量限制为 $T - A_i$，否则连接 $Y_i\\rightarrow T$，流量限制为 $A_i - T$。 如此便保证了跑出最大流之后，每个点的权值最终一定为平均值（对盈余和缺少的流量强制流入流出）。 然后看费用。 每个点只能向左右两个点转移。 有两种情况。 一是，当前转移到 $j$ 的流量只是路过，即 $j$ 是中转站； 二是，转移的流量就是给 $j$ 的，即 $j$ 是目的地。 根据拆点后的状态，显然对于两种情况分别连接 $X_i\\rightarrow X_j$ 和 $X_i\\rightarrow Y_j$。 费用为 $1$，流量限制为 $INF$。 对于为了满足任务一建的边，显然费用为 $0$。 $S-T$ 最小费用最大流之最小费用即为答案。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 200 + 5;const int MAXM = 1000 + 5;const int INF = INT_MAX / 3;namespace mcmf {const int MAXN = 200 + 5;const int MAXM = 5000 + 5;struct Edge { int v, f, c, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int N, M, S, T, cost, flow;int Pe[MAXN], Pv[MAXN], Dis[MAXN];bool Inq[MAXN];void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, f, c, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, -c, H[v]}; H[v] = cntE;}bool spfa() { static std::queue&lt;int&gt; Que; memset(Dis, 0x3f, sizeof Dis); memset(Inq, 0, sizeof Inq); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &gt; 0 &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Pe[v] = i, Pv[v] = x; if (!Inq[v]) { Que.push(v); Inq[v] = true; } } } } return Dis[T] != INF;}void init() { static int A[MAXN]; memset(H, -1, sizeof H); cntE = -1; int total = 0; std::cin &gt;&gt; N; rep(i, 1, N + 1) { std::cin &gt;&gt; A[i]; total += A[i]; } total /= N; S = 0, T = N * 2 + 1; rep(i, 1, N + 1) { if(A[i] &lt; total) { addEdge(S, i, total - A[i], 0); } else { addEdge(i + N, T, A[i] - total, 0); } int lst = i - 1, nxt = i + 1; if(i != 1) { addEdge(i, lst, INF, 1); addEdge(i, lst + N, INF, 1); } if(i != N) { addEdge(i, nxt, INF, 1); addEdge(i, nxt + N, INF, 1); } } addEdge(1, N, INF, 1); addEdge(1, N + N, INF, 1); addEdge(N, 1, INF, 1); addEdge(N, 1 + N, INF, 1);}int mcmf() { init(); while (spfa()) { int f = INT_MAX; for (int i = T; i != S; i = Pv[i]) { f = std::min(f, E[Pe[i]].f); } cost += f * Dis[T]; flow += f; for (int i = T; i != S; i = Pv[i]) { E[Pe[i]].f -= f; E[Pe[i] ^ 1].f += f; } } return cost;}}int main() { std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cout &lt;&lt; mcmf::mcmf() &lt;&lt; std::endl; return 0;}","link":"/LOJ-6013/"},{"title":"LOJ 6012 分配问题","text":"有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{i,j}$ 。 试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最大。 每个人只能做一个工作。 $1\\leq n\\leq 100$ 分析两次建图，限制均为 $1$，费用分别为 $C_{i,j}$ 和$-C_{i,j}$，跑最小费用最大流即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 200 + 5;const int MAXM = 20000 + 5;namespace mcmf {struct Edge { int v, c, f, nxt;}E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int N, M, S, T, C, F;int Lp[MAXN], Le[MAXN];int Dis[MAXN];std::bitset&lt;MAXN&gt; Inq;void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE;}bool spfa() { static std::queue&lt;int&gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if(!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;}int mcmf() { C = F = 0; while(spfa()) { int f = INT_MAX; for(int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } C += f * Dis[T]; F += f; for(int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } } return C;}int Z[MAXN][MAXN];void init() { memset(H, -1, sizeof H); cntE = -1; std::cin &gt;&gt; N; S = 0, T = N * 2 + 1; rep(i, 1, N + 1) { addEdge(S, i, 1, 0); addEdge(i + N, T, 1, 0); rep(j, 1, N + 1) { std::cin &gt;&gt; Z[i][j]; addEdge(i, j + N, 1, Z[i][j]); } }}void init2() { memset(H, -1, sizeof H); cntE = -1; rep(i, 1, N + 1) { addEdge(S, i, 1, 0); addEdge(i + N, T, 1, 0); rep(j, 1, N + 1) { addEdge(i, j + N, 1, -Z[i][j]); } }}}int main() { mcmf::init(); std::cout &lt;&lt; mcmf::mcmf() &lt;&lt; std::endl; mcmf::init2(); std::cout &lt;&lt; -mcmf::mcmf() &lt;&lt; std::endl; return 0;}","link":"/LOJ-6012/"},{"title":"LOJ 6121 孤岛营救问题","text":"一个 $N \\times M$ 的网格图，其中相邻的格子之间可能互通，共有三种情况如下： - 已经连通 - 有一堵墙，无法逾越 - 有一扇编号为 $A_i$ 的门，需要对应编号的钥匙打开（钥匙可以多次使用） 已知你现在位于 $(1,1)$，需要抵达 $(N, M)$ 。 有 $P$ 种门，门和墙的总数为 $K$ ，共 $S$ 把钥匙。 走到相邻的格子花费 $1$ 时间，捡起钥匙和打开门不消耗时间。 求抵达目的地的最短时间，如果无法抵达，输出 -1 。 $N,M,P\\leq 10$ $K\\leq 150$ $S\\leq 14$ 分析每得到一个钥匙，图的连通性就发生了改变。放在一起处理比较麻烦，考虑单独处理。 一共有 $P$ 种钥匙，那么共有 $2^P$ 种不同连通性的图，分别跑最短路即可。 具体实现即每次到达一个有钥匙的格子后，如果有新钥匙，那么进入下一层跑最短路。 钥匙的状态有两进制状压，记 $D_{i,j,k}$ 为在钥匙数 $i$ 状态下 $(1,1)$ 转移到 $(j,k)$ 的最短时间，答案为 $\\min{D_{i,N,M} \\mid i \\in[0, 2^S)}$ 。 注意事项 同一个格子可能会有多把钥匙 注意空间 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 10 + 5;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};int N, M, P, K, S;int Dis[1 &lt;&lt; MAXN][MAXN][MAXN];int Map[MAXN][MAXN][4];std::vector&lt;int&gt;Key[MAXN][MAXN];bool check(int x, int y) { return x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= N &amp;&amp; y &lt;= M;}bool bfs() { std::queue&lt;std::pair&lt;int, int&gt; &gt; Que; Que.push(std::make_pair(1, 1)); while(!Que.empty()) { std::pair&lt;int, int&gt; x = Que.front(); Que.pop(); if(x.first == N &amp;&amp; x.second == M) { return true; } rep(i, 0, 4) { int nx = x.first + Dicx[i], ny = x.second + Dicy[i]; if(check(nx, ny) &amp;&amp; Map[x.first][x.second][i] &amp;&amp; !Dis[0][nx][ny]) { Dis[0][nx][ny] = 1; Que.push(std::make_pair(nx, ny)); } } } return false;}void check(int cur, int lst, int lx, int ly) { std::queue&lt;std::pair&lt;int, int&gt; &gt; Que; std::bitset&lt;MAXN&gt; Bt = cur; Que.push(std::make_pair(lx, ly)); Dis[cur][lx][ly] = Dis[lst][lx][ly]; while(!Que.empty()) { std::pair&lt;int, int&gt; x = Que.front(); Que.pop(); if(!Key[x.first][x.second].empty()) { rep(i, 0, SZ(Key[x.first][x.second])) { if(!Bt[Key[x.first][x.second][i]]) { check(cur | (1 &lt;&lt; Key[x.first][x.second][i]), cur, x.first, x.second); } } } rep(i, 0, 4) { int nx = x.first + Dicx[i], ny = x.second + Dicy[i]; if(check(nx, ny) &amp;&amp; (Map[x.first][x.second][i] == -1 || Bt[Map[x.first][x.second][i]])) { if(Dis[cur][nx][ny] &gt; Dis[cur][x.first][x.second] + 1) { Dis[cur][nx][ny] = Dis[cur][x.first][x.second] + 1; Que.push(std::make_pair(nx, ny)); } } } }}int main() { int x1, y1, x2, y2, z; std::cin &gt;&gt; N &gt;&gt; M &gt;&gt; P &gt;&gt; K; memset(Map, -1, sizeof Map); rep(i, 0, K) { std::cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z; if(x1 == x2) { Map[x1][y1][y1 &gt; y2 ? 1 : 3] = z; Map[x2][y2][y1 &gt; y2 ? 3 : 1] = z; } else { Map[x1][y1][x1 &gt; x2 ? 2 : 0] = z; Map[x2][y2][x1 &gt; x2 ? 0 : 2] = z; } } std::cin &gt;&gt; S; rep(i, 0, S) { std::cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z; Key[x1][y1].push_back(z); } if(!bfs()) { std::cout &lt;&lt; -1 &lt;&lt; std::endl; } else { memset(Dis, 0x3f, sizeof Dis); Dis[0][1][1] = 0; check(0, 0, 1, 1); int ans = INT_MAX; rep(i, 0, 1 &lt;&lt; (P + 1)) { ans = std::min(ans, Dis[i][N][M]); } std::cout &lt;&lt; ans &lt;&lt; std::endl; } return 0;}","link":"/LOJ-6121/"},{"title":"LOJ-6122 航空路线问题","text":"有 $N$ 个结点， $M$ 条无向边。现想从结点 $1$ 走到 $N$ 再走回 $1$，且每个结点至多只能访问一次（除了结点 $1$）。 求该路径的最大长度并顺序输出途经结点，如果不存在，输出No Solution! $1\\leq N\\leq 100$ 分析首先将问题转化一下，由于除了起点可以经过两次，其他结点均只能经过一次。那么问题可以等价于寻找两条起点为 $1$，终点为 $N$ 的不相交路径（除了起点终点），使得两条路径的长度和最大。 构造跑最大流显然是不够的，因为最大流只会使得流量最大，而不会关心沿途结点个数。 构造图的方法很简单，依旧是拆点，然后边流量限制置为 $1$，起点终点限制置为 $2$。 如果存在路径 $(u, v)$，连边 $(u.y, v.x)$，即访问完 $u$ 后可以访问 $v$。 然后连接 $(i.x, i.y)$，$(S, 1.x)$， $(N.y, T)$，构图完成。 但是它和最大流是有关系的，因为存在路径条数为 $2$ 的限制，即最大流为 $2$ 。 对于无解情况很好判断，最大流 $F &lt; 2$ 时，即不存在两条路径，无解。 那么问题在于如何使得途径点数最多。 考虑再引入一维，使得在满足最大流最大的情况下，该值最大。 想到费用流。由于途径的每个点，根据拆点的思想，一定会从“未访问”到“访问”，而且根据限制，每个点至多访问一次。 那么将 $(i.x, i.y)$ 的费用置为 $1$，其他边均为 $0$, 那么 $S-T$ 跑得的费用即为经过点的个数。 最小费用最大流使用 SPFA 根据EK的思路增广即可，求最大费用也很简单，费用 $c_i$ 置成 $-c_i$ 即可。 关于路径输出，我们可以发现如果增广路途经 $i.y(i \\not= N)$，那么它一定是通过某 $j.x$ 而来，而且这个 $j$ 是唯一的（流量限制为 $1$）。那么从 $T$ 开始寻找两条增广路，分别纪录前驱后继，最后一个正序，一个逆序输出即可。 注意的点： 可能会存在边 $(1, N)$，那么这个时候 $1-&gt;N-&gt;1$ 是一条合法路径，但是按照之前的方法建图最大流不一定是 $2$ （比如 $1$ 到 $N$ 只存在这条路径，最大流为 $1$）。那么对于这条边，流量置为 $2$。输出路径的时候如果发现不存在两条增广路，直接输出 $1\\ N\\ 1$ 即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace mcmf {const int MAXN = 200 + 5;const int MAXM = 5000 + 5;struct Edge { int v, f, c, nxt;} E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int N, M, S, T, cost, flow;int Pe[MAXN], Pv[MAXN], Dis[MAXN];bool Inq[MAXN];void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, f, c, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, -c, H[v]}; H[v] = cntE;}bool spfa() { static std::queue&lt;int&gt; Que; memset(Dis, 0x3f, sizeof Dis); memset(Inq, 0, sizeof Inq); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &gt; 0 &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Pe[v] = i, Pv[v] = x; if (!Inq[v]) { Que.push(v); Inq[v] = true; } } } } return Dis[T] != INF;}std::map&lt;std::string, int&gt; Map;std::vector&lt;std::string&gt; Vs;void init() { std::string str, str2; memset(H, -1, sizeof H); cntE = -1; std::cin &gt;&gt; N &gt;&gt; M; S = 0, T = N * 2 + 1; Vs.push_back(\"\"); rep(i, 1, N + 1) { std::cin &gt;&gt; str; Map[str] = i; if(i != 1 &amp;&amp; i != N) { addEdge(i, i + N, 1, 0); } else { addEdge(i, i + N, 2, 0); } Vs.push_back(str); } rep(i, 0, M) { std::cin &gt;&gt; str &gt;&gt; str2; int u = Map[str], v = Map[str2]; if(u &gt; v) { std::swap(u, v); } if(u == 1 &amp;&amp; v == N) { addEdge(u + N, v, 2, -1); } else { addEdge(u + N, v, 1, -1); } } addEdge(S, 1, 2, 0); addEdge(N * 2, T, 2, 0);}void mcmf() { init(); while (spfa()) { int f = INT_MAX; for (int i = T; i != S; i = Pv[i]) { f = std::min(f, E[Pe[i]].f); } cost += f * Dis[T]; flow += f; for (int i = T; i != S; i = Pv[i]) { E[Pe[i]].f -= f; E[Pe[i] ^ 1].f += f; } }}int Match[MAXN];std::vector&lt;int&gt; V;void print() { if(flow &lt; 2) { std::cout &lt;&lt; \"No Solution!\" &lt;&lt; std::endl; } else { std::cout &lt;&lt; -cost &lt;&lt; std::endl; int cnt = -1, A[2]; for(int i = H[N]; ~i; i = E[i].nxt) { if(E[i].f) { A[++cnt] = E[i].v - N; } } if(cnt == 0) { std::cout &lt;&lt; Vs[1] &lt;&lt; std::endl; std::cout &lt;&lt; Vs[N] &lt;&lt; std::endl; std::cout &lt;&lt; Vs[1] &lt;&lt; std::endl; return; } rof(x, N, 1) { for(int i = H[x]; ~i; i = E[i].nxt) { if(E[i].f &amp;&amp; E[i].v != x + N) { Match[x] = E[i].v - N; break; } } } for(int i = A[0]; i &gt; 0; i = Match[i]) { V.push_back(i); } std::reverse(ALL(V)); rep(i, 0, SZ(V)) { std::cout &lt;&lt; Vs[V[i]] &lt;&lt; std::endl; } std::cout &lt;&lt; Vs[N] &lt;&lt; std::endl; for(int i = A[1]; i &gt; 0; i = Match[i]) { std::cout &lt;&lt; Vs[i] &lt;&lt; std::endl; } }}} // namespace mcmfint main() { mcmf::mcmf(); mcmf::print(); return 0;}","link":"/LOJ-6122/"},{"title":"LOJ 6223 汽车加油行驶问题","text":"一个 $N * N$ 的网格图，起点为 $(1,1)$ （左上角），终点为 $(N,N)$ （右下角）。 一辆汽车从起点出发，油量为满（ $K$ ），每走一格油量消耗 $1$ ，剩余 $0$ 的时候无法行驶。 有些点有加油站，如果走到该点，必须加满，费用为 $A$ 。 如果该点没有加油站，可以选择增设加油站，费用为 $C$ （不算加油的费用）。 每经过一条网格边，如果是往左或往上走，费用为 $B$ ；如果向下或者向右走，没有花费。 求最小花费。 $2\\leq N\\leq 100,2\\leq K\\leq 10$ 分析如果没有油量这个限制，就是一个最短路问题。 那么把剩余油量作为表示状态的一维。用 $(x, y, k)$ 表示坐标为 $(x,y)$ ，剩余流量为 $k$ 的状态。 根据条件，可以得到 ： $(x,y,k)\\rightarrow(x-1,y,k-1)$ ，费用为 $B$ （ $ k\\geq1, x&gt;1$ ）； $(x,y,k)\\rightarrow(x+1,y,k-1)$ ，费用为 $0$ （ $ k\\geq1, x&lt;N$ ）； $(x,y,k)\\rightarrow(x,y-1,k-1)$ ，费用为 $1$ （ $ k\\geq1, y&gt;1$ ）； $(x,y,k)\\rightarrow(x,y+1,k-1)$ ，费用为 $0$ （ $ k\\geq1, y&lt;N $ ）； $(x,y,k)\\rightarrow(x,y,K)$ ，费用为 $A$ 或 $A+C$ （$k\\geq 0$ ）。 这么建图有一个可能的问题在于：增设加油站只需要花费一次 $C$ ，下一次再加就只需要花费 $A$ 了，但是这么建图会导致每次费用都是 $A+C$ 。 那么存在一个结论：每个点只会走一次。 简略证明：回去的目的就是再加油；如果加完油回来，跟之前的剩余油量相同，又要多付路费；如果加完油走别的路径会更优，那么在第一次到达这个点就会直接那么走，故回去加油不会更优。 最后增加 $S\\rightarrow (1,1,K)$ $(N,N,i)\\rightarrow T(0\\leq i\\leq K)$ ，流量全部置为 $1$ 。 跑最小费用最大流即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { register T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { register char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} register bool f = c == '-'; register T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif} // namespace ionamespace mcmf {const int MAXN = 100 * 100 * 12 + 5;const int MAXM = MAXN * 5;const int Dicx[] = {1, 0, -1, 0};const int Dicy[] = {0, -1, 0, 1};struct Edge { int v, nxt, f, c;}E[MAXM &lt;&lt; 1];int N, S, T, F, C;int H[MAXN], cntE;int getId(int x, int y, int k) { return x * N + y + k * N * N;}void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, H[u], f, c}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v], 0, -c}; H[v] = cntE;}void init() { memset(H, -1, sizeof H); cntE = -1; S = 0, T = 1; N = io::gt&lt;int&gt;(); int K = io::gt&lt;int&gt;(), A = io::gt&lt;int&gt;(), B = io::gt&lt;int&gt;(), C = io::gt&lt;int&gt;(); addEdge(S, getId(1, 1, K), 1, 0); rep(i, 1, N + 1) { rep(j, 1, N + 1) { int opt = io::gt&lt;int&gt;(); rep(k, 0, K + 1) { if(k != K) { addEdge(getId(i, j, k), getId(i, j, K), 1, opt ? A : A + C); } rep(d, 0, 4) { int nx = i + Dicx[d], ny = j + Dicy[d]; if(((!opt &amp;&amp; k != 0) || k == K) &amp;&amp; (nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= N &amp;&amp; ny &lt;= N)) { addEdge(getId(i, j, k), getId(nx, ny, k - 1), 1, (d == 1 || d == 2) ? B : 0); } } } } } rep(i, 0, K) { addEdge(getId(N, N, i), T, 1, 0); }}int Lp[MAXN], Le[MAXN], Dis[MAXN];bool Inq[MAXN];void spfa() { static std::queue&lt;int&gt; Que; memset(Dis, 0x3f, sizeof Dis); Dis[S] = 0; Que.push(S); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(Dis[v] &gt; Dis[x] + E[i].c &amp;&amp; E[i].f) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if(!Inq[v]) { Inq[v] = true; Que.push(v); } } } }}void mcmf() { init(); spfa(); printf(\"%d\\n\", Dis[T]);}}int main() { mcmf::mcmf(); return 0;}","link":"/LOJ-6223/"},{"title":"LOJ 6003 魔术球","text":"将 $[1, N]$ 分成 $K$ 组序列，使得每组序列相邻两数的和为完全平方数，且序列递增。 已知 $K$，求 $N$ 的最大值，并给出一组方案（按顺序输出 $K$ 个序列）。 $1\\leq K\\leq 55$ 分析假如 $[1,N-1]$ 已经分好组了，那么 $N$ 只能自成一组或者放到某个序列的最后。 所以显而易见的一点就是，当 $N$ 增大时， $K$ 是单调不递减的。 根据单调性，一个基本的思路便是二分答案。 考虑如何检查合法性。 由于每个点之只能和一个前驱后继匹配（或者没有），那么便相当于一个DAG（有向无环图）求最小路径覆盖（拆成 $K’$ 条不相交的链，覆盖所有点）。 若 $K’ \\leq K$，解就是合法的。 求解最小路径匹配数，考虑网络流算法。 将每个点 $i$ 拆成 $A_i, B_i$ 两部分，如果存在 $i+j=k^2(i&lt; j)$，则连接 $A_i$ 和 $B_j$。 建立源汇点 $S$ 和 $T$，$S$ 和所有 $A_i$ 连边，所有 $B_i$ 和 $T$ 连边。 皆为有向边，流量限制为 $1$ 。 最小路径覆盖数的值即节点数 $N$ 和 $S-T$ 最大流的差。 根据Dinic算法的流程，易得每次在残余网络上加边再找可行流，与之前的最大流相加即为新图的最大流。 所以如果只是在原图的基础上加边，不需要重复构图，单次增广复杂度 $O(nm)$。 那么二分答案显然不如直接递增枚举了，因为它需要每次重新构图跑最大流，而后者只需要加边寻找可行流。 因此算法流程为：从 $1$ 开始递增枚举 $N$，寻找可行流，直到最小路径数超过 $K$，答案即为 $N - 1$。 至于输出答案，重新建图跑最大流，然后找到 $B_i$ 相连的所有反向弧为 $1$ 的边，纪录对应的点（即前驱）。 记录每个节点是否被输出。从后往前枚举序列的尾结点，如果没有标记，那么该点即为一个新序列的最后一个元素。 由于每个数的前驱只会有一个，所以从尾结点开始，每次跳到前驱，并同时输出，打上标记。 复杂度分析枚举 $N$ ，最大流跑二分图复杂度 $O(N^2\\times \\sqrt{M})$，如果利用了capacity scaling技巧，复杂度似乎会降（？），至少会快很多。 uoj blog 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace dinic {const int MAXN = 10000 + 5;const int MAXM = 180000 + 5;struct Edge { int v, f, nxt;}E[MAXM &lt;&lt; 1];int H[MAXN], cntE;int Flow[MAXM], Dis[MAXN], Lv[MAXN], Cur[MAXN];int N, M, S, T, K = 5000, tim, ffffc, F;void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, 0, H[v]}; H[v] = cntE;}bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for (Que[qt++] = S; qh &lt; qt;) { int &amp;x = Que[qh++]; if (x == T) { return true; } for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] != tim &amp;&amp; E[i].f) { Lv[v] = tim; Dis[v] = Dis[x] + 1; Que[qt++] = v; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}void dinic() { while (true) { while (bfs()) { memcpy(Cur, H, sizeof H); F += dfs(S, INT_MAX); } if (!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; } memset(Flow, 0, sizeof(int) * (cntE + 1)); }}void init() { memset(H, -1, sizeof H); cntE = -1;}std::bitset&lt;MAXM&gt; Issquare, Vis;int Match[MAXM];std::vector&lt;int&gt; V;void solve() { int n; scanf(\"%d\", &amp;n); rep(i, 1, std::sqrt(MAXM)) { Issquare[i * i] = 1; } init(); S = 0; T = 8000; int cur = 0; do { ++cur; addEdge(S, cur, 1); addEdge(cur + K, T, 1); rep(i, 1, cur) { if(Issquare[i + cur]) { addEdge(i, cur + K, 1); } } dinic(); } while(cur - F &lt;= n); printf(\"%d\\n\", cur - 1); init(); rep(i, 1, cur) { addEdge(S, i, 1); addEdge(i + K, T, 1); rep(j, 1, i) { if(Issquare[i + j]) { addEdge(j, i + K, 1); } } } dinic(); rof(i, K + cur, K + 1) { for(int j = H[i]; ~j; j = E[j].nxt) { if(E[j].f) { Match[E[j].v] = i - K; break; } } } rep(i, 1, cur) { if(Vis[i]) { continue; } V.clear(); for(int j = i; j; j = Match[j]) { V.push_back(j); Vis[j] = true; } rep(j, 0, SZ(V)) { printf(\"%d \", V[j]); } printf(\"\\n\"); }}}int main() { dinic::solve(); return 0;}","link":"/LOJ-6003/"},{"title":"LOJ-6225 火星探险问题","text":"$Q\\times P$ 的网格图，起点位于左上角 $(1,1)$ ，终点位于右下角 $(Q,P)$。 现在有 $N$ 个机器人从起点出发，每次只能向右或向下移动一格，且不能碰到障碍物。 每个格子有三种可能的状态：空地、有标本、有障碍物。 第一个抵达有标本的格子的机器人会取走该格子的标本，每个格子可以同时容纳多个机器人。 如果不能抵达终点，路上收集的标本将作废。 给出每个机器人的移动方案，使得采集到最多的标本，且最多的机器人达到终点。 $P,Q\\leq 35$ 分析显然是最大费用最大流。流量是机器人的个数，保证每个机器人都能到终点，费用是标本数。 输出方案也很简单，直接就是在回溯更新每条边流量的时候的存储路径上的点，然后再从起点到终点，比照一下相连两个点的位置关系，按照要求输出即可。 不过需要注意的一点是，很可能跑不到 $N$ 次就已经得到最大费用最大流了，所以剩下的机器人只需要随便找一条合法的路径输出。比较偷懒的方法就是剩下的全部输出最后一次增广的路径方案。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace mcmf {const int MAXN = 35 * 40 * 2 + 5;const int MAXM = MAXN * MAXN;struct Edge { int v, nxt, f, c;} E[MAXM &lt;&lt; 1];int N, P, Q, S, T, F, C;int H[MAXN], cntE;int Dis[MAXN], Lp[MAXN], Le[MAXN];bool Inq[MAXN];bool spfa() { static std::queue&lt;int&gt; Que; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if (!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } return Dis[T] != INF;}void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, H[u], f, c}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v], 0, -c}; H[v] = cntE;}int A[MAXN][MAXN];int getId(int x, int y) { return x * P + y;}bool check(int x, int y) { return x &gt;= 1 &amp;&amp; x &lt;= Q &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= P &amp;&amp; A[x][y] != 1;}void init() { memset(H, -1, sizeof H); cntE = -1; std::cin &gt;&gt; N &gt;&gt; P &gt;&gt; Q; rep(i, 1, Q + 1) { rep(j, 1, P + 1) { std::cin &gt;&gt; A[i][j]; } } int up = getId(Q, P); S = 0, T = up * 2; addEdge(S, getId(1, 1), N, 0); rep(i, 1, Q + 1) { rep(j, 1, P + 1) { if (A[i][j] == 2) { addEdge(getId(i, j), getId(i, j) + up, 1, -1); } if (A[i][j] != 1) { addEdge(getId(i, j), getId(i, j) + up, INT_MAX, 0); if (check(i, j + 1)) { addEdge(getId(i, j) + up, getId(i, j + 1), INT_MAX, 0); } if (check(i + 1, j)) { addEdge(getId(i, j) + up, getId(i + 1, j), INT_MAX, 0); } } } }}void mcmf() { static std::stack&lt;int&gt; Stk; static int A[MAXN], total; init(); int cnt = 1; while (spfa()) { int f = INT_MAX; for (int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); if(i &lt;= getId(Q, P)) { Stk.push(i); } } F += f; C += Dis[T] * f; int last = Stk.top(); Stk.pop(); total = 0; while (!Stk.empty()) { int x = Stk.top(); Stk.pop(); if (x == last + 1) { A[total++] = 1; } else { A[total++] = 0; } last = x; } rep(j, 0, total) { std::cout &lt;&lt; cnt &lt;&lt; \" \" &lt;&lt; A[j] &lt;&lt; std::endl; } for (int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } ++cnt; } rep(i, cnt, N + 1) { rep(j, 0, total) { std::cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; A[j] &lt;&lt; std::endl; } }}}int main() { mcmf::mcmf(); return 0;}","link":"/LOJ-6225/"},{"title":"LOJ-6224 深海机器人问题","text":"一个 $N * M$ 的网格图，每条边都存在权值。 现有 $A$ 个起点， $B$ 个终点。 第 $i$ 个起点可以作为 $X_i$ 条路径的起点，第 $i$ 个终点可以作为 $Y_i$ 条路径的终点。保证 $\\sum{X_i}=\\sum{Y_i}$ 。 每条路径只能向右或者向上移动，可以重复经过某一条边或者某个点。 求这 $\\sum{X_i}$ 条路径覆盖的所有边的最大权值和（同一条边的权值只算一次）。 $1\\leq N,M\\leq 15$ $1\\leq A\\leq 4$ $1\\leq B\\leq 6$ 分析既然是求最大价值，第一反应自然是连负边跑最小费用最大流。 边权算一次，那就流量限制置为 $1$ ，但是可以多次经过，那就再连一条花费为 $0$ ，不限流量的边。 $S$ 向所有起点连流量限制为 $A_i$ 的边，终点同理。 跑最小费用最大流。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace mcmf {const int MAXN = 20 * 20 * 2;const int MAXM = MAXN;const int INF = 1e9 + 7;struct Edge { int v, nxt, f, c;}E[MAXM &lt;&lt; 2];int N, M, S, T, F, C;int H[MAXN], cntE;int Dis[MAXN], Lp[MAXN], Le[MAXN];std::bitset&lt;MAXN&gt; Inq;int getId(int x, int y) { return x * (M + 1) + y;}void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge){v, H[u], f, c}; H[u] = cntE; E[++cntE] = (Edge){u, H[v], 0, -c}; H[v] = cntE;}void init() { int a, b, k, x, y; std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; N &gt;&gt; M; S = (N + 1) * (M + 1), T = S + 1; memset(H, -1, sizeof H); cntE = -1; rep(i, 0, N + 1) { rep(j, 0, M) { std::cin &gt;&gt; x; addEdge(getId(i, j), getId(i, j + 1), 1, -x); addEdge(getId(i, j), getId(i, j + 1), INF, 0); } } rep(i, 0, M + 1) { rep(j, 0, N) { std::cin &gt;&gt; x; addEdge(getId(j, i), getId(j + 1, i), 1, -x); addEdge(getId(j, i), getId(j + 1, i), INF, 0); } } rep(i, 0, a){ std::cin &gt;&gt; k &gt;&gt; x &gt;&gt; y; addEdge(S, getId(x, y), k, 0); } rep(i, 0, b) { std::cin &gt;&gt; k &gt;&gt; x &gt;&gt; y; addEdge(getId(x, y), T, k, 0); }}bool spfa() { static std::queue&lt;int&gt; Que; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x; Le[v] = i; if(!Inq[v]) { Inq[v] = 1; Que.push(v); } } } } return Dis[T] != INF;}int mcmf() { init(); while(spfa()) { int f = INF; for(int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } F += f; C += f * Dis[T]; for(int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } } return C;}}int main(){ std::cout &lt;&lt; -mcmf::mcmf() &lt;&lt; std::endl; return 0;}","link":"/LOJ-6224/"},{"title":"LOJ 6226 骑士共存问题","text":"一个位于点 $S$ 的骑士可以攻击到所有标记为 $X$ 的红色格子，在一个 $N * N$ 的棋盘上，有 $M$ 个格子不能放置骑士，坐标为 $(X_i,Y_i)$ 。 求最多能放多少个骑士，使得他们两两之间无法相互攻击。 $1\\leq N\\leq 200$ $M\\leq N^2$ 分析根据观察可以发现，棋盘的红色和黄色两部分是互相影响的，但是其内部相互独立。任意放置一个骑士后，只会导致某些异色的格子无法再放置。 这是两个独立的部分，由此想到二分图。互不影响，我们可以想到独立集。 合在一起就是二分图最大独立集。 求二分图最大独立集，根据 二分图最大匹配=最大流=最小顶点覆盖=总结点数-最大独立集 转化成网络流问题。 建模方法如下：$S$ 连接二分图 $X$ 部， 二分图 $Y$ 部连接 $T$ ，流量限制皆为 $1$ ，不能同时放置骑士的点之间连接边，不设流量限制。$N\\times N - M$ 为总结点数，与求得的 $S-T$ 最大流做差即为答案。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace dinic {const int MAXN = (200 + 5) * (200 + 5) + 5;const int MAXM = MAXN * 10;struct Edge { int v, nxt, f;}E[MAXM &lt;&lt; 1];int N, M, S, T, F, tim, ffffc;int H[MAXN], cntE;int Dis[MAXN], Lv[MAXN], Cur[MAXN], Flow[MAXM];void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, H[u], f}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v], 0}; H[v] = cntE;}bool bfs() { static int Que[MAXN]; int qh = 0, qt = 0; Dis[S] = 1, Lv[S] = ++tim; for (Que[qt++] = S; qh &lt; qt;) { int &amp;x = Que[qh++]; if (x == T) { return true; } for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] != tim &amp;&amp; E[i].f) { Lv[v] = tim; Dis[v] = Dis[x] + 1; Que[qt++] = v; } } } return false;}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int left = maxf; for (int &amp;i = Cur[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Lv[v] == tim &amp;&amp; Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f) { int flow = dfs(v, std::min(left, E[i].f)); if (!flow) { Dis[v] = -1; } else { left -= flow; E[i].f -= flow; Flow[i ^ 1] += flow; ffffc = 1; if (!left) { return maxf; } } } } return maxf - left;}std::bitset&lt;MAXN&gt; Bt;const int Dicx[] = {2, 1, -1, -2, -2, -1, 1, 2};const int Dicy[] = {-1, -2, -2, -1, 1, 2, 2, 1};int getId(int x, int y) { return x * N + y;}bool check(int x, int y) { return x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= N &amp;&amp; y &lt;= N &amp;&amp; !Bt[getId(x, y)];}void init() { memset(H, -1, sizeof H); cntE = -1; int x, y; std::cin &gt;&gt; N &gt;&gt; M; rep(i, 0, M) { std::cin &gt;&gt; x &gt;&gt; y; Bt[getId(x, y)] = 1; } S = getId(N, N) + 1, T = S + 1; rep(i, 1, N + 1) { rep(j, 1, N + 1) { if(!Bt[getId(i, j)]) { if((i + j) &amp; 1) { addEdge(getId(i, j), T, 1); } else { addEdge(S, getId(i, j), 1); rep(k, 0, 8) { int nx = i + Dicx[k], ny = j + Dicy[k]; if(check(nx, ny)) { addEdge(getId(i, j), getId(nx, ny), INT_MAX); } } } } } }}void dinic() { init(); while(true) { while(bfs()) { memcpy(Cur, H, sizeof H); F += dfs(S, INT_MAX); } if(!ffffc) { break; } ffffc = 0; rep(i, 0, cntE + 1) { E[i].f += Flow[i]; Flow[i] = 0; } } std::cout &lt;&lt; N * N - M - F &lt;&lt; std::endl;}}int main() { dinic::dinic(); return 0;}","link":"/LOJ-6226/"},{"title":"LOJ-6227 最长 k 可重线段集问题","text":"有 $N$ 条开线段，可以从中选择任意数量的开线段，使得对于任意直线 $x=p$ ，至多有 $K$ 条线段和它有交点。求选取的开线段的长度之和的最大值。 $1\\leq N\\leq 500$ $1\\leq K\\leq 13$ 分析和【【网络流24题】【最小费用最大流】luogu P3358 最长k可重区间集问题】几乎是一样的，但是有一个细节区分了这两道题（标程也没注意到）。 那就是对于某一条在直线 $x=p$ 上的开线段，和一条左/右端点为 $(p,q)$ 的开线段是没有交点的。 还要注意的一点，就是如果是 $O(N\\times\\log{N})$ 的建图方法，会出现自环且负环，需要特殊处理，比较麻烦，所以不如直接拆点跑网络流。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace mcmf {const int MAXN = 1200 + 5;const int MAXM = MAXN * MAXN;struct Edge { int v, nxt, f, c;}E[MAXM &lt;&lt; 1];int S, T, F, C;int H[MAXN], cntE;int Dis[MAXN], Lp[MAXN], Le[MAXN];bool Inq[MAXN];bool spfa() { static std::queue&lt;int&gt; Que; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if(!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;}void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, H[u], f, c}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v], 0, -c}; H[v] = cntE;}struct Point { int x, y, c; inline bool operator &lt; (const Point&amp; a) const { return x == a.x ? y &lt; a.y : x &lt; a.x; }};#define sqr(x) (x) * (x)void init() { memset(H, -1, sizeof H); cntE = -1; int N, K; ll x0, x1, y0, y1; scanf(\"%d%d\", &amp;N, &amp;K); static Point P[MAXN]; rep(i, 0, N) {g scanf(\"%lld%lld%lld%lld\", &amp;x0, &amp;y0, &amp;x1, &amp;y1); P[i] = (Point) {std::min(x0, x1), std::max(x0, x1), std::sqrt(sqr(x0 - x1) + sqr(y0 - y1))}; } std::sort(P, P + N); S = N * 2, T = N * 2 + 2; addEdge(S, S + 1, K, 0); rep(i, 0, N) { addEdge(S + 1, i, 1, 0); addEdge(i + N, T, 1, 0); addEdge(i, i + N, 1, -P[i].c); rep(j, i + 1, N) { if(P[j].x &gt;= P[i].y &amp;&amp; !(P[i].x == P[i].y &amp;&amp; P[j].x == P[j].y &amp;&amp; P[i].x == P[j].x)) { addEdge(i + N, j, 1, 0); } } }}void mcmf() { init(); while(spfa()) { int f = INT_MAX; for(int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } F += f; C += f * Dis[T]; for(int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } } printf(\"%d\\n\", -C);}}int main() { mcmf::mcmf(); return 0;}","link":"/LOJ-6227/"},{"title":"codeforces 145E Lucky Queries","text":"长度为 $N$ 的 $01$ 序列$A$有$M$次操作，每次将 $A[l,r]$ 中的每个数异或 $1$，或查询$A$ 的最长不下降子序列的长度。 $1 \\leq N\\leq 10^6, 1\\leq M\\leq 3\\times 10^5$ 分析由于序列中只有 $0$ 和 $1$ ，因此最长不下降子序列只有两种情况：都是$0$或$1$，或者前面都是 $0$ 后面都是 $1$ 。 用线段树维护区间中完全由 $0$ 与 $1$ 组成，以及最长不上升与不下降子序列的长度， 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).sizo())typedef long long ll;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0;}template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0;}const int MAXN = 1e6 + 5;int N, M;char Str[MAXN];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rstruct Node { int zero, one, up, down, mrk; Node () { zero = one = up = down = mrk = 0; } Node (int a, int b, int c, int d) : zero(a), one(b), up(c), down(d), mrk(0) {} Node operator + (const Node &amp;x) { Node y; y.zero = zero + x.zero; y.one = one + x.one; y.up = std::max(up + x.one, zero + x.up); y.down = std::max(down + x.zero, one + x.down); y.mrk = 0; return y; } void swap() { mrk ^= 1; std::swap(zero, one); std::swap(up, down); }} T[MAXN &lt;&lt; 2];void pushUp(int rt) { T[rt] = T[rt &lt;&lt; 1] + T[rt &lt;&lt; 1 | 1];}void pushDown(int rt) { if (T[rt].mrk) { T[rt &lt;&lt; 1].swap(); T[rt &lt;&lt; 1 | 1].swap(); T[rt].mrk = 0; }}void build(int rt, int l, int r) { if (l == r) { if (Str[l] == '4') { T[rt] = (Node) { 1, 0, 1, 1 }; } else { T[rt] = (Node) { 0, 1, 1, 1 }; } return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt);}void change(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { T[rt].swap(); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { change(LT, a, b); } if (m &lt; b) { change(RT, a, b); } pushUp(rt);}Node queryMax(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt]; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if (a &gt; m) { return queryMax(RT, a, b); } else if (b &lt;= m) { return queryMax(LT, a, b); } else { return queryMax(LT, a, b) + queryMax(RT, a, b); }}int main() { int N, M, l, r; scanf(\"%d%d%s\", &amp;N, &amp;M, Str + 1); build(1, 1, N); while (M--) { scanf(\"%s\", Str); if (Str[0] == 'c') { Node res = queryMax(1, 1, N, 1, N); printf(\"%d\\n\", res.up); } else { scanf(\"%d%d\", &amp;l, &amp;r); change(1, 1, N, l, r); } } return 0;}","link":"/codeforces-145E/"},{"title":"斯坦纳树学习笔记（Steiner Tree）","text":"总论斯坦纳树可以理解为一棵使得指定点集合联通的树，而最小斯坦纳树在联通的基础上要求边权和最小。（是不是有点类似于最小生成树？） 通常通过状压DP+最短路松弛的方式来解决此类问题。 过程具体过程不妨从一个简单问题出发。 无向图 $G$ 上有 $n$ 个点，选择若干个点使得它们包含点集合 $S={a_1,a_2,\\cdots,a_m}$，且 $S$ 联通。选择点 $i$ 的代价为 $A_i$，求最小代价。 设 $F[i][S]$ 表示集合 $S$ 的点被选择且当前选择节点 $i$ 的最小花费，则 $F[i][S]$ 有两种方式转移，一是枚举子集合并，二是集合内部松弛。 第一种： $F[i][S]=\\min{F[i][T]+F[i][S-T]-A[i]}$，其中 $T$ 是 $S$ 的一个子集。 可以通过 for (int x = S; x; x = (x - 1) &amp; S) 的方式枚举 $S$ 的所有子集 $x$，复杂度 $O(3^m)$。 由于外层还要枚举当前集合状态 $S$ 和当前点 $i$，因此总复杂度为 $n\\cdot 6^m$。 第二种：$F[i][S]=\\min{F[j][S]+A[i]}$，其中点 $i,j$ 联通。 在状压DP后，可以将所有更新过的点push进队列跑SPFA或其他最短路算法完成松弛。 总复杂度 $O(n\\cdot 6^m+2^m\\cdot f)$，$f$ 为最短路复杂度。 用途最小斯坦树可以得到给定点集合所有子集的最小花费，可能会作为预处理使用。 例题 【最小斯坦纳树】[WC 2008] BZOJ 2595 游览计划 【最小斯坦纳树+状压DP】[JLOI 2015] BZOJ 4006 管道连接","link":"/Steiner-Tree/"},{"title":"codeforces 280D k-Maximum Subsequence Sum","text":"序列 $A[1…N]$ 中进行 $M$ 次操作，分为两种： 将 $A[p]$ 修改为 $x$ 查询 $A[l,r]$ 中不相交至多 $K$ 个不相交子段的和的最大值。 $N,M\\leq 10^5, K\\leq 20$ 分析对于第二个询问，有个很熟悉的网络流模型，最小费用最大流。 但是对于每个询问都重新建图跑网络流显然是会超时的，需要优化。 网络流的流程就是每次增广最大的费用，然后将这些边取反变成反向边，继续增广，直到费用为负或者没有流量为止。 那么考虑手动模拟它，即每次找到区间中和最大的字段，统计贡献后将其取反，继续直到最大和为负数，或者完成 $k$ 次为止。 这种区间打标记，区间求最值的操作，让人联想到线段树。 用线段树维护区间中子段的最大/最小和（因为取反后两者就交换了），以及左右最大子段（用来合并）的值和对应子段的左右端点，以及取反标记。 查询时记录所有被取反的区间，结束时再将其恢复。 复杂度 $O(M\\times K\\times log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define All(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 1e5 + 5;struct Line { int l, r, s; Line(int l = 0, int r = 0, int s = 0): l(l), r(r), s(s) {} Line operator + (const Line &amp;x) { return (Line) {l, x.r, s + x.s}; } bool operator &lt; (const Line &amp;x) const { return s &lt; x.s; }};struct Node { Line lMax, lMin, rMax, rMin, vMax, vMin, v; int rev; Node (int l = 0, int r = 0, int s = 0) { lMax = lMin = rMax = rMin = vMax = vMin = v = Line(l, r, s); rev = 0; } void pushUp(Node ls, Node rs) { if (ls.lMax.l == 0) { *this = rs; return; } lMax = std::max(ls.lMax, ls.v + rs.lMax); lMin = std::min(ls.lMin, ls.v + rs.lMin); rMax = std::max(ls.rMax + rs.v, rs.rMax); rMin = std::min(ls.rMin + rs.v, rs.rMin); vMax = std::max(ls.rMax, rs.lMax); vMax = std::max(vMax, std::max(ls.vMax, rs.vMax)); vMax = std::max(vMax, ls.rMax + rs.lMax); vMax = std::max(vMax, std::max(lMax, rMax)); vMin = std::min(ls.rMin, rs.lMin); vMin = std::min(vMin, std::min(ls.vMin, rs.vMin)); vMin = std::min(vMin, ls.rMin + rs.lMin); vMin = std::min(vMin, std::min(lMin, rMin)); v = ls.v + rs.v; }} T[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rvoid rev(Node&amp; x) { x.rev ^= 1; std::swap(x.lMin, x.lMax); std::swap(x.rMin, x.rMax); std::swap(x.vMin, x.vMax); x.lMin.s *= -1, x.lMax.s *= -1; x.rMin.s *= -1, x.rMax.s *= -1; x.vMin.s *= -1, x.vMax.s *= -1; x.v.s *= -1;}void pushDown(int rt) { if(T[rt].rev) { rev(T[rt &lt;&lt; 1]); rev(T[rt &lt;&lt; 1 | 1]); T[rt].rev = 0; }}void build(int rt, int l, int r) { if (l == r) { T[rt] = Node(l, r, io::gt&lt;int&gt;()); return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); T[rt].pushUp(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}void modify(int rt, int l, int r, int p, int x) { if(l == r) { T[rt] = Node(l, r, x); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) { modify(LT, p, x); } else { modify(RT, p, x); } T[rt].pushUp(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}void reverse(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { rev(T[rt]); return ; } pushDown(rt); int m = (l + r) &gt;&gt; 1; if(a &lt;= m) { reverse(LT, a, b); } if(m &lt; b) { reverse(RT, a, b); } T[rt].pushUp(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}Node queryMax(int rt, int l, int r, int a, int b) { if(a &lt;= l &amp;&amp; r &lt;= b) { return T[rt]; } pushDown(rt); int m = (l + r) &gt;&gt; 1; Node res; if(a &lt;= m) { res.pushUp(res, queryMax(LT, a, b)); } if(m &lt; b) { res.pushUp(res, queryMax(RT, a, b)); } return res;}int main() { int N = io::gt&lt;int&gt;(); build(1, 1, N); int M = io::gt&lt;int&gt;(); std::vector&lt;Line&gt; V; while(M--) { int opt = io::gt&lt;int&gt;(); if(opt == 0) { int p = io::gt&lt;int&gt;(), x = io::gt&lt;int&gt;(); modify(1, 1, N, p, x); } else { int l = io::gt&lt;int&gt;(), r = io::gt&lt;int&gt;(), k = io::gt&lt;int&gt;(); int sum = 0; V.clear(); rep(i, 0, k) { Line x = queryMax(1, 1, N, l, r).vMax; if(x.s &lt; 0) { break; } sum += x.s; V.push_back(x); reverse(1, 1, N, x.l, x.r); } io::pt(sum); rep(i, 0, SZ(V)) { reverse(1, 1, N, V[i].l, V[i].r); } } } io::flush(); return 0;}","link":"/codeforces-280D/"},{"title":"codeforces 413E Maze 2D","text":"给你一个 $2\\times N$ 的矩阵，你可以上下左右移动，其中’.’可以走，’X’不能走。$M$ 个询问，问任意两点间距离。 $1\\leq N,M\\leq 2\\times 10^5$ 分析对于所有 $2\\times 2$ 的子矩阵，维护左上到右上、右下，左下到右上、右下所需要的步数。 建立线段树，发现两个中间重叠的子矩阵可以合并信息，得到最左边一列到最右边一列所需的最小步数。 每次将结果（一个子矩阵）对应那两个查询格子的相对位置，步数超出 $2\\times N$ 意味着无解。 复杂度 $O(M\\log{N})$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 2e5 + 5;const int INF = 0x3f3f3f3f;char S[2][MAXN];int N, Q;struct Segment { int A[2][2];} T[MAXN &lt;&lt; 2];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rSegment merge(Segment x, Segment y) { Segment tmp; tmp.A[0][0] = std::min(INF, std::min(x.A[0][0] + y.A[0][0], x.A[0][1] + y.A[1][0])); tmp.A[1][0] = std::min(INF, std::min(x.A[1][1] + y.A[1][0], x.A[1][0] + y.A[0][0])); tmp.A[0][1] = std::min(INF, std::min(x.A[0][0] + y.A[0][1], x.A[0][1] + y.A[1][1])); tmp.A[1][1] = std::min(INF, std::min(x.A[1][0] + y.A[0][1], x.A[1][1] + y.A[1][1])); return tmp;}void build(int rt, int l, int r) { if (l == r) { Segment &amp;x = T[rt]; memset(x.A, 0x3f, sizeof x.A); if (S[0][l] == '.' &amp;&amp; S[1][l] == 'X') { x.A[0][0] = 1; } else if (S[0][l] == 'X' &amp;&amp; S[1][l] == '.') { x.A[1][1] = 1; } else if (S[0][l] == '.' &amp;&amp; S[1][l] == '.') { x.A[0][0] = x.A[1][1] = 1; x.A[0][1] = x.A[1][0] = 2; } return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); T[rt] = merge(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);}Segment querySum(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { return T[rt]; } int m = (l + r) &gt;&gt; 1; if (b &lt;= m) { return querySum(LT, a, b); } else if (m &lt; a) { return querySum(RT, a, b); } else { return merge(querySum(LT, a, b), querySum(RT, a, b)); }}int query(int x, int y) { int a = x, b = y, fa = 0, fb = 0; if (x &gt; N) { fa = 1; a = x - N; } if (y &gt; N) { fb = 1; b = y - N; } if(a &gt; b) { std::swap(a, b); std::swap(fa, fb); } return querySum(1, 1, N, a, b).A[fa][fb] - 1;}int main() { int x, y; scanf(\"%d%d%s%s\", &amp;N, &amp;Q, S[0] + 1, S[1] + 1); build(1, 1, N); while (Q--) { scanf(\"%d%d\", &amp;x, &amp;y); int res = query(x, y); printf(\"%d\\n\", res &lt;= 2 * N ? res : -1); } return 0;}","link":"/codeforces-413E/"},{"title":"可持久化线段树 学习笔记","text":"主席树支持静态查询区间第 $k$ 大，可以用来维护可持久化数组。单次修改/查询的复杂度为 $O(\\log{n})$ ，空间 $O(m\\log{n})$（存疑），一般开 $20n$ 至 $60n$ 的空间（视实际情况而定）。 原理其实现方法为前缀和+权值线段树。 由于是权值线段树，因此需要对全局变量（初始值插入值）进行离散化。离散化后的权值线段树为了减少空间占用采取动态开点的方式存储数据。 所谓前缀和，相当于对 $n$ 个区间 $A[1,i]$ 分别建一棵权值线段树 $T_i$，那么 $A[l,r]$ 中在 $[a,b]$ 范围内的数个数即 $T_r$ 与 $T_{l-1}$ 在$[a,b]$内个数之差 。同理查询第 $k$ 大时也可以通过在两棵线段树上对应区间做差的方法判定查询的数的位置。 当然实际情况肯定不会真的建 $n$ 棵线段树，因为树与树之间存在大量交集。相邻两棵树 $T_{i-1},T_i$ 的差别只在于新加入的 $A_i$，因此构造 $T_i$ 时只需在继承 $T_{i-1}$的基础之上插入 $A_i$。 具体操作初始化时先离散化得到新区间 $[1,N]$，然后按序将 $A_i$ 离散化后的值插入树中，继承 $T_{i-1}$ 在对应节点处的子树大小并加一，即插入一条链。 查询的时候跟权值线段树的操作类似，根据 $T_r$ 和 $T_{l-1}$ 的当前左子树大小之差与 $k$ 的关系来判断向左还是向右，直到叶子节点停止。 复杂度分析离散化复杂度 $O(n\\log{n})$，初始化 $O(n\\log{n})$，查询 $O(\\log{n})$。 静态区间第 $k$ 大 序列 $A[1\\cdots n]$，$m$ 个查询 $A[l,r]$ 中第 $k$ 小数。 $n,m\\leq 2\\times 10^5,|A_i|\\leq 10^9$。 题目链接P3834 【模板】可持久化线段树 1（主席树） 分析模板题，离散化后建主席树。复杂度 $O((N+M)\\log{N})$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;const int MAXN = 2e5 + 5;const int LOG = 40;int N, M, n;int A[MAXN], B[MAXN];int Rt[MAXN], cntP;int L[MAXN * LOG], R[MAXN * LOG], Sum[MAXN * LOG];int getX(int x) { return std::lower_bound(B + 1, B + n + 1, x) - B;}int build(int l, int r) { int rt = ++cntP; int m = (l + r) &gt;&gt; 1; if (l &lt; r) { L[rt] = build(l, m); R[rt] = build(m + 1, r); } return rt;}int update(int pre, int l, int r, int x) { int rt = ++cntP; L[rt] = L[pre], R[rt] = R[pre]; Sum[rt] = Sum[pre] + 1; if (l &lt; r) { int m = (l + r) &gt;&gt; 1; if (x &lt;= m) { L[rt] = update(L[pre], l, m, x); } else { R[rt] = update(R[pre], m + 1, r, x); } } return rt;}int query(int u, int v, int l, int r, int k) { if (l == r) { return l; } int x = Sum[L[v]] - Sum[L[u]]; int m = (l + r) &gt;&gt; 1; if (x &gt;= k) { return query(L[u], L[v], l, m, k); } else { return query(R[u], R[v], m + 1, r, k - x); }}int main() { scanf(\"%d%d\", &amp;N, &amp;M); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;A[i]); B[i] = A[i]; } std::sort(B + 1, B + N + 1); n = std::unique(B + 1, B + N + 1) - B - 1; Rt[0] = build(1, n); for (int i = 1; i &lt;= N; ++i) { Rt[i] = update(Rt[i - 1], 1, n, getX(A[i])); } int l, r, k; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", B[query(Rt[l - 1], Rt[r], 1, n, k)]); } return 0;} 可持久化数组维护一个数组 $A[1\\cdots N]$，$M$ 次操作，查询或修改第 $k$ 个版本的 $A_i$，每次操作都会得到一个新版本（查询则继承该版本）。 $N,M\\leq 10^6, |A_i|\\leq 10^9$。 题目链接P3919 【模板】可持久化数组（可持久化线段树/平衡树） 分析线段树中的叶子节点存储每个点的值，单次修改只影响一个叶子节点。因此可以通过主席树每次新建一条链连接其他所有点，并修改该叶子节点的值。查询时从该版本的根向下找即可。复杂度 $O(N+M\\log{N})$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;const int MAXN = 1e6 + 5;const int LOG = 20;int N, M;int A[MAXN];int Rt[MAXN], cntP;int L[MAXN * LOG], R[MAXN * LOG], Val[MAXN * LOG];int build(int l, int r) { int rt = ++cntP; if (l == r) { scanf(\"%d\", &amp;Val[rt]); } else { int m = (l + r) &gt;&gt; 1; L[rt] = build(l, m); R[rt] = build(m + 1, r); } return rt;}int update(int pre, int l, int r, int p, int x) { int rt = ++cntP; L[rt] = L[pre], R[rt] = R[pre]; Val[rt] = Val[pre]; if (l == r) { Val[rt] = x; } else { int m = (l + r) &gt;&gt; 1; if (p &lt;= m) { L[rt] = update(L[pre], l, m, p, x); } else { R[rt] = update(R[pre], m + 1, r, p, x); } } return rt;}int query(int rt, int l, int r, int p) { if (l == r) { return Val[rt]; } else if (l &lt; r) { int m = (l + r) &gt;&gt; 1; if (p &lt;= m) { return query(L[rt], l, m, p); } else { return query(R[rt], m + 1, r, p); } }}int main() { scanf(\"%d%d\", &amp;N, &amp;M); Rt[0] = build(1, N); int ver, opt, p, x; for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;ver, &amp;opt, &amp;p); if (opt == 1) { scanf(\"%d\", &amp;x); Rt[i] = update(Rt[ver], 1, N, p, x); } else { Rt[i] = Rt[ver]; printf(\"%d\\n\", query(Rt[ver], 1, N, p)); } } return 0;}","link":"/president segment Tree/"},{"title":"树上启发式合并 学习笔记【填坑中】","text":"传说中的”dsu on tree”，其本质就是将树轻重链剖分后，暴力维护轻儿子信息，继承重儿子信息，用于快速计算不带修改的子树查询问题。 原理感谢NormalGod的讲解。 为什么通过这种方式维护子树信息的复杂度只有 $O(n\\log{n})$ 呐？这要从树链剖分的性质讲起。 由于重儿子的信息被它父亲直接继承，因此一条重链上的所有点，在向上的过程中只会在链顶处计算一次贡献（因为链顶是它父亲的轻儿子，会被暴力计算贡献）。 在叶子节点到根节点上的所有点中，显然叶子节点被统计的次数最多，而到根的路径上有最多 $\\log{n}$ 条重链，即在 $\\log{n}$ 个重链链头处会被统计贡献。 因此一个叶子节点最多被统计 $\\log{n}$ 次，所有节点被统计次数之和的上限为 $O(n\\log{n})$ ，复杂度得证。 模板1234567891011121314151617181920212223242526272829303132// vector存边：G[MAXN]// 先轻重链剖分，Son[x]表示x的重儿子int skip;void add(int x, int fa, int val) { // 根据题目要求统计 for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; if (v != fa &amp;&amp; v != skip) { // 统计子树贡献，不统计那个重儿子（即skip） add(v, x, val); } }}void dfs(int x, int fa, bool keep) { for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; if (v != fa &amp;&amp; v != Son[x]) { // 暴力统计轻儿子 dfs(v, x, 0); } } if (Son[x]) { dfs(Son[x], x, 1); // 继承重儿子 skip = Son[x]; } add(x, fa, 1); // 计算子树贡献 // 此时获得x子树的统计结果 skip = 0; if (!keep) { add(x, fa, -1); // 清除贡献 }} 例题Codeforces 600 E - Lomsat gelral根为 $1$ 的树中，每个点有颜色。定义颜色 $a$ 占领 $x$ 的子树当且仅当不存在颜色 $b$，使得 $b$在子树中出现的次数超过 $a$。令 $A[x]$ 为所有占领 $x$ 的子树的颜色编号之和，求所有点的 $A[i]$。 $n\\leq 10^5$ 分析用sum统计当前子树中颜色出现最多的次数mx下的颜色编号之和。如果mx被更新，清零sum，相等则累加，直接套用模板即可。注意当所有点颜色不同时，会爆int。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;const int MAXN = 1e5 + 5;int N, Col[MAXN];std::vector&lt;int&gt; G[MAXN];int Sz[MAXN], Son[MAXN];void getSon(int x, int fa) { Sz[x] = 1; for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; if (v != fa) { getSon(v, x); Sz[x] += Sz[v]; if (Sz[v] &gt; Sz[Son[x]]) { Son[x] = v; } } }}long long Ans[MAXN], sum;int Cnt[MAXN], mx;int skip;void add(int x, int fa, int val) { Cnt[Col[x]] += val; if (val &gt; 0 &amp;&amp; Cnt[Col[x]] &gt;= mx) { if (Cnt[Col[x]] &gt; mx) { mx = Cnt[Col[x]]; sum = 0; } if (Cnt[Col[x]] == mx) { sum += Col[x]; } } for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; if (v != fa &amp;&amp; v != skip) { add(v, x, val); } }}void dfs(int x, int fa, bool keep) { for (size_t i = 0; i &lt; G[x].size(); ++i) { int &amp;v = G[x][i]; if (v != fa &amp;&amp; v != Son[x]) { dfs(v, x, 0); } } if (Son[x]) { dfs(Son[x], x, 1); skip = Son[x]; } add(x, fa, 1); Ans[x] = sum; skip = 0; if (!keep) { add(x, fa, -1); mx = sum = 0; }}int main() { scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; ++i) { scanf(\"%d\", &amp;Col[i]); } int u, v; for (int i = 1; i &lt; N; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } getSon(1, 0); dfs(1, 0, 1); for (int i = 1; i &lt;= N; ++i) { printf(\"%lld \", Ans[i]); } return 0;}","link":"/dsu on tree/"},{"title":"LOJ 6015 星际转移","text":"地球和月球中间有 $n$ 个太空站，有 $m$ 艘太空船， $k$ 个人要从地球前往月球。 已知每个太空站可以容纳无限多的人，每艘太空船的承载人数为 $H_i$ ，以及它们的行驶路线（经过的每一个太空站编号）。 任意两个太空站之间的行驶时间均为 $1$，太空船周期行驶（终点站再回到初始站） 乘客可以选择在任意整数时刻下车或上车，这个操作不消耗时间。 假设所有太空船0时刻都在初始站，求所有人从地球转移到月球的最短时间。 如果不能到达，输出0。 $n \\leq 13$，$m \\leq 20$，$k \\leq 50$。 分析首先判断是否有解。 很显然只要地球和月球之间存在路径，那么就一定有解。 用并查集维护所有点的连通关系，最后判断地球和月球是否属于同一集合即可。 然后是求最小值。 可以发现对于任意时刻 $t_i$ ，所有太空船的位置是已知的。 那么我们将太空船的承载人数设为边的容量，乘客设为流量。 当存在流量 $f \\geq k$ 进入月球时，转移结束。 那么该如何建图？ 那么按照时间建分层图，对于时刻 $t$ 的点 $P_i$ ，建立新点$P_{i,t}$ ，根据太空船的行驶路径连接新边，继续跑最大流，直到流量达到 $k$ 结束。 具体而言，即： 如果存在太空船 $i$ 从 $e$ 行驶到 $v$ ，即存在边 $e(u, v)$ ，那么对于新的第 $t$ 层，连接 $P_{u,t}$ 和 $P_{v, t}$ ，流量限制为 $H_i$ ，即太空船 $i$ 的承载上限； 由于人可以在任意太空站上一直等，所以对于所有点 $P_i$ ，连接 $P_{i,t-1}$ 和 $P_{i,t}$ ，流量限制为 $INF$ ，因为太空站的承载能力是无限的； 设汇点为初始时刻的月球编号 $T_0$ ，那么连接 $T_{t+1}$ 和 $T_{t}$，流量限制为 $INF$，如此任意时刻新增的流量可以回到$T_0$ 方便统计。 不能使用ISAP跑最大流，选择用Dinic。 因为Dinic是多次分层，而ISAP是一次分层，无法处理新加进来的点。 循环当前时刻$t$ 并直接在残余网络上加边构建分层图，累计流量直到超过 $k$ 输出 $t$ 并跳出。 注意不能使用capacity scaling来优化Dinic，这样增加新边后似乎是跑不出最大流的… 复杂度分析Dinic算法求最大流的复杂度上界为 $O(V^2\\times E)$ 。 分层图新建 $t$ 层，复杂度$O(t\\times V^2 \\times E)$。 $E$ 最大为 $n\\times m$ ，最坏情况下只存在一条路径经过所有点从地球到达月球，且限制为1，此时 $t$ 为 $n\\times k$。 所以复杂度的上界为 $O(n^3\\times m^2 \\times k)$，对于如此小的 $n,m,k$ ，跑起来毫无压力。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { register T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { register char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} register bool f = c == '-'; register T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif} // namespace ionamespace uf {const int MAXN = 20;int Fa[MAXN];void init(int n) { rep(i, 0, n) { Fa[i] = i; }}int find(int x) { return Fa[x] == x ? x : Fa[x] = find(Fa[x]);}void merge(int x, int y) { x = find(x), y = find(y); if (x != y) { Fa[y] = x; }}} // namespace ufnamespace dinic {const int MAXN = 1200 + 5;const int MAXM = 12000 + 5;const int MAXK = 50 + 5;const int INF = INT_MAX;struct Edge { int v, f, nxt;} E[MAXM &lt;&lt; 1];int K, n, S, T;int A[MAXN][MAXK];int H[MAXN], cntE;int Dis[MAXN];bool bfs() { static std::queue&lt;int&gt; q; memset(Dis, -1, sizeof Dis); Dis[S] = 0; q.push(S); while (!q.empty()) { int x = q.front(); q.pop(); for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &gt; 0 &amp;&amp; !~Dis[v]) { Dis[v] = Dis[x] + 1; q.push(v); } } } return ~Dis[T];}void addEdge(int u, int v, int f) { E[++cntE] = (Edge) {v, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -f, H[v]}; H[v] = cntE;}int dfs(int x, int maxf) { if (x == T || !maxf) { return maxf; } int curf = 0; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (Dis[v] == Dis[x] + 1 &amp;&amp; E[i].f &gt; 0) { int flow = dfs(v, std::min(E[i].f, maxf - curf)); E[i].f -= flow, E[i ^ 1].f += flow; curf += flow; if (curf == maxf) { return curf; } } } return curf;}int dinic() { static int ans = 0; while (bfs()) { ans += dfs(S, INF); } return ans;}void init() { cntE = -1; memset(H, -1, sizeof H); n = io::gt&lt;int&gt;(), A[0][0] = io::gt&lt;int&gt;(), K = io::gt&lt;int&gt;(); T = n + 1; uf::init(T + 1); rep(i, 1, A[0][0] + 1) { A[0][i] = io::gt&lt;int&gt;(); A[i][0] = io::gt&lt;int&gt;(); rep(j, 1, A[i][0] + 1) { int x = io::gt&lt;int&gt;(); A[i][j] = ~x ? x : T; if (j &gt; 1) { uf::merge(A[i][j - 1], A[i][j]); } } } if (uf::find(S) != uf::find(T)) { puts(\"0\"); exit(0); }}void addGraph(int t) { rep(i, 0, n + 1) { addEdge(i + (t - 1) * (n + 2), i + t * (n + 2), INF); } addEdge(n + 1 + t * (n + 2), n + 1 + (t - 1) * (n + 2), INF); rep(i, 1, A[0][0] + 1) { int tmp = (t - 1) % A[i][0] + 1; addEdge(A[i][tmp] + (t - 1) * (n + 2) , A[i][t % A[i][0] + 1] + t * (n + 2), A[0][i]); }}int maxFlow() { init(); for (int t = 1; ; ++t) { addGraph(t); if (dinic() &gt;= K) { return t; } }}} // namespace dinicint main() { printf(\"%d\\n\", dinic::maxFlow()); return 0;}","link":"/LOJ-6015/"},{"title":"「SCOI 2012」BZOJ 2753 滑雪与时间胶囊","text":"有 $N$ 个点，每个点存在权值 $H_i$ 。有 $M$ 条边 $(u, v, w)$ ，如果 $H_u &lt; H_v$ ，那么这条边就是 $u\\rightarrow v$ ，反之是 $v \\rightarrow u$ 的。如果 $H_u = H_v$ ，那么这是一条无向边。 求以 $1$ 为根节点的生成树的最大节点个数，以及在节点数最大的情况下的最小权值和。 $1\\leq N\\leq 10^5,1\\leq M\\leq 10^ 6,1\\leq H_i\\leq 10^9$ 分析最小树形图如果不看数据范围，这是一个裸的最小树形图（无向边拆成两条有向边）。 先用bfs跑一遍可以得到节点 $1$ 可以到达的所有点，即第一问。复杂度 $O(N)$。 然后重新构图，使用朱刘算法在新图上求最小树形图的权值和。复杂度 $O(N\\times M)$ 。 这个上界很松，而且发现时间瓶颈很大程度在读入 3e6 的数据上。 随机数据应该是远远跑不满的，而且也没有听说专门卡它的构造数据方法。 最后提交发现该代码在BZOJ和luogu的评测机上均能通过。 BZOJ上此题时限50s，实测39.3s，并不算卡过去的。 最小生成树实际上刚看到这个数据范围，给我的第一感觉是：“就算上界很松也肯定跑不过啊……”。 但是求有向图的最小树形图，朱刘算法已经是很高效的了。 虽然存在 R.E.Tarjan 在1986年提出的 $O(E+V\\log{V})$ 的改进算法，但是国内基本没有相关资料。 看来出题人考不存在的（没见过=不存在）改进算法的几率不大。 相比于最小树形图，求无向图的最小生成树就有很好写，而且复杂度更低的算法。 例如 Prim's algorithm （复杂度 $O(V\\times \\log{V}$ ）和 Kruskal's algorithm （复杂度 $O(E\\times \\log{E})$）。 再思考为什么有向图求最小树形图的时候不能用它们，是因为最后可能会出现边指向根节点的情况，这样就不是一棵生成树了。 对于这道题而言，发现反向边只会在 $H_u=H_v$ 的时候出现。 假如可以处理掉它，那么模型就从最小树形图转化成最小生成树，复杂度也就足够优秀了。 根据这道题节点间的特殊性质，对于一棵生成树的任意节点所有可能的父亲节点，权值一定都大于等于它。 那么对于有向边 $(u, v, w)$ ，优先处理 $H_v$ 大的边， $H_v$ 相同时优先选择 $w$ 小的边，就能保证不会出现反向边。 如果生成树 $T1$ 中某节点 $y$ 通过边 $(x,y,w)$ 合并到另一个生成树 $T2$ 的节点 $x$ 上，那么就会出现反向边（即边 $(y,x,w)$）。 但是这是不会发生的，因为如果出现两棵生成树，那么图就不存在生成树了（ 已经经过了所有以 $T2$ 根节点为终点的边，既然没有与 $T1$ 合并，就说明无法合并了。而这是与第一问得到的都联通情况相违背） 因此通过 Kruskal's algorithm 求最小生成树是正确的，求得权值和即为第二问答案。 参考代码最小树形图 - Chu-Liu/Edmonds’ algorithm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;const int MAXN = 1e5 + 5;const int MAXM = 1e6 + 5;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif} // namespace iostruct Graph { struct Edge { int u, v, w; }; int N; std::vector&lt;Edge&gt; E; void init(int n) { N = n; E.clear(); } void addEdge(int u, int v, int w) { E.push_back((Edge) {u, v, w}); } ll MST_Directed(int rt) { static int Pre[MAXN], Cir[MAXN], Id[MAXN]; static ll Inw[MAXN]; ll ans = 0; while(true) { memset(Inw, 127 / 3, sizeof(ll) * N); memset(Pre, -1, sizeof(int) * N); memset(Cir, -1, sizeof(int) * N); memset(Id, -1, sizeof(int) * N); ll INF = Inw[0]; rep(i, 0, SZ(E)) { if(Inw[E[i].v] &gt; E[i].w &amp;&amp; E[i].v != E[i].u) { Inw[E[i].v] = E[i].w; Pre[E[i].v] = E[i].u; } } Pre[rt] = rt, Inw[rt] = 0; rep(i, 0, N) { if(Inw[i] == INF) { return -1; } ans += Inw[i]; } int circle = 0; rep(i, 0, N) { if(Cir[i] != -1) { continue; } int t = i; while(Cir[t] == -1) { Cir[t] = i; t = Pre[t]; } if(t != rt &amp;&amp; Cir[t] == i) { Id[t] = circle++; for(int j = Pre[t]; j != t; j = Pre[j]) { Id[j] = circle - 1; } } } if(!circle) { return ans; } rep(i, 0, N) { if(Id[i] == -1) { Id[i] = circle++; } } rep(i, 0, SZ(E)) { E[i].w -= Inw[E[i].v]; E[i].u = Id[E[i].u]; E[i].v = Id[E[i].v]; } N = circle; rt = Id[rt]; } }}G;int H[MAXN], Id[MAXN];struct Graph2 { struct Edge { int v, nxt; }E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; void init(int n) { memset(H, -1, sizeof(int) * n); cntE = -1; } void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; } int bfs(int x) { static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; static std::bitset&lt;MAXN&gt; Vis; int n = 1; Id[x] = n++; Vis[x] = 1; Que.push(x); while(!Que.empty()) { int x = Que.front(); Que.pop(); for(int i = H[x]; ~i; i = E[i].nxt) { if(!Vis[E[i].v]) { Que.push(E[i].v); Vis[E[i].v] = 1; Id[E[i].v] = n++; } } } return n; }}G2;int U[MAXM], V[MAXM], W[MAXM];int main() { int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { H[i] = io::gt&lt;int&gt;(); } G2.init(N + 1); rep(i, 0, M) { U[i] = io::gt&lt;int&gt;(); V[i] = io::gt&lt;int&gt;(); W[i] = io::gt&lt;int&gt;(); if(H[U[i]] &gt;= H[V[i]]) { G2.addEdge(U[i], V[i]); } if(H[U[i]] &lt;= H[V[i]]) { G2.addEdge(V[i], U[i]); } } int n = G2.bfs(1); rep(i, 0, M) { if(Id[U[i]] &amp;&amp; Id[V[i]]) { if(H[U[i]] &gt;= H[V[i]]) { G.addEdge(Id[U[i]], Id[V[i]], W[i]); } if(H[V[i]] &gt;= H[U[i]]) { G.addEdge(Id[V[i]], Id[U[i]], W[i]); } } } G.addEdge(0, Id[1], 0); G.N = n; ll ans = G.MST_Directed(0); printf(\"%d %lld\\n\", n - 1, ans); return 0;} 最小生成树 - Kruskal’s algorithm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out;template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c;}void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}#endif} // namespace ioconst int MAXN = 1e5 + 5;const int MAXM = 1e6 + 5;int H[MAXN];struct Graph { struct Edge { int u, v, w, nxt, can; bool operator &lt; (const Edge &amp;x) const { return ::H[v] != ::H[x.v] ? ::H[v] &gt; ::H[x.v] : w &lt; x.w; } }E[MAXM &lt;&lt; 1]; int H[MAXN], cntE; int Fa[MAXN], Rank[MAXN]; void init(int n) { memset(H, -1, sizeof(int) * n); cntE = -1; rep(i, 0, n) { Fa[i] = i; Rank[i] = 1; } } void addEdge(int u, int v, int w) { E[++cntE] = (Edge) {u, v, w, H[u], 0}; H[u] = cntE; } int bfs(int x) { static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; static std::bitset&lt;MAXN&gt; Vis; int n = 1; Vis[x] = 1; Que.push(x); while(!Que.empty()) { int x = Que.front(); Que.pop(); for(int i = H[x]; ~i; i = E[i].nxt) { E[i].can = 1; if(!Vis[E[i].v]) { Que.push(E[i].v); Vis[E[i].v] = 1; n++; } } } return n; } int findFa(int x) { return x == Fa[x] ? x : Fa[x] = findFa(Fa[x]); } bool merge(int u, int v) { u = findFa(u), v = findFa(v); if(u == v) { return false; } if(Rank[u] &lt; Rank[v]) { Fa[u] = v; } else { Fa[v] = u; if(Rank[u] == Rank[v]) { Rank[u]++; } } return true; } ll kruskal(int n) { ll ans = 0; int k = 1; static std::vector&lt;Edge&gt; V; rep(i, 0, cntE + 1) { if(E[i].can) { V.push_back(E[i]); } } std::sort(ALL(V)); rep(i, 0, SZ(V)) { if(k == n) { return ans; } if(merge(V[i].u, V[i].v)) { ans += V[i].w; ++k; } } }}G;int main() { int N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { H[i] = io::gt&lt;int&gt;(); } G.init(N + 1); rep(i, 0, M) { int u = io::gt&lt;int&gt;(), v = io::gt&lt;int&gt;(), w = io::gt&lt;int&gt;(); if(H[u] &gt;= H[v]) { G.addEdge(u, v, w); } if(H[u] &lt;= H[v]) { G.addEdge(v, u, w); } } int n = G.bfs(1); ll sum = G.kruskal(n); printf(\"%d %lld\\n\", n, sum); return 0;} 参考资料【最小树形图】——bzoj2753——朱刘算法达不到复杂度要求时的，改模板kruskal算法","link":"/BZOJ-2753/"},{"title":"「JLOI 2014」BZOJ 3631 松鼠的新家","text":"一棵树有 $N$ 个节点，需要按照 $A[1…N]$ 的顺序依次访问，每次走最短路径。 求每个节点各经过多少次。 $2\\leq N\\leq 300000$ 分析树上差分从 $u$ 到 $v$ 的路径即 $u\\rightarrow lca(u,v)\\rightarrow v$ 。 由于只需要输出一次，考虑树上差分。 $O(1)$ 修改， $O(N)$ 查询的复杂度在这里正合适。 用Tarjan或者其他lca算法得到 $lca(A[i],A[i+1])$ ，然后对两段路径进行差分。 最后将除了根节点的每个节点经过次数-1，因为它们在差分的过程中既被当成前一条路径终点，又被当作后一条路径的起点，重复计算两次。 复杂度 $O(N)$ 。 树状数组树链剖分+区间修改/单点查询树状数组。 复杂度 $O(N\\log^2{N})$ 。 参考代码树上差分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; void pt(T x, char c = '\\n') { static int S[20], *vp; vp = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++vp = x % 10, x /= 10; } while (x); while (vp != S) { *cur++ = *vp-- + '0'; } *cur++ = c; if (cur &gt;= end) { fflush(); }}#endif} // namespace ioconst int MAXN = 300000 + 5;int Faa[MAXN], Lca[MAXN];int H[MAXN], cnt;int N, R;int Fa[MAXN], Add[MAXN];struct Edge { int v, nxt;} Q[MAXN &lt;&lt; 1], E[MAXN &lt;&lt; 1];int H2[MAXN], cntE;void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; return ;}void addQuery(int u, int v) { Q[cnt] = (Edge) {v, H2[u]}; H2[u] = cnt++; Q[cnt] = (Edge) {u, H2[v]}; H2[v] = cnt++; return ;}int findFa(int x) { return Faa[x] == x ? x : Faa[x] = findFa(Faa[x]);}void dfs(int x) { Faa[x] = x; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; dfs(v); Faa[v] = x; } } for (int i = H2[x]; ~i; i = Q[i].nxt) { int &amp;v = Q[i].v; if (Fa[v]) { Lca[i &gt;&gt; 1] = findFa(v); } }}void dfs2(int x) { for(int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if(v != Fa[x]) { dfs2(v); Add[x] += Add[v]; } }}int A[MAXN];int main() { N = io::gt&lt;int&gt;(); memset(H2, -1, sizeof H2); rep(i, 1, N + 1) { A[i] = io::gt&lt;int&gt;(); } R = A[1]; rep(i, 2, N + 1) { addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); addQuery(A[i - 1], A[i]); } dfs(R); rep(i, 2, N + 1) { ++Add[A[i - 1]]; ++Add[A[i]]; --Add[Lca[i - 2]]; --Add[Fa[Lca[i - 2]]]; } dfs2(R); ++Add[R]; rep(i, 1, N + 1) { io::pt(Add[i] - 1); } io::fflush(); return 0;} 树状数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void fflush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void fflush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if(cur &gt;= end) { fflush(); }}#endif} // namespace ioconst int MAXN = 300000 + 5;int A[MAXN];struct Graph { struct Edge { int v, nxt; } E[MAXN &lt;&lt; 1]; int N, R; int H[MAXN], cntE; int Depth[MAXN], Sz[MAXN], Son[MAXN], Fa[MAXN]; int Dfn[MAXN], cntD, Top[MAXN]; int C[MAXN]; void addEdge(int u, int v) { E[++cntE] = (Edge) {v, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v]}; H[v] = cntE; } void dfs(int x) { Sz[x] = 1, Son[x] = 0; for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x]) { Fa[v] = x; Depth[v] = Depth[x] + 1; dfs(v); Sz[x] += Sz[v]; if (Sz[Son[x]] &lt; Sz[v]) { Son[x] = v; } } } } void dfs2(int x, int top) { Top[x] = top; Dfn[x] = ++cntD; if (Son[x]) { dfs2(Son[x], top); } for (int i = H[x]; i; i = E[i].nxt) { int &amp;v = E[i].v; if (v != Fa[x] &amp;&amp; v != Son[x]) { dfs2(v, v); } } } int lowbit(int x) { return x &amp; -x; } void update(int A[], int p, int x) { for (; p &lt;= N; p += lowbit(p)) { A[p] += x; } } void add(int l, int r, int x) { update(C, l, x); update(C, r + 1, -x); } int sum(int A[], int p) { int res = 0; for (; p &gt; 0; p -= lowbit(p)) { res += A[p]; } return res; } int query(int x) { return sum(C, x); } void prepare() { dfs(R); dfs2(R, R); } void addPath(int u, int v, int x = 1) { int tu = Top[u], tv = Top[v]; while (tu != tv) { if (Depth[tu] &gt; Depth[tv]) { std::swap(u, v); std::swap(tu, tv); } add(Dfn[tv], Dfn[v], x); v = Fa[tv]; tv = Top[v]; } if (Depth[u] &gt; Depth[v]) { std::swap(u, v); } add(Dfn[u], Dfn[v], x); }} G;int main() { G.N = io::gt&lt;int&gt;(); rep(i, 1, G.N + 1) { A[i] = io::gt&lt;int&gt;(); } G.R = A[1]; rep(i, 1, G.N) { G.addEdge(io::gt&lt;int&gt;(), io::gt&lt;int&gt;()); } G.prepare(); rep(i, 2, G.N + 1) { G.addPath(A[i], A[i - 1]); } G.add(G.Dfn[A[1]], G.Dfn[A[1]], 1); rep(i, 1, G.N + 1) { io::pt(G.query(G.Dfn[i]) - 1); } io::fflush(); return 0;}","link":"/BZOJ-3631/"},{"title":"「BJWC 2018」BZOJ 5148 kakuro","text":"kakuro是一个神奇的数独游戏，大致规则如下： $N\\times M​$ 的网格图中，由一些格子为空格需要填数，一些格子填线索，一些格子什么都不填 线索有两个方向，分别为右和下，线索的值表示该方向连续空格所填数之和 对于任意一个空格，其左边与上边的一定存在一个格子为线 游戏规则： 空格中填入正整数。 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。 Apia 给了Rimbaud 一个Kakuro 谜题。心不灵手不巧的Rimbaud 根本不会做Kakuro，所以只在空格里面填上了一些随机的数字，称这个为一个局面，即包含了谜题一开始给出的线索和后面填入的数字。 现在Rimbaud 希望能修改这个局面使得她的答案是一个合法解。这个局面中有些数字(包括一开始的给出线索和后面填入的数字) 是可以修改的。每个数字都有个特定的代价，将这个数字加 $1$ 或者减 $1$ 都得付出这个数字对应的代价。注意对于一组合法解，必须满足游戏规则，也就是空格中填的数字必须是正整数并且满足和的条件，但是不要求不重复。 Rimbaud 希望用最少的代价让这个局面变得合法，如果不可能那么输出-1 。 $3 \\leq n,m \\leq 30$，保证初始局面中的每个数字不超过 $10^6$ ，保证每个数字的代价不超过 $10^6$ 。 分析致谢感谢AloNE的讲解。 正题一个思路就是先做出一个合法解，然后再去修改权值以减少总花费。 那么最简单的合法解，就是每个空格都填 $1$ ，线索填对应格子的个数。 如此保证了每个空格都是正整数，这是一个最小解。 记当前花费为 $Ans$ 。 记某个格子现在的值为 $A(x,y)$ ，原来的值为 $O(x,y)$ ，修改 $1$ 的价格为 $C(x,y)$ 。 那么每个空格和线索只能往大修改，那么有两种情况。 $A(x,y) \\leq O(x,y)$ ，那么当 $A(x,y)$ 最初变大直到 $O(x,y)$ 时，相当于对最开始的修改进行反悔，也就是说花费 $-C(x,y)$；当然对于超出 $O(x,y)$ 的部分继续花费 $C(x,y)$ 。 $A(x,y) \\geq O(x,y)$ ，那么修改继续增加花费 $C(x,y)$ 。 转化成网络流问题，将这些关系抽象成如下的边： 发现对于修改一个空格会对其左边和上边的两个线索产生影响，约束方法很简单，就是流量从其上面的线索流入，从其左边的线索流出，那么保证所有增加的流量都是合法的；也就是说空格本质就是一条连接横向和竖向线索的边； 根据上面的建模方法，$S$ 连接所有竖向线索，费用为 $C(x,y)$ ，流量不限； 所有横向线索连接 $T$ ，费用为 $C(x,y)$ ，流量不限； 对于所有空格，如果 $A(x,y) \\leq O(x,y)$ ，连接费用为 $-C(x,y)$ 流量为 $O(x,y) - A(x,y)$ ，意为对最初的修改进行反悔；（对应的两个线索之间连边） 对于所有空格，连接费用为 $C(x,y)$ ，流量不限的边，因为每个格子都可以无限增大。 跑最小费用可行流，当前费用 $Cost \\geq 0$ 时结束。 得到最小费用 $C$ ，那么最终结果 $Ans + C$ 。 那么如何判断无解的情况？ 无解也就是说修改了不能修改的边。 那么将不能修改的边的费用置为 $INF$ ，跑完最小费用可行流之后检查残余与网络是否存在费用为 $INF$ 的反向边流量不为 $0$ 或者费用为 $-INF$ 的边流量不为 $0$ 。 如果出现这种情况，说明了必须修改不能修改的格子权值以满足流量平衡，输出 -1 即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }namespace io {#ifndef ONLINE_JUDGEchar gc() { return getchar();}template &lt;class T&gt; inline T gt() { static T x; std::cin &gt;&gt; x; return x;}template &lt;typename T&gt; inline void pt(T x, const char c = '\\n') { std::cout &lt;&lt; x &lt;&lt; c;}void flush() {}#elseconst int MAXSIZE = 1 &lt;&lt; 22;inline char gc() { static char In[MAXSIZE], *at = In, *en = In; if (at == en) { en = (at = In) + fread(In, 1, MAXSIZE, stdin); } return at == en ? EOF : *at++;}template &lt;class T&gt; inline T gt() { char c; while (c = gc(), !isdigit(c) &amp;&amp; c != '-') {} bool f = c == '-'; T x = f ? 0 : c - '0'; for (c = gc(); isdigit(c); c = gc()) { x = x * 10 + c - '0'; } return f ? -x : x;}char Out[MAXSIZE], *cur = Out, *end = Out + MAXSIZE - 100;void flush() { fwrite(Out, 1, cur - Out, stdout); cur = Out;}template &lt;typename T&gt; inline void pt(T x, char c = '\\n') { static int S[20], *top; top = S; if (x &lt; 0) { *cur++ = '-', x = -x; } do { *++top = x % 10, x /= 10; } while (x); while (top != S) { *cur++ = *top-- + '0'; } *cur++ = c; if (cur &gt;= end) { flush(); }}#endif} // namespace ioconst int MAXN = 30 + 5;const int INF = 1e9 + 7;namespace mcf {const int MAXN = ::MAXN * ::MAXN * 4;const int MAXM = MAXN;struct Edge { int v, c, f, nxt;} E[MAXM &lt;&lt; 1];int S, T;ll C, F, Dis[MAXN];int H[MAXN], cntE;int Lp[MAXN], Le[MAXN];void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, c, f, H[u]}; H[u] = cntE; E[++cntE] = (Edge) {u, -c, 0, H[v]}; H[v] = cntE;}bool spfa() { static std::bitset&lt;MAXN&gt; Inq; static std::queue&lt;int, std::deque&lt;int&gt; &gt; Que; Inq = 0; memset(Dis, 0x3f, sizeof Dis); Dis[S] = 0; Que.push(S); while (!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for (int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if (E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if (!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] &lt; 0;}void mcf() { while (spfa()) { int f = INF; for (int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } C += f * Dis[T]; F += f; for (int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } }}void init() { memset(H, -1, sizeof H); cntE = -1; C = F = 0;}bool check() { for (int i = 0; i &lt;= cntE; i += 2) { if (E[i].c == INF &amp;&amp; E[i ^ 1].f &gt; 0) { return false; } if (E[i].c == -INF &amp;&amp; E[i].f &gt; 0) { return false; } } return true;}}int N, M;int Type[MAXN][MAXN];int Column[MAXN][MAXN], Line[MAXN][MAXN], Ori[MAXN][MAXN];int ChangeC[MAXN][MAXN], ChangeL[MAXN][MAXN], ChangeO[MAXN][MAXN];int IdC[MAXN][MAXN], IdL[MAXN][MAXN];int Left[MAXN][MAXN], Up[MAXN][MAXN];int AfterC[MAXN][MAXN], AfterL[MAXN][MAXN], AfterO[MAXN][MAXN];int main() { mcf::init(); int cnt = 0; N = io::gt&lt;int&gt;(), M = io::gt&lt;int&gt;(); rep(i, 1, N + 1) { rep(j, 1, M + 1) { Type[i][j] = io::gt&lt;int&gt;(); } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { Column[i][j] = io::gt&lt;int&gt;(); IdC[i][j] = ++cnt; } if (Type[i][j] == 2 || Type[i][j] == 3) { Line[i][j] = io::gt&lt;int&gt;(); IdL[i][j] = ++cnt; } if (Type[i][j] == 4) { Ori[i][j] = io::gt&lt;int&gt;(); } } } mcf::S = 0, mcf::T = cnt + 1; rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { ChangeC[i][j] = io::gt&lt;int&gt;(); if (ChangeC[i][j] == -1) { ChangeC[i][j] = INF; } } if (Type[i][j] == 2 || Type[i][j] == 3) { ChangeL[i][j] = io::gt&lt;int&gt;(); if (ChangeL[i][j] == -1) { ChangeL[i][j] = INF; } } if (Type[i][j] == 4) { ChangeO[i][j] = io::gt&lt;int&gt;(); if (ChangeO[i][j] == -1) { ChangeO[i][j] = INF; } } } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { int k = i + 1; while (k &lt;= N &amp;&amp; Type[k][j] == 4) { Up[k++][j] = IdC[i][j]; } AfterC[i][j] = k - i - 1; mcf::C += 1ll * ChangeC[i][j] * std::abs(AfterC[i][j] - Column[i][j]); } if (Type[i][j] == 2 || Type[i][j] == 3) { int k = j + 1; while (k &lt;= M &amp;&amp; Type[i][k] == 4) { Left[i][k++] = IdL[i][j]; } AfterL[i][j] = k - j - 1; mcf::C += 1ll * ChangeL[i][j] * std::abs(AfterL[i][j] - Line[i][j]); } if (Type[i][j] == 4) { AfterO[i][j] = 1; mcf::C += 1ll * ChangeO[i][j] * std::abs(AfterO[i][j] - Ori[i][j]); } } } rep(i, 1, N + 1) { rep(j, 1, M + 1) { if (Type[i][j] == 1 || Type[i][j] == 3) { if (AfterC[i][j] &lt; Column[i][j]) { mcf::addEdge(mcf::S, IdC[i][j], Column[i][j] - AfterC[i][j], -ChangeC[i][j]); } mcf::addEdge(mcf::S, IdC[i][j], INF, ChangeC[i][j]); } if (Type[i][j] == 2 || Type[i][j] == 3) { if (AfterL[i][j] &lt; Line[i][j]) { mcf::addEdge(IdL[i][j], mcf::T, Line[i][j] - AfterL[i][j], -ChangeL[i][j]); } mcf::addEdge(IdL[i][j], mcf::T, INF, ChangeL[i][j]); } if (Type[i][j] == 4) { if (AfterO[i][j] &lt; Ori[i][j]) { mcf::addEdge(Up[i][j], Left[i][j], Ori[i][j] - AfterO[i][j], -ChangeO[i][j]); } mcf::addEdge(Up[i][j], Left[i][j], INF, ChangeO[i][j]); } } } mcf::mcf(); if (!mcf::check()) { printf(\"-1\\n\"); } else { printf(\"%lld\\n\", mcf::C); } return 0;}","link":"/BZOJ-5148/"},{"title":"LOJ 6014 最长 k 可重区间集","text":"直线上有 $N$ 个开区间 $(x_i,y_i)$，从中选取任意多个，满足该直线上任意一个点最多被 $K$ 个区间覆盖，求选取区间的最大长度和。 $1\\leq N\\leq 500$ $1\\leq K\\leq 3$ 分析$O(N^2)$ 建图方法以区间长度作为费用，目标即让总费用最大。 每个区间只能选一次，所以要拆点。 问题在于如果保证任何一个点至多被覆盖 $K$ 次。 显然，如果任意选择 $K$ 个区间，那么不可能出现某个点被覆盖超过 $K$ 次。 如果选择一个区间，再去选择一个与它不相交的区间，那么依然不会出现某个点被覆盖超过 $K$ 次的情况。 那么如果在这个基础上再选择一个与另一个区间不相交的区间呐？是否会出现某个点被覆盖 $K + 1$ 次的情况？ 令开始选取的区间为 $A_1….A_K$，第一次增加了与 $A_1$ 不相交的区间 $B_1$，第二次增加了与 $A_2$ 不相交的区间 $B_2$ ，以 $X{a,b,c}=s$ 表示区间集合 ${a,b,c}$ 覆盖的点中，被覆盖次数最大次数为 $s$ 。 根据之前的描述，$X{A_1…A_K} \\leq K$ ，$X{A_1,B_1,A_2…A_k} \\leq K$ 。 由于 $A_1\\cap B_1=\\emptyset$，所以 $X{B_1,A_2…A_k} \\leq K$。 如果增加 $B_2$ 之后覆盖了某个点 $K + 1$ 次，那么就是 $X{A_1,B_1,A_2,B_2,A_3…A_K} = K+1$ 。 由于 $A_2\\cap B_2=\\emptyset$，所以等价为 $X{A_1,B_1,B_2…A_k} = K+1$。 集合中共有 $K+1$ 个数，若满足上式，即需要其中任意两个集合都有交，且所有交集的交不为 $\\emptyset$ 。 但是 $A_1\\cap B_1=\\emptyset$ ，所以上式一定不成立。 也就是说增加 $B_2$ 依然不会出现某个点被覆盖 $K+1$ 次。 同理按照选取不相交区间的原则增加 $B_3$ ， $B_4$ $…$，都不会出现某个点被覆盖 $K+1$ 次的情况。 所以说问题转化为从 $N$ 个区间中任意选取 $K$ 个，选择完某区间后可以再选择一个与它不相交的区间，求选取的所有区间总长度最大值。 转化成网络流模型： 每个区间拆点成 $X_i,Y_i$ $S$ 向 $S’$ 连一条流量限制为 $K$，费用为 $0$ 的边 $S’$ 向所有 $X_i$ 连接流量限制为 $1$ ，费用为 $0$ 的边 $X_i$ 向 $Y_i$ 连接流量限制为 $1$ ，费用为区间长度的边 $Y_i$ 向 $X_j$ 连接流量限制为 $1$ ，费用为 $0$ 的边，其中 $i\\leq j$ 且区间 $i,j$ 不相交 所有 $Y_i$ 向 $T$ 连接一条流量限制为 $1$， 费用为 $0$ 的边。 求最大费用最大流。 费用取反跑最小费用流，其结果再取反即为答案。 $O(N\\times \\log{N})$ 建图方法根据 $O(N^2)$ 建图方法，我们明白了网络流模型转化的核心，即共 $K$ 条流量，任意一个点可以流向与其不相交的区间所对应的点，跑费用流。 建图的瓶颈在于找到所有不相交的区间，需要 $O(N^2)$ 的遍历。 比较显然的一点，就是如果按照左端点排序区间，如果 $(x_i,y_i)$ 与 $(x_j,y_j)$ 不相交，且 $j-i$ 最小，那么对于区间 $(x_k,y_k)(k\\geq j)$ ，一定也不和 $(x_i,y_i)$ 相交。 也就是说我们可以在 $O(\\log{N})$ 的时间内找到第一个与 $(x_i,y_i)$ 不相交的区间。 那么如果能让流量到达 $(x_j,y_j)$ 后“自然地向后流“，就相当于可以流到所有和 $(x_i,y_i)$ 不相交的区间。 想象整个直线是一条河，入河口流入 $K$ 点流量。这条河可以通过无限流量且费用为 $0$ 。每个节点在对应的坐标上，是一块河中一块小陆地。那么在所有区间的左右端点之间架一座桥，允许 $1$ 的流量通过，费用为区间长度。 流量从 $x_i\\rightarrow y_i$ 之后，这一点流量可以选择再跨越后面任何一座没有流量经过的桥，或者一直沿着河流，直到河的尽头。 这么流依然保证了其合法性，但是建图复杂度大大降低了。 离散化所有结点，即 $h(a) $ 为 $a$ 的重标号， $0$ 和 $n’$ 分别为第一个和最后一个点 $h(x_i)\\rightarrow h(y_i)$ ，费用为 $y_i-x_i$，流量限制为$1$ $i\\rightarrow i+1$，费用为$0$，流量限制为无穷 $s\\rightarrow 0$，费用为 $0$ ，流量限制为 $K$ $n’\\rightarrow T$ ，费用为 $0$ ，流量限制为 $K$ 求 $S-T$ 最大费用最大流，方法同理 离散化复杂度 $O(N\\times \\log{N})$ ，求 $h(a)$ 的复杂度 $O(\\log{N})$，所以建图复杂度为$O(N\\times \\log{N})$ 。 注意事项 从来没有说过 $y_i\\geq x_i$ 参考代码法一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace mcmf {const int MAXN = 1000 + 5;const int MAXM = MAXN * MAXN;struct Edge { int v, nxt, f, c;}E[MAXM &lt;&lt; 2];int S, T, F, C;int H[MAXN], cntE;int Lp[MAXN], Le[MAXN], Dis[MAXN];bool Inq[MAXN];void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, H[u], f, c}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v], 0, -c}; H[v] = cntE;}void init() { memset(H, -1, sizeof H); cntE = -1; static int N, K; static std::pair&lt;int, int&gt; P[MAXN]; scanf(\"%d%d\", &amp;N, &amp;K); S = N * 2, T = N * 2 + 2; addEdge(S, S + 1, K, 0); rep(i, 0, N) { scanf(\"%d%d\", &amp;P[i].first, &amp;P[i].second); if(P[i].first &gt; P[i].second) { std::swap(P[i].first, P[i].second); } } std::sort(P, P + N); rep(i, 0, N) { addEdge(S + 1, i, 1, 0); addEdge(i + N, T, 1, 0); addEdge(i, i + N, 1, P[i].first - P[i].second); rep(j, i + 1, N) { if(P[j].first &gt;= P[i].second) { addEdge(i + N, j, 1, 0); } } }}bool spfa() { static std::queue&lt;int&gt; Que; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if(!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;}void mcmf() { init(); while(spfa()) { int f = INT_MAX; for(int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } F += f; C += Dis[T] * f; for(int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } } printf(\"%d\\n\", -C);}}int main() { mcmf::mcmf(); return 0;} 法二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// Copyright 2018, Skqliao#include &lt;bits/stdc++.h&gt;#define rg register#define rep(i, l, r) for (rg int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (rg int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;namespace mcmf {const int MAXN = 1000 + 5;const int MAXM = MAXN * MAXN;struct Edge { int v, nxt, f, c;}E[MAXM &lt;&lt; 2];int S, T, F, C;int H[MAXN], cntE;int Lp[MAXN], Le[MAXN], Dis[MAXN];bool Inq[MAXN];void addEdge(int u, int v, int f, int c) { E[++cntE] = (Edge) {v, H[u], f, c}; H[u] = cntE; E[++cntE] = (Edge) {u, H[v], 0, -c}; H[v] = cntE;}void init() { memset(H, -1, sizeof H); cntE = -1; static int N, K; static std::pair&lt;int, int&gt; P[MAXN]; scanf(\"%d%d\", &amp;N, &amp;K); static int Hash[MAXN], total = 0; rep(i, 0, N) { scanf(\"%d%d\", &amp;P[i].first, &amp;P[i].second); if(P[i].first &gt; P[i].second) { std::swap(P[i].first, P[i].second); } Hash[total++] = P[i].first; Hash[total++] = P[i].second; } std::sort(Hash, Hash + total); total = std::unique(Hash, Hash + total) - Hash; S = total, T = total + 1; addEdge(S, 0, K, 0); addEdge(total - 1, T, K, 0); rep(i, 1, total) { addEdge(i - 1, i, INT_MAX, 0); } rep(i, 0, N) { int x = std::lower_bound(Hash, Hash + total, P[i].first) - Hash; int y = std::lower_bound(Hash, Hash + total, P[i].second) - Hash; addEdge(x, y, 1, P[i].first - P[i].second); }}bool spfa() { static std::queue&lt;int&gt; Que; memset(Dis, 0x3f, sizeof Dis); int INF = Dis[0]; Dis[S] = 0; Que.push(S); while(!Que.empty()) { int x = Que.front(); Que.pop(); Inq[x] = false; for(int i = H[x]; ~i; i = E[i].nxt) { int &amp;v = E[i].v; if(E[i].f &amp;&amp; Dis[v] &gt; Dis[x] + E[i].c) { Dis[v] = Dis[x] + E[i].c; Lp[v] = x, Le[v] = i; if(!Inq[v]) { Inq[v] = true; Que.push(v); } } } } return Dis[T] != INF;}void mcmf() { init(); while(spfa()) { int f = INT_MAX; for(int i = T; i != S; i = Lp[i]) { f = std::min(f, E[Le[i]].f); } F += f; C += Dis[T] * f; for(int i = T; i != S; i = Lp[i]) { E[Le[i]].f -= f; E[Le[i] ^ 1].f += f; } } printf(\"%d\\n\", -C);}}int main() { mcmf::mcmf(); return 0;}","link":"/LOJ-6014/"},{"title":"Miller–Rabin学习笔记","text":"对于检查一个数是否为素数，有不少方法。比如基于素数定义的朴素算法，复杂度$O(\\sqrt{N})$ ；比如当筛取 $[1,N]$ 中所有素数时，可以通过欧拉筛实现 $O(N)$ 的线性筛. 如果要检测大量的随机数是否为素数，这两个方法显然都不适用。对于这种情况，我们使用基于素数定理逆命题的Miller-Rabin素性测试。 前置定理威尔逊定理若 $p$ 为素数，则 $(p-1)!\\equiv -1\\pmod{p}$ ，其逆定理也成立。 费马小定理定理的特殊形式若 $p$ 是素数， $a$ 为正整数，且 $a$ 与 $p$ 互质，则 $a^{p-1}\\equiv 1 \\pmod{p}$ 。 证明由于 $a$ 与 $p$ 互质，则 $a,2a,3a,\\cdots,(p-1)a$ 都与 $p$ 互质，且不存在 $i\\times a \\equiv j\\times a\\pmod p(1\\leq i &lt; j &lt; p)$ 。 因此 $a,2a,3a,\\cdots,(p-1)a$ 对 $p$ 的取余构成 $1,2,\\cdots,p-1$ 的排列。 那么 $a\\times 2a\\times 3a\\times \\cdots\\times (p-1)a\\equiv1\\times 2\\times 3\\times \\cdots\\times (p-1) \\pmod{p}$ 。 化简为 $a^{p-1}\\times(p-1)!\\equiv (p-1)!\\pmod{p}$，即 $a^{p-1}\\equiv 1\\pmod{p}$ 。 定理的一般形式若 $p$ 是素数，则 $a^p\\equiv a\\pmod{p}$ 。 证明如果 $a$ 能被 $p$ 整除，则上式显然成立；如果不能整除，那么 $gcd(a,p)=1$，对于这种情况前面已经证明。 而费马小定理是欧拉定理的一个特殊形式，$a^{\\varphi(p)}\\equiv 1\\pmod{p}$。因为根据定义，当 $p$ 是质数时， $\\varphi(p)=p-1$。 素性测试Fermat素性测试人们经过测试发现，如果一个数 $b$ 满足费马小定理的逆命题（令 $a=2$，$2^{b-1}\\equiv 1\\pmod{b}$ )，那么 $b$ 有很大可能是一个素数。 但是仅仅通过费马小定理的逆命题来判断素性显然是错误的，比如 $2^{560}\\equiv 1\\pmod{561}$ 但是 $561=11\\times 51$，这类数被称为伪素数。 后来人们把满足 $a^{b-1}\\equiv 1\\pmod{b}$ 的合数 $b$ 称为以 $a$ 为底的伪素数。 基于此，有一种方法就是预处理区间内的所有伪素数，那么满足 $2^{b-1}\\equiv 1\\pmod{b}$ 且不在伪素数表中的数就是素数。 然而使用这种方法过于麻烦，不用它错误率却不低，因此需要对原测试方法进行改进。 这种算法的问题在于无法鉴别出某些合数，由于费马小定理成立是素数的必要条件，因此不会出现将素数被判定成合数的情况。 既然它有一定概率判断正确，那么有一个很自然的想法。那便是用多组 $a_i(a_i &lt; b)$ 去检查 $b$ 是否满足 $a_{i}^{b-1}\\equiv 1\\pmod{b}$。如果同时成立， $b$ 是素数的概率应该会大幅增加，反之如果一次被判定为合数就确定其为合数。 简而言之，通过若干个小于待测数的正整数 $a$ 做底数进行测试素性的方法被称为Fermat素性测试。 Miller-Rabin素性测试二次探测定理优化定理若 $p$ 是素数，$x$ 为小于 $p$ 的正整数，且 $x^2\\equiv 1\\pmod{p}$，则 $x$ 为 $1$ 或 $p-1$ 。 证明$x^2=(x+1)(x-1)+1$，即 $p$ 能整除 $(x+1)(x-1)$，那么 $x$ 只能为 $1$ 或 $-1$ ，在模 $p$ 意义下即 $1$ 或 $p-1$。 通过二次探测定理，我们可以加强费马小定理，以此降低素性探测的错误率。 假设 $a$ 被判定为素数，即 $2^{a-1}\\equiv 1\\pmod{a}$，那么根据二次探测定理， $2^{\\frac{a-1}{2}}\\bmod a$ 只能为 $1$ 或 $a-1$。 拿 $561$ 举例子，虽然满足 $2^{280}\\bmod 561 = 1$，但是再往下一步却发现 $2^{140}\\bmod 561=67$，因此 $561$ 不是素数。 将其转化一般形式，用于检测正整数 $n​$ 的素性。 1.将 $n-1$ 表示为 $d\\times 2^{r}$ 的形式，其中 $d$ 是一个奇数。 2.依次检查 $2^{d\\times 2^{r-i}}\\bmod n$ 的值，如果 $2^{d\\times 2^{r-i}}\\bmod n = 1$ ，那么二次探测定理就继续适用于 $2^{d\\times 2^{r-i-1}}$ ，于是递增 $i$ 直到某个 $i$ 满足 $2^{d\\times {r-i}}\\bmod n =n-1$ 或 $r=i$ 结束。 换句话说，如果 $n$ 是一个素数，那么一定存在 $0\\leq i\\leq r$ 使得 $2^{d\\times 2^i}\\bmod n = n-1$ 或 $2^d\\bmod n=1$。不满足的 $n$ 一定是合数。 同理Fermat素性探测优化的想法，依然采取使用多个底数来降低错误率，即检测 $2^{d\\times 2^r},3^{d\\times 2^r},\\cdots$。 Miller-Rabin素性测试同样是不确定算法，我们把可以通过以 $a$ 为底的Miller-Rabin测试的合数称作以 $a$ 为底的强伪素数。 第一个以 $2$ 为底的强伪素数为 $2047$ ，而第一个以 $2$ 和 $3$ 为底的强伪素数则达到了 $1373653$ ，可以直观感受到Miller-Rabin素性探测的正确率之高。 根据 Wikipedia的相关词条，如果检测的正整数在 int 中（ $2^{32}$ ，即 $2.5\\times 10^9$ ），底数只需要前 $4$ 个素数作为底数，即 $2,3,5,7$；如果是 long long （ $2^{64}$ ，即 $1.85\\times 10^{19}$ ），则需要前 $13$ 个素数做底数，即 $2,3,5,\\cdots,41$ 。如此可以保证数据范围内的所有检测不会出错。 具体实现算法流程首先得到关于 $n-1$ 的 $r$ 和 $d$ 。对于每一轮（不同底数）通过快速幂得到 $a^{d}$ ，再依次检查 $2^{d\\times 2^i}\\bmod n$ 的值 ，直到 $i &gt; r$ 或者值为 $1$ 或 $n-1$ 。 若 $i &gt; r$ ，则判定 $n$ 为合数，否则继续测试下一个底数 。 注意事项int 与溢出即使素数测试的数据范围是 int，也不要吝啬使用 long long。两个 int 相乘会有溢出的可能，导致死循环或者判定结果出错。 浮点数与自然溢出如果数据范围是 long long ，那么两个 long long 相乘溢出是很有可能的，但是没有更大的类型可以使用。 常规解决方法就是采取类似快速幂的方法，通过二进制分解来实现乘法取模，但是复杂度为 $O(\\log{N})$。 还有一种 $O(1)$ 的方法，那便是将 $a\\times b\\bmod p$ 转化成 $a\\times b - (a / p\\times b)\\times p$ 。将 $a$ 强转成 long double 进行计算。 更具体地： 1234long long mul(long long x, long long y, long long m) { // x ^ y % mx %= m, y %= m;return (x * y - m * (long long)((long double)x / m * y) % m + m) % m;} 然而我没有理解C++对溢出的处理方式，所以无法对这个函数做出准确的解释。 不过这种方法在[2012集训队互测]JZPKIL的多份题解中被使用，实测也得到了正确的结果。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Copyright (C) 2018 Skqliao. All rights served.#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i &lt; _##i##_; ++i)#define rof(i, l, r) for (int i = (l) - 1, _##i##_ = (r); i &gt;= _##i##_; --i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) static_cast&lt;int&gt;((x).size())typedef long long ll;template&lt;typename T&gt; inline bool chkMin(T &amp;a, const T &amp;b) { return a &gt; b ? a = b, 1 : 0; }template&lt;typename T&gt; inline bool chkMax(T &amp;a, const T &amp;b) { return a &lt; b ? a = b, 1 : 0; }ll mul(ll x, ll y, ll m) {x %= m, y %= m;return (x * y - m * (ll)((long double)x / m * y) % m + m) % m;}ll pow(ll x, ll t, ll m) {ll res = 1;for(; t; t &gt;&gt;= 1, x = mul(x, x, m)) { if(t &amp; 1) { res = mul(res, x, m); }}return res;}bool miller_rabin(ll x) {static ll Prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41};if(x == 2 || x == 3) { return true;}if(x &lt; 2 || (x % 6 != 1 &amp;&amp; x % 6 != 5)) { return false;}ll s = x - 1;while(!(s &amp; 1)) { s &gt;&gt;= 1;}rep(i, 0, 13) { if(x == Prime[i]) { return true; } ll t = s, m = pow(Prime[i], s, x); while(t != x - 1 &amp;&amp; m != 1 &amp;&amp; m != x - 1) { m = mul(m, m, x); t &lt;&lt;= 1; } if(!(t &amp; 1) &amp;&amp; m != x - 1) { return false; }}return true;}int main() {return 0;} 参考资料 Miller_Rabin素数测试[Fermat小定理][二次探测定理][同余式][Wilson定理] | 学步园 Miller–Rabin primality test - Wikipedia 《信息学奥赛之数学一本通》","link":"/Miller-Rabin/"}],"tags":[{"name":"01字典树","slug":"01字典树","link":"/tags/01字典树/"},{"name":"最短路","slug":"最短路","link":"/tags/最短路/"},{"name":"对偶图","slug":"对偶图","link":"/tags/对偶图/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"Pruefer","slug":"Pruefer","link":"/tags/Pruefer/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"矩阵树定理","slug":"矩阵树定理","link":"/tags/矩阵树定理/"},{"name":"高精度","slug":"高精度","link":"/tags/高精度/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"斜率优化","slug":"斜率优化","link":"/tags/斜率优化/"},{"name":"单调队列","slug":"单调队列","link":"/tags/单调队列/"},{"name":"轻重链剖分","slug":"轻重链剖分","link":"/tags/轻重链剖分/"},{"name":"基环树","slug":"基环树","link":"/tags/基环树/"},{"name":"树形DP","slug":"树形DP","link":"/tags/树形DP/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"约数个数定理","slug":"约数个数定理","link":"/tags/约数个数定理/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"哈希","slug":"哈希","link":"/tags/哈希/"},{"name":"ST表","slug":"ST表","link":"/tags/ST表/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"动态点分治","slug":"动态点分治","link":"/tags/动态点分治/"},{"name":"堆","slug":"堆","link":"/tags/堆/"},{"name":"欧拉序","slug":"欧拉序","link":"/tags/欧拉序/"},{"name":"传递闭包","slug":"传递闭包","link":"/tags/传递闭包/"},{"name":"二分图最大匹配","slug":"二分图最大匹配","link":"/tags/二分图最大匹配/"},{"name":"平衡树","slug":"平衡树","link":"/tags/平衡树/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"差分约束","slug":"差分约束","link":"/tags/差分约束/"},{"name":"字典树","slug":"字典树","link":"/tags/字典树/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"最大密度子图","slug":"最大密度子图","link":"/tags/最大密度子图/"},{"name":"分数规划","slug":"分数规划","link":"/tags/分数规划/"},{"name":"最小割","slug":"最小割","link":"/tags/最小割/"},{"name":"左偏树","slug":"左偏树","link":"/tags/左偏树/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"二分答案","slug":"二分答案","link":"/tags/二分答案/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","link":"/tags/最大权闭合子图/"},{"name":"差分","slug":"差分","link":"/tags/差分/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"单调栈","slug":"单调栈","link":"/tags/单调栈/"},{"name":"最近公共祖先","slug":"最近公共祖先","link":"/tags/最近公共祖先/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"Floyd","slug":"Floyd","link":"/tags/Floyd/"},{"name":"二元关系","slug":"二元关系","link":"/tags/二元关系/"},{"name":"最小割树","slug":"最小割树","link":"/tags/最小割树/"},{"name":"费用流","slug":"费用流","link":"/tags/费用流/"},{"name":"斯坦纳树","slug":"斯坦纳树","link":"/tags/斯坦纳树/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"可持久化Trie","slug":"可持久化Trie","link":"/tags/可持久化Trie/"},{"name":"启发式合并","slug":"启发式合并","link":"/tags/启发式合并/"},{"name":"欧拉函数","slug":"欧拉函数","link":"/tags/欧拉函数/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/树链剖分/"},{"name":"欧拉回路","slug":"欧拉回路","link":"/tags/欧拉回路/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"状压DP","slug":"状压DP","link":"/tags/状压DP/"},{"name":"背包","slug":"背包","link":"/tags/背包/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"莫队","slug":"莫队","link":"/tags/莫队/"},{"name":"二分图","slug":"二分图","link":"/tags/二分图/"},{"name":"网络流","slug":"网络流","link":"/tags/网络流/"},{"name":"最小路径覆盖","slug":"最小路径覆盖","link":"/tags/最小路径覆盖/"},{"name":"分层图","slug":"分层图","link":"/tags/分层图/"},{"name":"最大点权独立集","slug":"最大点权独立集","link":"/tags/最大点权独立集/"},{"name":"二分图多重匹配","slug":"二分图多重匹配","link":"/tags/二分图多重匹配/"},{"name":"最大独立集","slug":"最大独立集","link":"/tags/最大独立集/"},{"name":"主席树","slug":"主席树","link":"/tags/主席树/"},{"name":"可持久化数组","slug":"可持久化数组","link":"/tags/可持久化数组/"},{"name":"树上启发式合并","slug":"树上启发式合并","link":"/tags/树上启发式合并/"},{"name":"树上差分","slug":"树上差分","link":"/tags/树上差分/"},{"name":"Miller-Rabin","slug":"Miller-Rabin","link":"/tags/Miller-Rabin/"},{"name":"数论","slug":"数论","link":"/tags/数论/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/学习笔记/"},{"name":"BZOJ","slug":"BZOJ","link":"/categories/BZOJ/"},{"name":"51nod","slug":"51nod","link":"/categories/51nod/"},{"name":"FZOJ","slug":"FZOJ","link":"/categories/FZOJ/"},{"name":"JZOJ","slug":"JZOJ","link":"/categories/JZOJ/"},{"name":"LOJ","slug":"LOJ","link":"/categories/LOJ/"},{"name":"codeforces","slug":"codeforces","link":"/categories/codeforces/"}]}