{"pages":[],"posts":[{"title":"【线段树+Kruskal】JZOJ 5060 公路建设","text":"题目大意有 $n$ 个点， $m$ 条边， $q$ 个询问。每次给定一个区间 $[l_i,r_i]$，求这些边构成的图在保证联通块个数最小的情况下所需最小花费。 数据范围$n\\leq 100$$m\\leq 100000$$q\\leq 15000$ 分析将题意翻译一下就是求区间最小生成树的权值。 假设已知 $[l,m]$ 和 $[m+1,r]$ 的最小生成树，那么 $[l,r]$ 的mst显然是由这两棵mst中的边构成的。 具体地说，在线段树中，通过Kruskal保存子区间mst上的所有边，然后用归并排序合并两个子区间的边，并再做kruskal求出父亲节点的mst上的所有边。查询时按照同样方法合并答案。 复杂度 $O(n\\alpha(n)(m\\log{m}+q\\log{m}))$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * @Author: Skqliao * @Date: 2019-01-26 16:40:30 * @LastEditTime: 2019-01-26 17:12:13 * @Source: GDOI2017第二轮模拟day1 * @Problem: JZOJ 5060 公路建设 * @Url: https://jzoj.net/senior/#main/show/5060 */#include &lt;bits/stdc++.h&gt;void open() { freopen(\"highway.in\", \"r\", stdin); freopen(\"highway.out\", \"w\", stdout);}const int MAXN = 100 + 5;const int MAXM = 100000 + 5;int N, M, Q;struct Node { int u, v, w; bool operator &lt; (const Node &amp;x) const { return w &lt; x.w; }} A[MAXM], T[MAXM &lt;&lt; 2][MAXN], Tmp[MAXN &lt;&lt; 1];#define LT rt &lt;&lt; 1, l, m#define RT rt &lt;&lt; 1 | 1, m + 1, rint Len[MAXM &lt;&lt; 2];int Anc[MAXN];int findAnc(int x) { return Anc[x] == x ? x : Anc[x] = findAnc(Anc[x]);}bool merge(int x, int y) { x = findAnc(x), y = findAnc(y); if (x != y) { Anc[y] = x; return true; } return false;}void pushUp(int x, int l, int r) { int len = std::merge(T[l], T[l] + Len[l], T[r], T[r] + Len[r], Tmp) - Tmp; for (int i = 1; i &lt;= N; ++i) { Anc[i] = i; } Len[x] = 0; for (int i = 0; i &lt; len; ++i) { if (merge(Tmp[i].u, Tmp[i].v)) { T[x][Len[x]++] = Tmp[i]; } }}void build(int rt, int l, int r) { if (l == r) { Len[rt] = 1; T[rt][0] = A[l]; return ; } int m = (l + r) &gt;&gt; 1; build(LT); build(RT); pushUp(rt, rt &lt;&lt; 1, rt &lt;&lt; 1 | 1);}void query(int rt, int l, int r, int a, int b) { if (a &lt;= l &amp;&amp; r &lt;= b) { pushUp(0, rt, 0); return ; } int m = (l + r) &gt;&gt; 1; if (a &lt;= m) { query(LT, a, b); } if (m &lt; b) { query(RT, a, b); }}int main() { open(); scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;Q); for (int i = 1; i &lt;= M; ++i) { scanf(\"%d%d%d\", &amp;A[i].u, &amp;A[i].v, &amp;A[i].w); } build(1, 1, M); int l, r; while (Q--) { long long sum = 0; scanf(\"%d%d\", &amp;l, &amp;r); Len[0] = 0; query(1, 1, M, l, r); for (int i = 0; i &lt; Len[0]; ++i) { sum += T[0][i].w; } printf(\"%lld\\n\", sum); } return 0;}","link":"/2019/02/06/JZOJ-5060/"}],"tags":[{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"}],"categories":[{"name":"BZOJ","slug":"BZOJ","link":"/categories/BZOJ/"},{"name":"图论","slug":"BZOJ/图论","link":"/categories/BZOJ/图论/"}]}